/* GENERATED AUTOMATICALLY */
/* DON'T MODIFY */

using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using SlimDX;
using SlimDX.D3DCompiler;
using SlimDX.Direct3D11;
using AcTools.Render.Base.Structs;
using AcTools.Render.Base.Utils;
// ReSharper disable InconsistentNaming
// ReSharper disable LocalizableElement

namespace AcTools.Render.Base.Shaders {
	public interface IEffectWrapper : System.IDisposable {
		void Initialize(Device device);
	}

	public interface IEffectMatricesWrapper : IEffectWrapper {
		EffectMatrixVariable FxWorld { get; }
		EffectMatrixVariable FxWorldInvTranspose { get; }
		EffectMatrixVariable FxWorldViewProj { get; }
	}

	public class EffectDeferredGObject : IEffectMatricesWrapper {
		[StructLayout(LayoutKind.Sequential)]
        public struct PosOnly_PS_IN {


			public static readonly int Stride = Marshal.SizeOf(typeof(PosOnly_PS_IN));
        }
		[StructLayout(LayoutKind.Sequential)]
        public struct Material {
            public float Ambient;
            public float Diffuse;
            public float Specular;
            public float SpecularExp;
            public float FresnelC;
            public float FresnelExp;
            public float FresnelMaxLevel;
            public float DetailsUvMultipler;
            public Vector3 Emissive;
            public float DetailsNormalBlend;
            public uint Flags;
            public Vector3 _padding;

			public static readonly int Stride = Marshal.SizeOf(typeof(Material));
        }
		[StructLayout(LayoutKind.Sequential)]
        public struct AmbientShadow_VS_IN {


			public static readonly int Stride = Marshal.SizeOf(typeof(AmbientShadow_VS_IN));
        }
		[StructLayout(LayoutKind.Sequential)]
        public struct AmbientShadow_PS_IN {


			public static readonly int Stride = Marshal.SizeOf(typeof(AmbientShadow_PS_IN));
        }
		public const uint HasNormalMap = 1;
		public const uint HasDetailsMap = 2;
		public const uint HasDetailsNormalMap = 4;
		public const uint HasMaps = 8;
		public const uint UseDiffuseAlphaAsMap = 16;
		public const uint AlphaBlend = 32;
		public const uint SpecialMapsMode = 64;
        public Effect E;

        public ShaderSignature InputSignaturePNTG, InputSignaturePT;
        public InputLayout LayoutPNTG, LayoutPT;

		public EffectTechnique TechStandardDeferred, TechStandardForward, TechAmbientShadowDeferred, TechTransparentDeferred, TechTransparentForward, TechTransparentMask;

		public EffectMatrixVariable FxWorld { get; private set; }
		public EffectMatrixVariable FxWorldInvTranspose { get; private set; }
		public EffectMatrixVariable FxWorldViewProj { get; private set; }
		public EffectResourceVariable FxDiffuseMap, FxNormalMap, FxMapsMap, FxDetailsMap, FxDetailsNormalMap, FxReflectionCubemap;
		public EffectVectorVariable FxEyePosW, FxAmbientDown, FxAmbientRange, FxLightColor, FxDirectionalLightDirection;
		public EffectVariable FxMaterial;

		public EffectDeferredGObject() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("#include \"Deferred.fx\"\n\n\n\tstatic const dword HAS_NORMAL_MAP = 1;\n\tstatic const dword HAS_DETAILS_MAP = 2;\n\tstatic const dword HAS_DETAILS_NORMAL_MAP = 4;\n\tstatic const dword HAS_MAPS = 8;\n\tstatic const dword USE_DIFFUSE_ALPHA_AS_MAP = 16;\n\tstatic const dword ALPHA_BLEND = 32;\n\tstatic const dword SPECIAL_MAPS_MODE = 64;\n\n\tstruct Material {\n\t\tfloat Ambient;\n\t\tfloat Diffuse;\n\t\tfloat Specular;\n\t\tfloat SpecularExp;\n\n\t\tfloat FresnelC;\n\t\tfloat FresnelExp;\n\t\tfloat FresnelMaxLevel;\n\t\tfloat DetailsUvMultipler;\n\n\t\tfloat3 Emissive;\n\t\tfloat DetailsNormalBlend;\n\n\t\tdword Flags;\n\t\tfloat3 _padding;\n\t};\n\n\n\tTexture2D gDiffuseMap;\n\tTexture2D gNormalMap;\n\tTexture2D gMapsMap;\n\tTexture2D gDetailsMap;\n\tTexture2D gDetailsNormalMap;\n\tTextureCube gReflectionCubemap;\n\n\n\tcbuffer cbPerObject : register(b0) {\n\t\tmatrix gWorld;\n\t\tmatrix gWorldInvTranspose;\n\t\tmatrix gWorldViewProj;\n\t\tMaterial gMaterial;\n\t}\n\n\tcbuffer cbPerFrame {\n\t\tfloat3 gEyePosW;\n\t\tfloat3 gAmbientDown;\n\t\tfloat3 gAmbientRange;\n\n\t\tfloat3 gLightColor;\n\t\tfloat3 gDirectionalLightDirection;\n\t}\n\n\n\tfloat3 CalcAmbient(float3 normal, float3 color) {\n\t\tfloat up = normal.y * 0.5 + 0.5;\n\t\tfloat3 ambient = gAmbientDown + up * gAmbientRange;\n\t\treturn ambient * color;\n\t}\n\n\n\tPS_IN vs_Standard(VS_IN vin) {\n\t\tPS_IN vout;\n\n\t\tvout.PosW = mul(float4(vin.PosL, 1.0f), gWorld).xyz;\n\t\tvout.NormalW = mul(vin.NormalL, (float3x3)gWorldInvTranspose);\n\t\tvout.TangentW = mul(vin.TangentL, (float3x3)gWorldInvTranspose);\n\n\t\tvout.PosH = mul(float4(vin.PosL, 1.0f), gWorldViewProj);\n\t\tvout.Tex = vin.Tex;\n\n\t\treturn vout;\n\t}\n\n\tPosOnly_PS_IN vs_PosOnly(VS_IN vin) {\n\t\tPosOnly_PS_IN vout;\n\t\tvout.PosH = mul(float4(vin.PosL, 1.0f), gWorldViewProj);\n\t\treturn vout;\n\t}\n\n\tfloat3 NormalSampleToWorldSpace(float3 normalMapSample, float3 unitNormalW, float3 tangentW){\n\t\t\n\t\tfloat3 normalT = 2.0f*normalMapSample - 1.0f;\n\n\t\t\n\t\tfloat3 N = unitNormalW;\n\t\tfloat3 T = normalize(tangentW - dot(tangentW, N)*N);\n\t\tfloat3 B = cross(N, T);\n\n\t\tfloat3x3 TBN = float3x3(T, B, N);\n\n\t\t\n\t\tfloat3 bumpedNormalW = mul(normalT, TBN);\n\t\treturn bumpedNormalW;\n\t}\n\n\tPS_OUT ps_StandardDeferred(PS_IN pin) : SV_Target{\n\t\tfloat4 diffuseValue = gDiffuseMap.Sample(samAnisotropic, pin.Tex);\n\n\t\tPS_OUT pout;\n\t\t\n\t\t[flatten]\n\t\tif ((gMaterial.Flags & HAS_NORMAL_MAP) == HAS_NORMAL_MAP){\n\t\t\tfloat4 normalValue = gNormalMap.Sample(samAnisotropic, pin.Tex);\n\t\t\n\t\t\t[flatten]\n\t\t\tif ((gMaterial.Flags & HAS_DETAILS_NORMAL_MAP) == HAS_DETAILS_NORMAL_MAP){\n\t\t\t\tfloat4 detailsNormalValue = gDetailsNormalMap.Sample(samAnisotropic, pin.Tex * gMaterial.DetailsUvMultipler);\n\t\t\t\tnormalValue += (detailsNormalValue - 0.5) * gMaterial.DetailsNormalBlend * (1.0 - diffuseValue.a);\n\t\t\t}\n\n\t\t\tpout.Normal = float4(normalize(NormalSampleToWorldSpace(normalize(normalValue.xyz), pin.NormalW, pin.TangentW)),\n\t\t\t\t\tnormalValue.a * diffuseValue.a);\n\t\t} else {\n\t\t\tpout.Normal = float4(normalize(pin.NormalW), diffuseValue.a);\n\t\t}\n\t\t\t\n\t\tpout.Normal.a = min(pout.Normal.a + 1.0 - (gMaterial.Flags & ALPHA_BLEND) / ALPHA_BLEND, 1.0);\n\n\t\tfloat specular = saturate(gMaterial.Specular / 2.5);\n\t\tfloat glossiness = saturate((gMaterial.SpecularExp - 1) / 400 + 0.5 * (gMaterial.Flags & SPECIAL_MAPS_MODE) / SPECIAL_MAPS_MODE);\n\t\tfloat reflectiveness = saturate(gMaterial.FresnelMaxLevel);\n\t\tfloat metalness = saturate(max(\n\t\t\t\tgMaterial.FresnelC / gMaterial.FresnelMaxLevel, \n\t\t\t\t1.1 / (gMaterial.FresnelExp + 1) - 0.1));\n\t\t\n\t\tif ((gMaterial.Flags & HAS_MAPS) == HAS_MAPS){\n\t\t\tfloat4 mapsValue = gMapsMap.Sample(samAnisotropic, pin.Tex);\n\t\t\tspecular *= mapsValue.r;\n\t\t\tglossiness *= mapsValue.g;\n\t\t\treflectiveness *= mapsValue.b;\n\t\t}\n\t\t\n\t\tif ((gMaterial.Flags & USE_DIFFUSE_ALPHA_AS_MAP) == USE_DIFFUSE_ALPHA_AS_MAP){\n\t\t\tspecular *= diffuseValue.a;\n\t\t\treflectiveness *= diffuseValue.a / 2 + 0.5;\n\t\t}\n\t\t\n\t\t\n\t\t[flatten]\n\t\tif ((gMaterial.Flags & HAS_DETAILS_MAP) == HAS_DETAILS_MAP){\n\t\t\tfloat4 detailsValue = gDetailsMap.Sample(samAnisotropic, pin.Tex * gMaterial.DetailsUvMultipler);\n\n\t\t\tdiffuseValue *= diffuseValue.a + detailsValue - detailsValue * diffuseValue.a;\n\t\t\tglossiness *= (1.0 - detailsValue.a * (1.0 - diffuseValue.a)) / 2 + 0.5;\n\t\t}\n\t\t\n\t\tfloat ambient = max(gMaterial.Ambient, 0.05);\n\t\tpout.Base = float4(CalcAmbient(pout.Normal.xyz, diffuseValue.rgb * ambient), gMaterial.Diffuse / ambient);\n\t\t\n\t\t\n\t\tpout.Maps = float4(specular, glossiness, reflectiveness, metalness);\n\t\treturn pout;\n\t}\n\n\ttechnique11 StandardDeferred {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_Standard() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_5_0, ps_StandardDeferred() ) );\n\t\t}\n\t}\n\n\tfloat4 ps_StandardForward(PS_IN pin) : SV_Target {\n\t\tfloat4 diffuseValue = gDiffuseMap.Sample(samAnisotropic, pin.Tex);\n\t\tfloat ambient = max(gMaterial.Ambient, 0.05);\n\n\t\tfloat3 normal;\n\t\t[flatten]\n\t\tif ((gMaterial.Flags & HAS_NORMAL_MAP) == HAS_NORMAL_MAP) {\n\t\t\tfloat4 normalValue = gNormalMap.Sample(samAnisotropic, pin.Tex);\n\t\t\tnormal = normalize(NormalSampleToWorldSpace(normalize(normalValue.xyz), pin.NormalW, pin.TangentW));\n\t\t} else {\n\t\t\tnormal = normalize(pin.NormalW);\n\t\t}\n\n\t\tfloat3 toLight = -gDirectionalLightDirection;\n\t\tfloat lightness = saturate(dot(normal, toLight));\n\n\t\tfloat3 lighted = CalcAmbient(normal, diffuseValue.rgb * ambient) + \n\t\t\t\tdiffuseValue.rgb * gMaterial.Diffuse * gLightColor * lightness;\n\n\t\treturn float4(lighted, 1.0);\n\t}\n\n\ttechnique11 StandardForward {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_Standard() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_4_0, ps_StandardForward() ) );\n\t\t}\n\t}\n\n\n\tstruct AmbientShadow_VS_IN {\n\t\tfloat3 PosL       : POSITION;\n\t\tfloat2 Tex        : TEXCOORD;\n\t};\n\n\tstruct AmbientShadow_PS_IN {\n\t\tfloat4 PosH       : SV_POSITION;\n\t\tfloat3 PosW       : POSITION;\n\t\tfloat2 Tex        : TEXCOORD;\n\t};\n\n\tAmbientShadow_PS_IN vs_AmbientShadowDeferred(AmbientShadow_VS_IN vin) {\n\t\tAmbientShadow_PS_IN vout;\n\t\tvout.PosW = mul(float4(vin.PosL, 1.0f), gWorld).xyz;\n\t\tvout.PosH = mul(float4(vin.PosL, 1.0f), gWorldViewProj);\n\t\tvout.Tex = vin.Tex;\n\t\treturn vout;\n\t}\n\n\tPS_OUT ps_AmbientShadowDeferred(AmbientShadow_PS_IN pin) : SV_Target {\n\t\tPS_OUT pout;\n\n\t\tfloat4 diffuseValue = gDiffuseMap.Sample(samAnisotropic, pin.Tex);\n\t\tfloat shadowLevel = diffuseValue.x * 1.15;\n\n\t\tpout.Base = float4(0, 0, 0, shadowLevel);\n\t\tpout.Normal = 0;\n\t\tpout.Maps = float4(0, 0, 0, shadowLevel);\n\n\t\treturn pout;\n\t}\n\n\ttechnique11 AmbientShadowDeferred {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_5_0, vs_AmbientShadowDeferred() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_5_0, ps_AmbientShadowDeferred() ) );\n\t\t}\n\t}\n\n\n\ttechnique11 TransparentDeferred {\n\t\tpass P0 {\n\t\t\tSetVertexShader(CompileShader(vs_4_0, vs_Standard()));\n\t\t\tSetGeometryShader(NULL);\n\t\t\tSetPixelShader(CompileShader(ps_4_0, ps_StandardDeferred()));\n\t\t}\n\t}\n\n\n\tfloat4 ps_TransparentForward(PS_IN pin) : SV_Target{\n\t\tfloat4 diffuseValue = gDiffuseMap.Sample(samAnisotropic, pin.Tex);\n\n\t\tfloat alpha = diffuseValue.a;\n\t\tfloat3 normal;\n\n\t\t[flatten]\n\t\tif ((gMaterial.Flags & HAS_NORMAL_MAP) == HAS_NORMAL_MAP) {\n\t\t\tfloat4 normalValue = gNormalMap.Sample(samAnisotropic, pin.Tex);\n\t\t\talpha *= normalValue.a;\n\t\t\tnormal = normalize(NormalSampleToWorldSpace(normalize(normalValue.xyz), pin.NormalW, pin.TangentW));\n\t\t}\n\t\telse {\n\t\t\tnormal = normalize(pin.NormalW);\n\t\t}\n\n\t\tfloat3 color = CalcAmbient(normal, diffuseValue.rgb);\n\n\t\tfloat specular = saturate(gMaterial.Specular / 2.5);\n\t\tfloat glossiness = saturate((gMaterial.SpecularExp - 1) / 400 + (gMaterial.Flags & SPECIAL_MAPS_MODE) / SPECIAL_MAPS_MODE);\n\t\tfloat reflectiveness = saturate(gMaterial.FresnelMaxLevel);\n\t\tfloat metalness = saturate(max(\n\t\t\t\tgMaterial.FresnelC / gMaterial.FresnelMaxLevel,\n\t\t\t\t1.1 / (gMaterial.FresnelExp + 1) - 0.1));\n\n\t\tfloat3 toEyeW = normalize(gEyePosW - pin.PosW);\n\n\t\tfloat rid = saturate(dot(toEyeW, pin.NormalW));\n\t\tfloat rim = pow(1 - rid, gMaterial.FresnelExp);\n\n\t\tfloat4 reflectionColor = gReflectionCubemap.SampleBias(samAnisotropic, reflect(-toEyeW, normal),\n\t\t\t1.0f - glossiness);\n\n\t\t\n\t\treturn float4(color * (gMaterial.Ambient - reflectiveness / 2) + reflectionColor * reflectiveness * rim, alpha);\n\t}\n\n\ttechnique11 TransparentForward {\n\t\tpass P0 {\n\t\t\tSetVertexShader(CompileShader(vs_4_0, vs_Standard()));\n\t\t\tSetGeometryShader(NULL);\n\t\t\tSetPixelShader(CompileShader(ps_4_0, ps_TransparentForward()));\n\t\t}\n\t}\n\n\ttechnique11 TransparentMask {\n\t\tpass P0 {\n\t\t\tSetVertexShader(CompileShader(vs_4_0, vs_PosOnly()));\n\t\t\tSetGeometryShader(NULL);\n\t\t\tSetPixelShader(NULL);\n\t\t}\n\t}"), "DeferredGObject")){
                E = new Effect(device, bc);
			}

			TechStandardDeferred = E.GetTechniqueByName("StandardDeferred");
			TechStandardForward = E.GetTechniqueByName("StandardForward");
			TechAmbientShadowDeferred = E.GetTechniqueByName("AmbientShadowDeferred");
			TechTransparentDeferred = E.GetTechniqueByName("TransparentDeferred");
			TechTransparentForward = E.GetTechniqueByName("TransparentForward");
			TechTransparentMask = E.GetTechniqueByName("TransparentMask");

			for (var i = 0; i < TechStandardDeferred.Description.PassCount && InputSignaturePNTG == null; i++) {
				InputSignaturePNTG = TechStandardDeferred.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePNTG == null) throw new System.Exception("input signature (DeferredGObject, PNTG, StandardDeferred) == null");
			LayoutPNTG = new InputLayout(device, InputSignaturePNTG, InputLayouts.VerticePNTG.InputElementsValue);
			for (var i = 0; i < TechAmbientShadowDeferred.Description.PassCount && InputSignaturePT == null; i++) {
				InputSignaturePT = TechAmbientShadowDeferred.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePT == null) throw new System.Exception("input signature (DeferredGObject, PT, AmbientShadowDeferred) == null");
			LayoutPT = new InputLayout(device, InputSignaturePT, InputLayouts.VerticePT.InputElementsValue);

			FxWorld = E.GetVariableByName("gWorld").AsMatrix();
			FxWorldInvTranspose = E.GetVariableByName("gWorldInvTranspose").AsMatrix();
			FxWorldViewProj = E.GetVariableByName("gWorldViewProj").AsMatrix();
			FxDiffuseMap = E.GetVariableByName("gDiffuseMap").AsResource();
			FxNormalMap = E.GetVariableByName("gNormalMap").AsResource();
			FxMapsMap = E.GetVariableByName("gMapsMap").AsResource();
			FxDetailsMap = E.GetVariableByName("gDetailsMap").AsResource();
			FxDetailsNormalMap = E.GetVariableByName("gDetailsNormalMap").AsResource();
			FxReflectionCubemap = E.GetVariableByName("gReflectionCubemap").AsResource();
			FxEyePosW = E.GetVariableByName("gEyePosW").AsVector();
			FxAmbientDown = E.GetVariableByName("gAmbientDown").AsVector();
			FxAmbientRange = E.GetVariableByName("gAmbientRange").AsVector();
			FxLightColor = E.GetVariableByName("gLightColor").AsVector();
			FxDirectionalLightDirection = E.GetVariableByName("gDirectionalLightDirection").AsVector();
			FxMaterial = E.GetVariableByName("gMaterial");
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePNTG.Dispose();
            LayoutPNTG.Dispose();
			InputSignaturePT.Dispose();
            LayoutPT.Dispose();
        }
	}

	public class EffectDeferredGObjectSpecial : IEffectMatricesWrapper {
		[StructLayout(LayoutKind.Sequential)]
        public struct PosOnly_PS_IN {


			public static readonly int Stride = Marshal.SizeOf(typeof(PosOnly_PS_IN));
        }
		[StructLayout(LayoutKind.Sequential)]
        public struct SpecialGl_PS_IN {


			public static readonly int Stride = Marshal.SizeOf(typeof(SpecialGl_PS_IN));
        }
		
        public Effect E;

        public ShaderSignature InputSignaturePNTG;
        public InputLayout LayoutPNTG;

		public EffectTechnique TechSpecialGlDeferred, TechSpecialGlForward, TechSpecialGlMask;

		public EffectMatrixVariable FxWorld { get; private set; }
		public EffectMatrixVariable FxWorldInvTranspose { get; private set; }
		public EffectMatrixVariable FxWorldViewProj { get; private set; }

		public EffectDeferredGObjectSpecial() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("#include \"Deferred.fx\"\n\n\n\tcbuffer cbPerObject : register(b0) {\n\t\tmatrix gWorld;\n\t\tmatrix gWorldInvTranspose;\n\t\tmatrix gWorldViewProj;\n\t}\n\n\n\tstruct SpecialGl_PS_IN {\n\t\tfloat4 PosH       : SV_POSITION;\n\t\tfloat3 NormalW    : NORMAL;\n\t\tfloat3 PosL       : POSITION;\n\t};\n\n\tSpecialGl_PS_IN vs_SpecialGl(VS_IN vin) {\n\t\tSpecialGl_PS_IN vout;\n\t\tvout.PosH = mul(float4(vin.PosL, 1.0f), gWorldViewProj);\n\t\tvout.PosL = vin.PosL;\n\t\tvout.NormalW = mul(vin.NormalL, (float3x3)gWorldInvTranspose);\n\t\treturn vout;\n\t}\n\n\tPosOnly_PS_IN vs_PosOnly(VS_IN vin) {\n\t\tPosOnly_PS_IN vout;\n\t\tvout.PosH = mul(float4(vin.PosL, 1.0f), gWorldViewProj);\n\t\treturn vout;\n\t}\n\n\tPS_OUT ps_SpecialGlDeferred(SpecialGl_PS_IN pin) : SV_Target {\n\t\tPS_OUT pout;\n\t\tpout.Base = float4(normalize(pin.PosL), 1.0);\n\t\tpout.Normal = normalize(pin.NormalW);\n\t\tpout.Maps = 0;\n\t\treturn pout;\n\t}\n\n\ttechnique11 SpecialGlDeferred {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_SpecialGl() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_4_0, ps_SpecialGlDeferred() ) );\n\t\t}\n\t}\n\n\tfloat4 ps_SpecialGlForward(SpecialGl_PS_IN pin) : SV_Target {\n\t\treturn float4(normalize(pin.PosL), 1.0);\n\t}\n\n\ttechnique11 SpecialGlForward {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_SpecialGl() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_4_0, ps_SpecialGlForward() ) );\n\t\t}\n\t}\n\n\ttechnique11 SpecialGlMask {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_PosOnly() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( NULL );\n\t\t}\n\t}"), "DeferredGObjectSpecial")){
                E = new Effect(device, bc);
			}

			TechSpecialGlDeferred = E.GetTechniqueByName("SpecialGlDeferred");
			TechSpecialGlForward = E.GetTechniqueByName("SpecialGlForward");
			TechSpecialGlMask = E.GetTechniqueByName("SpecialGlMask");

			for (var i = 0; i < TechSpecialGlDeferred.Description.PassCount && InputSignaturePNTG == null; i++) {
				InputSignaturePNTG = TechSpecialGlDeferred.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePNTG == null) throw new System.Exception("input signature (DeferredGObjectSpecial, PNTG, SpecialGlDeferred) == null");
			LayoutPNTG = new InputLayout(device, InputSignaturePNTG, InputLayouts.VerticePNTG.InputElementsValue);

			FxWorld = E.GetVariableByName("gWorld").AsMatrix();
			FxWorldInvTranspose = E.GetVariableByName("gWorldInvTranspose").AsMatrix();
			FxWorldViewProj = E.GetVariableByName("gWorldViewProj").AsMatrix();
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePNTG.Dispose();
            LayoutPNTG.Dispose();
        }
	}

	public class EffectDeferredGSky : IEffectMatricesWrapper {
		[StructLayout(LayoutKind.Sequential)]
        public struct PosOnly_PS_IN {


			public static readonly int Stride = Marshal.SizeOf(typeof(PosOnly_PS_IN));
        }
		[StructLayout(LayoutKind.Sequential)]
        public struct Sky_VS_IN {


			public static readonly int Stride = Marshal.SizeOf(typeof(Sky_VS_IN));
        }
		[StructLayout(LayoutKind.Sequential)]
        public struct Sky_PS_IN {


			public static readonly int Stride = Marshal.SizeOf(typeof(Sky_PS_IN));
        }
		
        public Effect E;

        public ShaderSignature InputSignatureP;
        public InputLayout LayoutP;

		public EffectTechnique TechSkyDeferred, TechSkyForward;

		public EffectMatrixVariable FxWorld { get; private set; }
		public EffectMatrixVariable FxWorldInvTranspose { get; private set; }
		public EffectMatrixVariable FxWorldViewProj { get; private set; }
		public EffectVectorVariable FxSkyDown, FxSkyRange;

		public EffectDeferredGSky() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("#include \"Deferred.fx\"\n\n\n\tcbuffer cbPerObject : register(b0) {\n\t\tmatrix gWorld;\n\t\tmatrix gWorldInvTranspose;\n\t\tmatrix gWorldViewProj;\n\t}\n\n\tcbuffer cbPerFrame {\n\t\tfloat3 gSkyDown;\n\t\tfloat3 gSkyRange;\n\t}\n\n\n\tstruct Sky_VS_IN {\n\t\tfloat3 PosL       : POSITION;\n\t};\n\n\tstruct Sky_PS_IN {\n\t\tfloat4 PosH       : SV_POSITION;\n\t\tfloat3 PosL       : POSITION;\n\t};\n\n\tfloat3 CalcSky(float3 normal) {\n\t\tfloat up = normal.y * 0.5 + 0.5;\n\t\treturn gSkyDown + up * gSkyRange;\n\t\treturn up;\n\t\treturn saturate(((up * 100) % 2 - 1.0) * 1e6);\n\t}\n\n\tSky_PS_IN vs_Sky(Sky_VS_IN vin) {\n\t\tSky_PS_IN vout;\n\t\tvout.PosH = mul(float4(vin.PosL, 1.0f), gWorldViewProj);\n\t\tvout.PosL = vin.PosL;\n\t\treturn vout;\n\t}\n\n\tPS_OUT ps_SkyDeferred(Sky_PS_IN pin) : SV_Target {\n\t\tfloat3 normal = normalize(pin.PosL);\n\n\t\tPS_OUT pout;\n\t\tpout.Base = float4(CalcSky(normal), 1.0);\n\t\tpout.Normal = float4(normal, 1.0);\n\t\tpout.Maps = 0;\n\t\treturn pout;\n\t}\n\n\ttechnique11 SkyDeferred {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_Sky() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_4_0, ps_SkyDeferred() ) );\n\t\t}\n\t}\n\n\tfloat4 ps_SkyForward(Sky_PS_IN pin) : SV_Target {\n\t\tfloat3 normal = normalize(pin.PosL);\n\t\treturn float4(CalcSky(normal), 1.0);\n\t}\n\n\ttechnique11 SkyForward {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_Sky() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_4_0, ps_SkyForward() ) );\n\t\t}\n\t}"), "DeferredGSky")){
                E = new Effect(device, bc);
			}

			TechSkyDeferred = E.GetTechniqueByName("SkyDeferred");
			TechSkyForward = E.GetTechniqueByName("SkyForward");

			for (var i = 0; i < TechSkyDeferred.Description.PassCount && InputSignatureP == null; i++) {
				InputSignatureP = TechSkyDeferred.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignatureP == null) throw new System.Exception("input signature (DeferredGSky, P, SkyDeferred) == null");
			LayoutP = new InputLayout(device, InputSignatureP, InputLayouts.VerticeP.InputElementsValue);

			FxWorld = E.GetVariableByName("gWorld").AsMatrix();
			FxWorldInvTranspose = E.GetVariableByName("gWorldInvTranspose").AsMatrix();
			FxWorldViewProj = E.GetVariableByName("gWorldViewProj").AsMatrix();
			FxSkyDown = E.GetVariableByName("gSkyDown").AsVector();
			FxSkyRange = E.GetVariableByName("gSkyRange").AsVector();
		}

        public void Dispose() {
            E.Dispose();
			InputSignatureP.Dispose();
            LayoutP.Dispose();
        }
	}

	public class EffectDeferredLight : IEffectMatricesWrapper {
		
		public const int NumSplits = 4;
		public const float SmapSize = 2048.0f;
		public const float SmapDx = 1.0f / 2048.0f;
        public Effect E;

        public ShaderSignature InputSignaturePT;
        public InputLayout LayoutPT;

		public EffectTechnique TechPointLight, TechDirectionalLight, TechDirectionalLight_Shadows, TechDirectionalLight_Shadows_NoFilter, TechDirectionalLight_Split;

		public EffectMatrixVariable FxWorld { get; private set; }
		public EffectMatrixVariable FxWorldInvTranspose { get; private set; }
		public EffectMatrixVariable FxWorldViewProj { get; private set; }
		public EffectMatrixVariable FxWorldViewProjInv { get; private set; }
		public EffectMatrixVariable FxShadowViewProj { get; private set; }
		public EffectResourceVariable FxBaseMap, FxNormalMap, FxMapsMap, FxDepthMap, FxShadowMaps;
		public EffectScalarVariable FxPointLightRadius;
		public EffectVectorVariable FxScreenSize, FxLightColor, FxDirectionalLightDirection, FxPointLightPosition, FxShadowDepths, FxEyePosW;

		public EffectDeferredLight() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("\n    Texture2D gBaseMap;\n    Texture2D gNormalMap;\n    Texture2D gMapsMap;\n    Texture2D gDepthMap;\n\n\tstatic const int NUM_SPLITS = 4;\n\tTexture2D gShadowMaps[NUM_SPLITS];\n\n    SamplerState samInputImage {\n        Filter = MIN_MAG_LINEAR_MIP_POINT;\n        AddressU = CLAMP;\n        AddressV = CLAMP;\n    };\n\n\n    cbuffer cbPerObject : register(b0) {\n        matrix gWorld;\n        matrix gWorldInvTranspose;\n        matrix gWorldViewProj;\n\n        float4 gScreenSize;\n\n        matrix gWorldViewProjInv;\n        float3 gLightColor;\n\n        float3 gDirectionalLightDirection;\n\n        float3 gPointLightPosition;\n        float gPointLightRadius;\n\n\t\tfloat4 gShadowDepths;\n\t\tmatrix gShadowViewProj[NUM_SPLITS];\n    }\n\n    cbuffer cbPerFrame {\n        float3 gEyePosW;\n    }\n\n\n    struct VS_IN {\n        float3 PosL    : POSITION;\n        float2 Tex     : TEXCOORD;\n    };\n\n    struct VS_REPL_IN {\n        float3 PosL       : POSITION;\n        float3 NormalL    : NORMAL;\n        float2 Tex        : TEXCOORD;\n        float3 TangentL   : TANGENT;\n    };\n\n    struct PS_IN {\n        float4 PosH    : SV_POSITION;\n        float2 Tex     : TEXCOORD;\n    };\n\n\n    PS_IN vs_main(VS_IN vin) {\n        PS_IN vout;\n        vout.PosH = float4(vin.PosL, 1.0f);\n        vout.Tex = vin.Tex;\n        return vout;\n    }\n\n    PS_IN vs_replacement(VS_REPL_IN vin) {\n        PS_IN vout;\n        vout.PosH = mul(float4(vin.PosL, 1.0f), gWorldViewProj);\n        vout.Tex = vin.Tex;\n        return vout;\n    }\n\n\n    float3 GetPosition(float2 uv, float depth) {\n        float4 position = mul(float4(uv.x * 2 - 1, -(uv.y * 2 - 1), depth, 1), gWorldViewProjInv);\n        return position.xyz / position.w;\n    }\n\n\tvoid GetParams(float2 uv,\n\t\tout float3 normal, out float3 position, out float depth,\n\t\tout float3 lightResult,\n\t\tout float specIntensity, out float specExp\n\t\t) {\n\n\t\tnormal = gNormalMap.Sample(samInputImage, uv).xyz;\n\t\tdepth = gDepthMap.Sample(samInputImage, uv).x;\n\t\tposition = GetPosition(uv, depth);\n\n\t\tfloat4 baseValue = gBaseMap.Sample(samInputImage, uv);\n\t\tlightResult = baseValue.rgb * baseValue.a * gLightColor;\n\n\t\tfloat4 mapsValue = gMapsMap.Sample(samInputImage, uv);\n\t\tspecIntensity = mapsValue.r * 1.2;\n\t\tspecExp = mapsValue.g * 250 + 1;\n\t}\n\n\n    float4 ps_PointLight_inner(float2 tex) {\n        float3 normal, position, lightResult;\n        float depth, specIntensity, specExp;\n        GetParams(tex, normal, position, depth, lightResult, specIntensity, specExp);\n\n        float3 lightVector = gPointLightPosition - position;\n        float3 toLight = normalize(lightVector);\n\n        float distance = dot(lightVector, lightVector);\n        float lightness = saturate(dot(normal, toLight)) * saturate(1 - distance / gPointLightRadius);\n\n        float3 toEye = normalize(gEyePosW - position);\n        float3 halfway = normalize(toEye + toLight);\n\n        float nDotH = saturate(dot(halfway, normal));\n        float specularLightness = pow(nDotH, specExp) * specIntensity;\n\n        [flatten]\n        if (specExp > 30) {\n            specularLightness += pow(nDotH, specExp * 10 + 5000) * (specIntensity * 12 + 5) * saturate((specExp - 30) / 40);\n        }\n\n        lightResult += specularLightness * gLightColor;\n        return float4(lightResult, lightness + specularLightness);\n    }\n\n\tfloat4 ps_PointLight(PS_IN pin) : SV_Target {\n\t\treturn ps_PointLight_inner(pin.Tex);\n\t}\n\n    technique11 PointLight {\n        pass P0 {\n            SetVertexShader(CompileShader(vs_4_0, vs_main()));\n            SetGeometryShader(NULL);\n            SetPixelShader(CompileShader(ps_4_0, ps_PointLight()));\n        }\n    }\n\n\n\tSamplerComparisonState samShadow {\n\t\tFilter = COMPARISON_MIN_MAG_MIP_LINEAR;\n\t\tAddressU = BORDER;\n\t\tAddressV = BORDER;\n\t\tAddressW = BORDER;\n\t\tBorderColor = float4(1.0f, 1.0f, 1.0f, 0.0f);\n\n\t\tComparisonFunc = LESS;\n\t};\n\n\tSamplerState samShadowSpecial {\n\t\tFilter = MIN_MAG_MIP_LINEAR;\n\t\tAddressU = BORDER;\n\t\tAddressV = BORDER;\n\t\tAddressW = BORDER;\n\t\tBorderColor = float4(1.0f, 1.0f, 1.0f, 0.0f);\n\t};\n\n\tstatic const float SMAP_SIZE = 2048.0f;\n\tstatic const float SMAP_DX = 1.0f / 2048.0f;\n\n\tfloat GetShadowInner(float3 position, Texture2D tex, matrix viewProj) {\n\t\tfloat4 uv = mul(float4(position, 1.0f), viewProj);\n\t\tuv.xyz /= uv.w;\n\n\t\tfloat shadow = 0.0, x, y;\n\t\tfor (y = -1.5; y <= 1.5; y += 1.0)\n\t\t\tfor (x = -1.5; x <= 1.5; x += 1.0)\n\t\t\t\tshadow += tex.SampleCmpLevelZero(samShadow, uv.xy + float2(x, y) * SMAP_DX, uv.z).r;\n\t\treturn shadow / 16.0;\n\t}\n\n\tfloat GetShadow(float3 position, float depth) {\n\t\tfloat shadow0, shadow1, edge;\n\t\tif (depth > gShadowDepths.w) {\n\t\t\treturn 1;\n\t\t} else if (depth > gShadowDepths.w) {\n\t\t\tshadow0 = GetShadowInner(position, gShadowMaps[3], gShadowViewProj[3]);\n\t\t\tshadow1 = 1;\n\t\t\tedge = gShadowDepths.w;\n\t\t} else if (depth > gShadowDepths.y) {\n\t\t\tshadow0 = GetShadowInner(position, gShadowMaps[2], gShadowViewProj[2]);\n\t\t\tshadow1 = GetShadowInner(position, gShadowMaps[3], gShadowViewProj[3]);\n\t\t\tedge = gShadowDepths.z;\n\t\t} else if (depth > gShadowDepths.x) {\n\t\t\tshadow0 = GetShadowInner(position, gShadowMaps[1], gShadowViewProj[1]);\n\t\t\tshadow1 = GetShadowInner(position, gShadowMaps[2], gShadowViewProj[2]);\n\t\t\tedge = gShadowDepths.y;\n\t\t} else {\n\t\t\tshadow0 = GetShadowInner(position, gShadowMaps[0], gShadowViewProj[0]);\n\t\t\tshadow1 = GetShadowInner(position, gShadowMaps[1], gShadowViewProj[1]);\n\t\t\tedge = gShadowDepths.x;\n\t\t}\n\n\t\tfloat k = saturate((depth / edge - 0.995) * 200.0);\n\t\tfloat shadow = shadow0 * (1 - k) + shadow1 * k;\n\n\t\tshadow = saturate((shadow - 0.5) * 8 + 0.5);\n\t\treturn shadow;\n\t}\n\n\tfloat GetShadowInner_NoFilter(float3 position, Texture2D tex, matrix viewProj) {\n\t\tfloat4 uv = mul(float4(position, 1.0f), viewProj);\n\t\tuv.xyz /= uv.w;\n\t\treturn tex.SampleCmpLevelZero(samShadow, uv.xy, uv.z).r;\n\t}\n\n\tfloat GetShadow_NoFilter2(float3 position, float depth) {\n\t\tif (depth > gShadowDepths.w) {\n\t\t\treturn 1;\n\t\t} else if (depth > gShadowDepths.w) {\n\t\t\treturn GetShadowInner_NoFilter(position, gShadowMaps[3], gShadowViewProj[3]);\n\t\t} else if (depth > gShadowDepths.y) {\n\t\t\treturn GetShadowInner_NoFilter(position, gShadowMaps[2], gShadowViewProj[2]);\n\t\t} else if (depth > gShadowDepths.x) {\n\t\t\treturn GetShadowInner_NoFilter(position, gShadowMaps[1], gShadowViewProj[1]);\n\t\t} else {\n\t\t\treturn GetShadowInner_NoFilter(position, gShadowMaps[0], gShadowViewProj[0]);\n\t\t}\n\t}\n\n\tfloat GetShadow_NoFilter(float3 position, float depth) {\n\t\tfloat4 pos = float4(position, 1.0f), uv, nv;\n\n\t\tuv = mul(pos, gShadowViewProj[3]);\n\t\tuv.xyz /= uv.w;\n\t\tif (uv.x < 0 || uv.x > 1 || uv.y < 0 || uv.y > 1) return 1;\n\n\t\tnv = mul(pos, gShadowViewProj[2]);\n\t\tnv.xyz /= nv.w;\n\t\tif (nv.x < 0 || nv.x > 1 || nv.y < 0 || nv.y > 1) return gShadowMaps[3].SampleCmpLevelZero(samShadow, uv.xy, uv.z).r;\n\t\tuv = nv;\n\n\t\tnv = mul(pos, gShadowViewProj[1]);\n\t\tnv.xyz /= nv.w;\n\t\tif (nv.x < 0 || nv.x > 1 || nv.y < 0 || nv.y > 1) return gShadowMaps[2].SampleCmpLevelZero(samShadow, uv.xy, uv.z).r;\n\t\tuv = nv;\n\n\t\tnv = mul(pos, gShadowViewProj[0]);\n\t\tnv.xyz /= nv.w;\n\t\tif (nv.x < 0 || nv.x > 1 || nv.y < 0 || nv.y > 1) return gShadowMaps[1].SampleCmpLevelZero(samShadow, uv.xy, uv.z).r;\n\t\t\n\t\treturn gShadowMaps[0].SampleCmpLevelZero(samShadow, nv.xy, nv.z).r;\n\t}\n\n\tfloat4 ps_DirectionalLight(PS_IN pin) : SV_Target {\n        float3 normal, position, lightResult;\n        float depth, specIntensity, specExp;\n        GetParams(pin.Tex, normal, position, depth, lightResult, specIntensity, specExp);\n\n\t\tfloat3 toLight = -gDirectionalLightDirection;\n\t\tfloat lightness = saturate(dot(normal, toLight));\n\n\t\tfloat3 toEye = normalize(gEyePosW - position);\n\t\tfloat3 halfway = normalize(toEye + toLight);\n\n\t\tfloat nDotH = saturate(dot(halfway, normal));\n\t\tfloat specularLightness = pow(nDotH, specExp) * specIntensity;\n\n\t\t[flatten]\n\t\tif (specExp > 30) {\n\t\t\tspecularLightness += pow(nDotH, specExp * 10 + 5000) * (specIntensity * 12 + 5) * saturate((specExp - 30) / 40);\n\t\t}\n\n\t\tlightResult += specularLightness * gLightColor;\n\t\treturn float4(lightResult, lightness + specularLightness);\n\t}\n\n\tfloat4 ps_DirectionalLight_Shadows(PS_IN pin) : SV_Target {\n        float3 normal, position, lightResult;\n        float depth, specIntensity, specExp;\n        GetParams(pin.Tex, normal, position, depth, lightResult, specIntensity, specExp);\n\n\t\tfloat3 toLight = -gDirectionalLightDirection;\n\t\tfloat lightness = saturate(dot(normal, toLight));\n\t\tlightness *= GetShadow(position, depth);\n\n\t\tfloat3 toEye = normalize(gEyePosW - position);\n\t\tfloat3 halfway = normalize(toEye + toLight);\n\n\t\tfloat nDotH = saturate(dot(halfway, normal));\n\t\tfloat specularLightness = pow(nDotH, specExp) * specIntensity;\n\n\t\t[flatten]\n\t\tif (specExp > 30) {\n\t\t\tspecularLightness += pow(nDotH, specExp * 10 + 5000) * (specIntensity * 12 + 5) * saturate((specExp - 30) / 40);\n\t\t}\n\n\t\tlightResult += specularLightness * gLightColor;\n\t\treturn float4(lightResult, lightness + specularLightness);\n\t}\n\n\tfloat4 ps_DirectionalLight_Shadows_NoFilter(PS_IN pin) : SV_Target {\n        float3 normal, position, lightResult;\n        float depth, specIntensity, specExp;\n        GetParams(pin.Tex, normal, position, depth, lightResult, specIntensity, specExp);\n\n\t\tfloat3 toLight = -gDirectionalLightDirection;\n\t\tfloat lightness = saturate(dot(normal, toLight));\n\t\tlightness *= GetShadow_NoFilter(position, depth);\n\n\t\tfloat3 toEye = normalize(gEyePosW - position);\n\t\tfloat3 halfway = normalize(toEye + toLight);\n\n\t\tfloat nDotH = saturate(dot(halfway, normal));\n\t\tfloat specularLightness = pow(nDotH, specExp) * specIntensity;\n\n\t\t[flatten]\n\t\tif (specExp > 30) {\n\t\t\tspecularLightness += pow(nDotH, specExp * 10 + 5000) * (specIntensity * 12 + 5) * saturate((specExp - 30) / 40);\n\t\t}\n\n\t\tlightResult += specularLightness * gLightColor;\n\t\treturn float4(lightResult, lightness + specularLightness);\n\t}\n\n\tfloat4 ps_DirectionalLight_Split(PS_IN pin) : SV_Target{\n\t\tfloat3 normal, position, lightResult;\n\t\tfloat depth, specIntensity, specExp;\n\t\tGetParams(pin.Tex, normal, position, depth, lightResult, specIntensity, specExp);\n\n\t\tfloat3 toLight = -gDirectionalLightDirection;\n\t\tfloat lightness = saturate(dot(normal, toLight));\n\n\t\tfloat spec = abs(depth - gShadowDepths.x) < 0.0005;\n\t\tspec += abs(depth - gShadowDepths.y) < 0.0001;\n\t\tspec += abs(depth - gShadowDepths.z) < 0.00002;\n\t\tspec += abs(depth - gShadowDepths.w) < 0.000003;\n\n\t\tif (depth > gShadowDepths.w) {\n\t\t\tlightResult += float3(0.4, 0, 0.4);\n\t\t} else if (depth > gShadowDepths.z) {\n\t\t\tlightResult += float3(0.4, 0.4, 0);\n\t\t} else if (depth > gShadowDepths.y) {\n\t\t\tlightResult += float3(0, 0, 0.2);\n\t\t} else if (depth > gShadowDepths.x) {\n\t\t\tlightResult += float3(0.2, 0, 0);\n\t\t} else {\n\t\t\tlightResult += float3(0, 0.2, 0);\n\t\t}\n\n\t\tlightResult.r += spec;\n\t\tlightResult.g -= spec;\n\t\tlightResult.b -= spec;\n\n\t\treturn float4(lightResult, lightness);\n\t}\n\n    technique11 DirectionalLight {\n        pass P0 {\n            SetVertexShader(CompileShader(vs_4_0, vs_main()));\n            SetGeometryShader(NULL);\n            SetPixelShader(CompileShader(ps_4_0, ps_DirectionalLight()));\n        }\n    }\n\n    technique11 DirectionalLight_Shadows {\n        pass P0 {\n            SetVertexShader(CompileShader(vs_4_0, vs_main()));\n            SetGeometryShader(NULL);\n            SetPixelShader(CompileShader(ps_4_0, ps_DirectionalLight_Shadows()));\n        }\n    }\n\n    technique11 DirectionalLight_Shadows_NoFilter {\n        pass P0 {\n            SetVertexShader(CompileShader(vs_4_0, vs_main()));\n            SetGeometryShader(NULL);\n            SetPixelShader(CompileShader(ps_4_0, ps_DirectionalLight_Shadows_NoFilter()));\n        }\n    }\n\n    technique11 DirectionalLight_Split {\n        pass P0 {\n            SetVertexShader(CompileShader(vs_4_0, vs_main()));\n            SetGeometryShader(NULL);\n            SetPixelShader(CompileShader(ps_4_0, ps_DirectionalLight_Split()));\n        }\n    }"), "DeferredLight")){
                E = new Effect(device, bc);
			}

			TechPointLight = E.GetTechniqueByName("PointLight");
			TechDirectionalLight = E.GetTechniqueByName("DirectionalLight");
			TechDirectionalLight_Shadows = E.GetTechniqueByName("DirectionalLight_Shadows");
			TechDirectionalLight_Shadows_NoFilter = E.GetTechniqueByName("DirectionalLight_Shadows_NoFilter");
			TechDirectionalLight_Split = E.GetTechniqueByName("DirectionalLight_Split");

			for (var i = 0; i < TechPointLight.Description.PassCount && InputSignaturePT == null; i++) {
				InputSignaturePT = TechPointLight.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePT == null) throw new System.Exception("input signature (DeferredLight, PT, PointLight) == null");
			LayoutPT = new InputLayout(device, InputSignaturePT, InputLayouts.VerticePT.InputElementsValue);

			FxWorld = E.GetVariableByName("gWorld").AsMatrix();
			FxWorldInvTranspose = E.GetVariableByName("gWorldInvTranspose").AsMatrix();
			FxWorldViewProj = E.GetVariableByName("gWorldViewProj").AsMatrix();
			FxWorldViewProjInv = E.GetVariableByName("gWorldViewProjInv").AsMatrix();
			FxShadowViewProj = E.GetVariableByName("gShadowViewProj").AsMatrix();
			FxBaseMap = E.GetVariableByName("gBaseMap").AsResource();
			FxNormalMap = E.GetVariableByName("gNormalMap").AsResource();
			FxMapsMap = E.GetVariableByName("gMapsMap").AsResource();
			FxDepthMap = E.GetVariableByName("gDepthMap").AsResource();
			FxShadowMaps = E.GetVariableByName("gShadowMaps").AsResource();
			FxPointLightRadius = E.GetVariableByName("gPointLightRadius").AsScalar();
			FxScreenSize = E.GetVariableByName("gScreenSize").AsVector();
			FxLightColor = E.GetVariableByName("gLightColor").AsVector();
			FxDirectionalLightDirection = E.GetVariableByName("gDirectionalLightDirection").AsVector();
			FxPointLightPosition = E.GetVariableByName("gPointLightPosition").AsVector();
			FxShadowDepths = E.GetVariableByName("gShadowDepths").AsVector();
			FxEyePosW = E.GetVariableByName("gEyePosW").AsVector();
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePT.Dispose();
            LayoutPT.Dispose();
        }
	}

	public class EffectDeferredPpSslr : IEffectWrapper {
		
		
        public Effect E;

        public ShaderSignature InputSignaturePT;
        public InputLayout LayoutPT;

		public EffectTechnique TechHabrahabrVersion;

		public EffectMatrixVariable FxWorldViewProjInv { get; private set; }
		public EffectMatrixVariable FxWorldViewProj { get; private set; }
		public EffectResourceVariable FxBaseMap, FxLightMap, FxNormalMap, FxDepthMap;
		public EffectVectorVariable FxEyePosW;

		public EffectDeferredPpSslr() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("\n    Texture2D gBaseMap;\n    Texture2D gLightMap;\n    Texture2D gNormalMap;\n    Texture2D gDepthMap;\n\n    SamplerState samInputImage {\n        Filter = MIN_MAG_LINEAR_MIP_POINT;\n        AddressU = CLAMP;\n        AddressV = CLAMP;\n    };\n    \n\n    cbuffer cbPerFrame : register(b0) {\n        matrix gWorldViewProjInv;\n        matrix gWorldViewProj;\n        float3 gEyePosW;\n    }\n\n\n    struct VS_IN {\n        float3 PosL    : POSITION;\n        float2 Tex     : TEXCOORD;\n    };\n\n    struct PS_IN {\n        float4 PosH    : SV_POSITION;\n        float2 Tex     : TEXCOORD;\n    };\n\n\n    float3 GetColor(float2 uv){\n        return gBaseMap.Sample(samInputImage, uv).rgb + \n                gLightMap.Sample(samInputImage, uv).rgb;\n    }\n\n    float3 GetPosition(float2 uv, float depth){\n        float4 position = mul(float4(uv.x * 2 - 1, -(uv.y * 2 - 1), depth, 1), gWorldViewProjInv);\n        return position.xyz / position.w;\n    }\n\n    float GetDepth(float2 uv){\n        return gDepthMap.Sample(samInputImage, uv).x;\n    }\n\n    float3 GetUv(float3 position){\n        float4 pVP = mul(float4(position, 1.0f), gWorldViewProj);\n        pVP.xy = float2(0.5f, 0.5f) + float2(0.5f, -0.5f) * pVP.xy / pVP.w;\n        return float3(pVP.xy, pVP.z / pVP.w);\n    }\n\n\n    PS_IN vs_main(VS_IN vin) {\n        PS_IN vout;\n        vout.PosH = float4(vin.PosL, 1.0f);\n        vout.Tex = vin.Tex;\n        return vout;\n    }\n\n\n    #define MAX_L 0.72\n    #define FADING_FROM 0.5\n    #define MIN_L 0.0\n    #define ITERATIONS 20\n    #define START_L 0.01\n\n    float4 ps_HabrahabrVersion(PS_IN pin) : SV_Target {\n        float depth = GetDepth(pin.Tex);\n        float3 position = GetPosition(pin.Tex, depth);\n        float3 normal = gNormalMap.Sample(samInputImage, pin.Tex).xyz;\n        float3 viewDir = normalize(position - gEyePosW);\n        float3 reflectDir = normalize(reflect(viewDir, normal));\n\n        float3 newUv = 0;\n        float L = START_L;\n        float quality = 0;\n\n        [flatten]\n        for(int i = 0; i < ITERATIONS; i++){\n            float3 calculatedPosition = position + reflectDir * L;\n\n            newUv = GetUv(calculatedPosition);\n            float3 newPosition = GetPosition(newUv.xy, GetDepth(newUv.xy));\n            quality = length(calculatedPosition - newPosition);\n            L = (L + length(position - newPosition)) / 2;\n        }\n\n        float fresnel = saturate(3.2 * pow(1 + dot(viewDir, normal), 2));\n        quality = 1 - saturate(abs(quality) / 0.1);\n\n        float alpha = fresnel * quality * saturate(\n            (1 - saturate((length(newUv - pin.Tex) - FADING_FROM) / (MAX_L - FADING_FROM)))\n                - min(L - MIN_L, 0) * -10000\n        ) * saturate(min(newUv.x, 1 - newUv.x) / 0.1) * saturate(min(newUv.y, 1 - newUv.y) / 0.1);\n\n        return float4(GetColor(newUv.xy).rgb * min(alpha * 4, 1), alpha);\n    }\n\n    technique11 HabrahabrVersion {\n        pass P0 {\n            SetVertexShader( CompileShader( vs_5_0, vs_main() ) );\n            SetGeometryShader( NULL );\n            SetPixelShader( CompileShader( ps_5_0, ps_HabrahabrVersion() ) );\n        }\n    }"), "DeferredPpSslr")){
                E = new Effect(device, bc);
			}

			TechHabrahabrVersion = E.GetTechniqueByName("HabrahabrVersion");

			for (var i = 0; i < TechHabrahabrVersion.Description.PassCount && InputSignaturePT == null; i++) {
				InputSignaturePT = TechHabrahabrVersion.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePT == null) throw new System.Exception("input signature (DeferredPpSslr, PT, HabrahabrVersion) == null");
			LayoutPT = new InputLayout(device, InputSignaturePT, InputLayouts.VerticePT.InputElementsValue);

			FxWorldViewProjInv = E.GetVariableByName("gWorldViewProjInv").AsMatrix();
			FxWorldViewProj = E.GetVariableByName("gWorldViewProj").AsMatrix();
			FxBaseMap = E.GetVariableByName("gBaseMap").AsResource();
			FxLightMap = E.GetVariableByName("gLightMap").AsResource();
			FxNormalMap = E.GetVariableByName("gNormalMap").AsResource();
			FxDepthMap = E.GetVariableByName("gDepthMap").AsResource();
			FxEyePosW = E.GetVariableByName("gEyePosW").AsVector();
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePT.Dispose();
            LayoutPT.Dispose();
        }
	}

	public class EffectDeferredResult : IEffectWrapper {
		
		
        public Effect E;

        public ShaderSignature InputSignaturePT;
        public InputLayout LayoutPT;

		public EffectTechnique TechDebug, TechDebugPost, TechDebugLighting, TechDebugLocalReflections, TechCombine0;

		public EffectMatrixVariable FxWorldViewProjInv { get; private set; }
		public EffectResourceVariable FxBaseMap, FxNormalMap, FxMapsMap, FxDepthMap, FxLightMap, FxLocalReflectionMap, FxBottomLayerMap, FxReflectionCubemap;
		public EffectVectorVariable FxEyePosW, FxScreenSize;

		public EffectDeferredResult() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("\n    Texture2D gBaseMap;\n    Texture2D gNormalMap;\n    Texture2D gMapsMap;\n    Texture2D gDepthMap;\n    Texture2D gLightMap;\n    Texture2D gLocalReflectionMap;\n    Texture2D gBottomLayerMap;\n    TextureCube gReflectionCubemap;\n\n    SamplerState samInputImage {\n        Filter = MIN_MAG_LINEAR_MIP_POINT;\n        AddressU = CLAMP;\n        AddressV = CLAMP;\n    };\n\n    SamplerState samTest {\n        Filter = MIN_MAG_MIP_POINT;\n        AddressU = CLAMP;\n        AddressV = CLAMP;\n    };\n\n    SamplerState samAnisotropic {\n        Filter = ANISOTROPIC;\n        MaxAnisotropy = 4;\n\n        AddressU = WRAP;\n        AddressV = WRAP;\n    };\n    \n\n    cbuffer cbPerFrame : register(b0) {\n        matrix gWorldViewProjInv;\n        float3 gEyePosW;\n        float4 gScreenSize;\n    }\n\n\n    struct VS_IN {\n        float3 PosL    : POSITION;\n        float2 Tex     : TEXCOORD;\n    };\n\n    struct PS_IN {\n        float4 PosH    : SV_POSITION;\n        float2 Tex     : TEXCOORD;\n    };\n\n\n    float3 GetPosition(float2 uv, float depth){\n        float4 position = mul(float4(uv.x * 2 - 1, -(uv.y * 2 - 1), depth, 1), gWorldViewProjInv);\n        return position.xyz / position.w;\n    }\n\n    float CalculateReflectionPower(float3 toEyeNormalW, float3 normalW, float metalness){\n        float rid = 1 - dot(toEyeNormalW, normalW);\n        float rim = metalness + pow(rid, max(1 / metalness - 2.4, 0));\n        return saturate(rim);\n    }\n\n\n    PS_IN vs_main(VS_IN vin) {\n        PS_IN vout;\n        vout.PosH = float4(vin.PosL, 1.0f);\n        vout.Tex = vin.Tex;\n        return vout;\n    }\n\n\n    float4 ps_debug(PS_IN pin) : SV_Target {\n        if (pin.Tex.y < 0.5){\n            if (pin.Tex.x < 0.5){\n                return gBaseMap.Sample(samInputImage, pin.Tex * 2);\n            } else {\n                float4 normalValue = gNormalMap.Sample(samInputImage, pin.Tex * 2 - float2(1, 0));\n                if (normalValue.x == 0 && normalValue.y == 0 && normalValue.z == 0){\n                    return 0.0;\n                }\n                return 0.5 + 0.5 * normalValue;\n            }\n        } else {\n            if (pin.Tex.x < 0.5){\n                float depthValue = gDepthMap.Sample(samInputImage, pin.Tex * 2 - float2(0, 1)).x;\n                return (1 - pow(depthValue, 10));\n            }\n        }\n        \n        if (pin.Tex.y < 0.75){\n            if (pin.Tex.x < 0.75){\n                return gMapsMap.Sample(samInputImage, pin.Tex * 4 - float2(2, 2)).x;\n            } else {\n                return gMapsMap.Sample(samInputImage, pin.Tex * 4 - float2(3, 2)).y;\n            }\n        } else {\n            if (pin.Tex.x < 0.75){\n                return gMapsMap.Sample(samInputImage, pin.Tex * 4 - float2(2, 3)).z;\n            } else {\n                return gMapsMap.Sample(samInputImage, pin.Tex * 4 - float2(3, 3)).w;\n            }\n        }\n\n        return 0;\n    }\n\n    technique11 Debug {\n        pass P0 {\n            SetVertexShader( CompileShader( vs_5_0, vs_main() ) );\n            SetGeometryShader( NULL );\n            SetPixelShader( CompileShader( ps_5_0, ps_debug() ) );\n        }\n    }\n\n\n    float4 ps_DebugPost(PS_IN pin) : SV_Target {\n        if (pin.Tex.y < 0.5){\n            if (pin.Tex.x < 0.5){\n                return gBaseMap.Sample(samInputImage, pin.Tex * 2).a;\n            } else {\n                float2 uv = pin.Tex * 2 - float2(1.0, 0.0);\n\n                float4 normalValue = gNormalMap.Sample(samInputImage, uv);\n                float3 normal = normalValue.xyz;\n        \n                float depth = gDepthMap.Sample(samInputImage, uv).x;\n                float3 position = GetPosition(uv, depth);\n        \n                float3 toEyeW = normalize(gEyePosW - position);\n                float4 reflectionColor = gReflectionCubemap.Sample(samAnisotropic, reflect(-toEyeW, normal));\n                return reflectionColor;\n                \n                float4 mapsValue = gMapsMap.Sample(samInputImage, uv);\n                float glossiness = mapsValue.g;\n                float reflectiveness = mapsValue.z;\n                float metalness = mapsValue.w;\n\n                return reflectionColor * reflectiveness * CalculateReflectionPower(toEyeW, normal, metalness);\n            }\n        } else {\n            if (pin.Tex.x < 0.5){\n                return gLocalReflectionMap.Sample(samInputImage, pin.Tex * 2 - float2(0.0, 1.0));\n            } else {\n                return gLightMap.Sample(samInputImage, pin.Tex * 2 - float2(1.0, 1.0));\n            }\n        }\n    }\n\n    technique11 DebugPost {\n        pass P0 {\n            SetVertexShader( CompileShader( vs_5_0, vs_main() ) );\n            SetGeometryShader( NULL );\n            SetPixelShader( CompileShader( ps_5_0, ps_DebugPost() ) );\n        }\n    }\n\n\n    float4 ps_DebugLighting(PS_IN pin) : SV_Target {\n        return gLightMap.Sample(samInputImage, pin.Tex);\n    }\n\n    technique11 DebugLighting {\n        pass P0 {\n            SetVertexShader( CompileShader( vs_5_0, vs_main() ) );\n            SetGeometryShader( NULL );\n            SetPixelShader( CompileShader( ps_5_0, ps_DebugLighting() ) );\n        }\n    }\n\n\n    float4 ps_DebugLocalReflections(PS_IN pin) : SV_Target {\n        float4 base = gBaseMap.Sample(samInputImage, pin.Tex);\n        float4 light = gLightMap.Sample(samInputImage, pin.Tex);\n        float4 reflection = gLocalReflectionMap.Sample(samInputImage, pin.Tex);\n\n        float x = saturate((pin.Tex.x * (gScreenSize.x / 16) % 2 - 1.0) * 1e6);\n        float y = saturate((pin.Tex.y * (gScreenSize.y / 16) % 2 - 1.0) * 1e6);\n        float background = ((x + y) % 2) * 0.2 + 0.7;\n\n        return background * (1 - reflection.a) + reflection * reflection.a;\n    }\n\n    technique11 DebugLocalReflections {\n        pass P0 {\n            SetVertexShader( CompileShader( vs_5_0, vs_main() ) );\n            SetGeometryShader( NULL );\n            SetPixelShader( CompileShader( ps_5_0, ps_DebugLocalReflections() ) );\n        }\n    }\n\n\n    float3 ReflectionColor(float3 toEyeW, float3 normal, float glossiness) {\n        return gReflectionCubemap.SampleBias(samAnisotropic, reflect(-toEyeW, normal), 1 - glossiness).rgb;\n    }\n\n    float4 ps_0(PS_IN pin) : SV_Target {\n        \n        \n        float4 normalValue = gNormalMap.Sample(samTest, pin.Tex);\n\n        float3 normal = normalValue.xyz;\n        float3 position = GetPosition(pin.Tex, gDepthMap.Sample(samInputImage, pin.Tex).x);\n\n        \n        float4 baseValue = gBaseMap.Sample(samInputImage, pin.Tex);\n        float4 lightValue = gLightMap.Sample(samInputImage, pin.Tex);\n        float3 lighted = baseValue.rgb + lightValue.rgb;\n\n        \n        float4 mapsValue = gMapsMap.Sample(samInputImage, pin.Tex);\n        float glossiness = mapsValue.g;\n        float reflectiveness = mapsValue.z;\n        float metalness = mapsValue.w;\n        \n        \n        float3 toEyeW = normalize(gEyePosW - position);\n        float3 reflectionColor = ReflectionColor(toEyeW, normal, glossiness);\n\n        float4 localReflectionColor = gLocalReflectionMap.Sample(samInputImage, pin.Tex);\n        float reflectionAlpha = saturate((localReflectionColor.a - 0.5) * 2.0 + 0.5);\n        reflectionColor = reflectionColor * (1 - reflectionAlpha) + localReflectionColor.rgb * reflectionAlpha;\n\n        float reflectionPower = saturate(2 * reflectiveness * CalculateReflectionPower(toEyeW, normal, metalness));\n        float3 reflection = reflectionColor * reflectionPower;\n\n        float alpha = min(normalValue.a + reflectionPower * metalness, 1.0);\n\n        float metalnessFine = saturate(metalness * reflectiveness) * 0.2;\n        lighted = max(lighted - metalnessFine, 0.0);\n\n        return gBottomLayerMap.Sample(samInputImage, pin.Tex) * (1 - alpha) + \n                float4(lighted + reflection, 1.0) * alpha;\n    }\n\n    technique11 Combine0 {\n        pass P0 {\n            SetVertexShader( CompileShader( vs_5_0, vs_main() ) );\n            SetGeometryShader( NULL );\n            SetPixelShader( CompileShader( ps_5_0, ps_0() ) );\n        }\n    }"), "DeferredResult")){
                E = new Effect(device, bc);
			}

			TechDebug = E.GetTechniqueByName("Debug");
			TechDebugPost = E.GetTechniqueByName("DebugPost");
			TechDebugLighting = E.GetTechniqueByName("DebugLighting");
			TechDebugLocalReflections = E.GetTechniqueByName("DebugLocalReflections");
			TechCombine0 = E.GetTechniqueByName("Combine0");

			for (var i = 0; i < TechDebug.Description.PassCount && InputSignaturePT == null; i++) {
				InputSignaturePT = TechDebug.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePT == null) throw new System.Exception("input signature (DeferredResult, PT, Debug) == null");
			LayoutPT = new InputLayout(device, InputSignaturePT, InputLayouts.VerticePT.InputElementsValue);

			FxWorldViewProjInv = E.GetVariableByName("gWorldViewProjInv").AsMatrix();
			FxBaseMap = E.GetVariableByName("gBaseMap").AsResource();
			FxNormalMap = E.GetVariableByName("gNormalMap").AsResource();
			FxMapsMap = E.GetVariableByName("gMapsMap").AsResource();
			FxDepthMap = E.GetVariableByName("gDepthMap").AsResource();
			FxLightMap = E.GetVariableByName("gLightMap").AsResource();
			FxLocalReflectionMap = E.GetVariableByName("gLocalReflectionMap").AsResource();
			FxBottomLayerMap = E.GetVariableByName("gBottomLayerMap").AsResource();
			FxReflectionCubemap = E.GetVariableByName("gReflectionCubemap").AsResource();
			FxEyePosW = E.GetVariableByName("gEyePosW").AsVector();
			FxScreenSize = E.GetVariableByName("gScreenSize").AsVector();
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePT.Dispose();
            LayoutPT.Dispose();
        }
	}

	public class EffectDeferredTransparent : IEffectWrapper {
		
		
        public Effect E;

        public ShaderSignature InputSignaturePT;
        public InputLayout LayoutPT;

		public EffectTechnique TechDebug, TechDebugPost, TechDebugLighting, TechDebugLocalReflections, TechCombine0;

		public EffectMatrixVariable FxWorldViewProjInv { get; private set; }
		public EffectResourceVariable FxBaseMap, FxNormalMap, FxMapsMap, FxDepthMap, FxLightMap, FxLocalReflectionMap, FxReflectionCubemap;
		public EffectVectorVariable FxAmbientDown, FxAmbientRange, FxEyePosW;

		public EffectDeferredTransparent() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("\n\tTexture2D gBaseMap;\n\tTexture2D gNormalMap;\n\tTexture2D gMapsMap;\n\tTexture2D gDepthMap;\n\tTexture2D gLightMap;\n\tTexture2D gLocalReflectionMap;\n\tTextureCube gReflectionCubemap;\n\n\tSamplerState samInputImage {\n\t\tFilter = MIN_MAG_LINEAR_MIP_POINT;\n\t\tAddressU = CLAMP;\n\t\tAddressV = CLAMP;\n\t};\n\n\tSamplerState samAnisotropic {\n\t\tFilter = ANISOTROPIC;\n\t\tMaxAnisotropy = 4;\n\n\t\tAddressU = WRAP;\n\t\tAddressV = WRAP;\n\t};\n\t\n\n\tcbuffer cbPerFrame : register(b0) {\n\t\tmatrix gWorldViewProjInv;\n\t\tfloat3 gAmbientDown;\n\t\tfloat3 gAmbientRange;\n\t\tfloat3 gEyePosW;\n\t}\n\n\n\tstruct VS_IN {\n\t\tfloat3 PosL    : POSITION;\n\t\tfloat2 Tex     : TEXCOORD;\n\t};\n\n\tstruct PS_IN {\n\t\tfloat4 PosH    : SV_POSITION;\n\t\tfloat2 Tex     : TEXCOORD;\n\t};\n\n\n\tfloat3 GetPosition(float2 uv, float depth){\n\t\tfloat4 position = mul(float4(uv.x * 2 - 1, -(uv.y * 2 - 1), depth, 1), gWorldViewProjInv);\n\t\treturn position.xyz / position.w;\n\t}\n\n\tfloat CalculateReflectionPower(float3 toEyeNormalW, float3 normalW, float metalness){\n\t\tfloat rid = dot(toEyeNormalW, normalW);\n\t\tfloat rim = metalness + pow(1 - rid, (2 + 1 / metalness) / 3);\n\t\treturn rim * 2;\n\t}\n\n\n\tPS_IN vs_main(VS_IN vin) {\n\t\tPS_IN vout;\n\t\tvout.PosH = float4(vin.PosL, 1.0f);\n\t\tvout.Tex = vin.Tex;\n\t\treturn vout;\n\t}\n\n\n\tfloat4 ps_debug(PS_IN pin) : SV_Target {\n\t\tif (pin.Tex.y < 0.5){\n\t\t\tif (pin.Tex.x < 0.5){\n\t\t\t\treturn gBaseMap.SampleLevel(samInputImage, pin.Tex * 2, 0);\n\t\t\t} else {\n\t\t\t\tfloat4 normalValue = gNormalMap.SampleLevel(samInputImage, pin.Tex * 2 - float2(1, 0), 0);\n\t\t\t\tif (normalValue.x == 0 && normalValue.y == 0 && normalValue.z == 0){\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}\n\t\t\t\treturn 0.5 + 0.5 * normalValue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (pin.Tex.x < 0.5){\n\t\t\t\tfloat depthValue = gDepthMap.SampleLevel(samInputImage, pin.Tex * 2 - float2(0, 1), 0).x;\n\t\t\t\treturn (1 - depthValue) * 5;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (pin.Tex.y < 0.75){\n\t\t\tif (pin.Tex.x < 0.75){\n\t\t\t\treturn gMapsMap.SampleLevel(samInputImage, pin.Tex * 4 - float2(2, 2), 0).x;\n\t\t\t} else {\n\t\t\t\treturn gMapsMap.SampleLevel(samInputImage, pin.Tex * 4 - float2(3, 2), 0).y;\n\t\t\t}\n\t\t} else {\n\t\t\tif (pin.Tex.x < 0.75){\n\t\t\t\treturn gMapsMap.SampleLevel(samInputImage, pin.Tex * 4 - float2(2, 3), 0).z;\n\t\t\t} else {\n\t\t\t\treturn gMapsMap.SampleLevel(samInputImage, pin.Tex * 4 - float2(3, 3), 0).w;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\ttechnique11 Debug {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_5_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_5_0, ps_debug() ) );\n\t\t}\n\t}\n\n\n\tfloat4 ps_DebugPost(PS_IN pin) : SV_Target {\n\t\tif (pin.Tex.y < 0.5){\n\t\t\tif (pin.Tex.x < 0.5){\n\t\t\t\treturn gBaseMap.SampleLevel(samInputImage, pin.Tex * 2, 0.0).a;\n\t\t\t} else {\n\t\t\t\tfloat2 uv = pin.Tex * 2 - float2(1.0, 0.0);\n\n\t\t\t\tfloat4 normalValue = gNormalMap.SampleLevel(samInputImage, uv, 0.0);\n\t\t\t\tfloat3 normal = normalValue.xyz;\n\t\t\n\t\t\t\tfloat depth = gDepthMap.SampleLevel(samInputImage, uv, 0.0).x;\n\t\t\t\tfloat3 position = GetPosition(uv, depth);\n\t\t\n\t\t\t\tfloat3 toEyeW = normalize(gEyePosW - position);\n\t\t\t\tfloat4 reflectionColor = gReflectionCubemap.Sample(samAnisotropic, reflect(-toEyeW, normal));\n\t\t\t\treturn reflectionColor;\n\t\t\t\t\n\t\t\t\tfloat4 mapsValue = gMapsMap.SampleLevel(samInputImage, uv, 0.0);\n\t\t\t\tfloat glossiness = mapsValue.g;\n\t\t\t\tfloat reflectiveness = mapsValue.z;\n\t\t\t\tfloat metalness = mapsValue.w;\n\n\t\t\t\treturn reflectionColor * reflectiveness * CalculateReflectionPower(toEyeW, normal, metalness);\n\t\t\t}\n\t\t} else {\n\t\t\tif (pin.Tex.x < 0.5){\n\t\t\t\treturn gLocalReflectionMap.SampleLevel(samInputImage, pin.Tex * 2 - float2(0.0, 1.0), 0.0);\n\t\t\t} else {\n\t\t\t\treturn gLightMap.SampleLevel(samInputImage, pin.Tex * 2 - float2(1.0, 1.0), 0.0);\n\t\t\t}\n\t\t}\n\t}\n\n\ttechnique11 DebugPost {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_5_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_5_0, ps_DebugPost() ) );\n\t\t}\n\t}\n\n\n\tfloat4 ps_DebugLighting(PS_IN pin) : SV_Target {\n\t\treturn gLightMap.SampleLevel(samInputImage, pin.Tex, 0.0);\n\t}\n\n\ttechnique11 DebugLighting {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_5_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_5_0, ps_DebugLighting() ) );\n\t\t}\n\t}\n\n\n\tfloat4 ps_DebugLocalReflections(PS_IN pin) : SV_Target {\n\t\tfloat4 base = gBaseMap.SampleLevel(samInputImage, pin.Tex, 0.0);\n\t\tfloat4 light = gLightMap.SampleLevel(samInputImage, pin.Tex, 0.0);\n\t\tfloat4 reflection = gLocalReflectionMap.SampleLevel(samInputImage, pin.Tex, 0.0);\n\t\t\n\t\treturn (base + light) * (1 - reflection.a) + reflection * reflection.a;\n\t}\n\n\ttechnique11 DebugLocalReflections {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_5_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_5_0, ps_DebugLocalReflections() ) );\n\t\t}\n\t}\n\n\n\tfloat3 CalcAmbient(float3 normal, float3 color) {\n\t\tfloat up = normal.y * 0.5 + 0.5;\n\t\tfloat3 ambient = gAmbientDown + up * gAmbientRange;\n\t\treturn ambient * color;\n\t}\n\n\tfloat3 ReflectionColor(float3 toEyeW, float3 normal, float glossiness) {\n\t\treturn gReflectionCubemap.SampleBias(samAnisotropic, reflect(-toEyeW, normal), 0.3 / (glossiness + 0.3)).rgb;\n\t}\n\n\tfloat4 ps_0(PS_IN pin) : SV_Target {\n\t\t\n\t\tfloat4 normalValue = gNormalMap.SampleLevel(samInputImage, pin.Tex, 0.0);\n\t\tfloat depthValue = gDepthMap.SampleLevel(samInputImage, pin.Tex, 0.0).x;\n\n\t\tfloat3 normal = normalValue.xyz;\n\t\tfloat3 position = GetPosition(pin.Tex, depthValue);\n\n\t\t\n\t\tfloat4 baseValue = gBaseMap.SampleLevel(samInputImage, pin.Tex, 0.0);\n\t\tfloat4 lightValue = gLightMap.SampleLevel(samInputImage, pin.Tex, 0.0);\n\n\t\tfloat3 lighted = CalcAmbient(normal, baseValue.rgb) + lightValue.rgb;\n\n\t\t\n\t\tfloat4 mapsValue = gMapsMap.SampleLevel(samInputImage, pin.Tex, 0.0);\n\t\tfloat glossiness = mapsValue.g;\n\t\tfloat reflectiveness = mapsValue.z;\n\t\tfloat metalness = mapsValue.w;\n\t\t\n\t\t\n\t\tfloat3 toEyeW = normalize(gEyePosW - position);\n\t\tfloat3 reflectionColor = ReflectionColor(toEyeW, normal, glossiness);\n\n\t\tfloat4 localReflectionColor = gLocalReflectionMap.SampleLevel(samInputImage, pin.Tex, 0.0);\n\t\treflectionColor = reflectionColor * (1 - localReflectionColor.a) + localReflectionColor.rgb * localReflectionColor.a;\n\n\t\tfloat rid = dot(toEyeW, normal);\n\t\tfloat rim = metalness + pow(1 - rid, 1 / metalness);\n\n\t\tfloat3 reflection = (reflectionColor - 0.5 * (metalness + 0.2) / 1.2) * saturate(reflectiveness * \n\t\t\tCalculateReflectionPower(toEyeW, normal, metalness));\n\n\t\t\n\t\treturn float4(lighted + reflection, 1.0);\n\t}\n\n\ttechnique11 Combine0 {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_5_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_5_0, ps_0() ) );\n\t\t}\n\t}"), "DeferredTransparent")){
                E = new Effect(device, bc);
			}

			TechDebug = E.GetTechniqueByName("Debug");
			TechDebugPost = E.GetTechniqueByName("DebugPost");
			TechDebugLighting = E.GetTechniqueByName("DebugLighting");
			TechDebugLocalReflections = E.GetTechniqueByName("DebugLocalReflections");
			TechCombine0 = E.GetTechniqueByName("Combine0");

			for (var i = 0; i < TechDebug.Description.PassCount && InputSignaturePT == null; i++) {
				InputSignaturePT = TechDebug.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePT == null) throw new System.Exception("input signature (DeferredTransparent, PT, Debug) == null");
			LayoutPT = new InputLayout(device, InputSignaturePT, InputLayouts.VerticePT.InputElementsValue);

			FxWorldViewProjInv = E.GetVariableByName("gWorldViewProjInv").AsMatrix();
			FxBaseMap = E.GetVariableByName("gBaseMap").AsResource();
			FxNormalMap = E.GetVariableByName("gNormalMap").AsResource();
			FxMapsMap = E.GetVariableByName("gMapsMap").AsResource();
			FxDepthMap = E.GetVariableByName("gDepthMap").AsResource();
			FxLightMap = E.GetVariableByName("gLightMap").AsResource();
			FxLocalReflectionMap = E.GetVariableByName("gLocalReflectionMap").AsResource();
			FxReflectionCubemap = E.GetVariableByName("gReflectionCubemap").AsResource();
			FxAmbientDown = E.GetVariableByName("gAmbientDown").AsVector();
			FxAmbientRange = E.GetVariableByName("gAmbientRange").AsVector();
			FxEyePosW = E.GetVariableByName("gEyePosW").AsVector();
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePT.Dispose();
            LayoutPT.Dispose();
        }
	}

	public class EffectKunosShader : IEffectMatricesWrapper {
		[StructLayout(LayoutKind.Sequential)]
        public struct Material {
            public float Ambient;
            public float Diffuse;
            public float Specular;
            public float SpecularExp;
            public Vector3 Emissive;

			public static readonly int Stride = Marshal.SizeOf(typeof(Material));
        }
		
        public Effect E;

        public ShaderSignature InputSignaturePNT;
        public InputLayout LayoutPNT;

		public EffectTechnique TechPerPixel;

		public EffectMatrixVariable FxWorld { get; private set; }
		public EffectMatrixVariable FxWorldInvTranspose { get; private set; }
		public EffectMatrixVariable FxWorldViewProj { get; private set; }
		public EffectResourceVariable FxDiffuseMap;
		public EffectVectorVariable FxEyePosW;
		public EffectVariable FxMaterial;

		public EffectKunosShader() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("\n\tstruct Material {\n\t\tfloat Ambient;\n\t\tfloat Diffuse;\n\t\tfloat Specular;\n\t\tfloat SpecularExp;\n\t\tfloat3 Emissive;\n\t};\n\n\n\tTexture2D gDiffuseMap;\n\n\tSamplerState samAnisotropic {\n\t\tFilter = ANISOTROPIC;\n\t\tMaxAnisotropy = 4;\n\n\t\tAddressU = WRAP;\n\t\tAddressV = WRAP;\n\t};\n\n\n\tcbuffer cbPerObject : register(b0) {\n\t\tmatrix gWorld;\n\t\tmatrix gWorldInvTranspose;\n\t\tmatrix gWorldViewProj;\n\t\tMaterial gMaterial;\n\t}\n\n\tcbuffer cbPerFrame {\n\t\t\n\t\tfloat3 gEyePosW;\n\t}\n\n\n\tstruct VS_IN {\n\t\tfloat3 PosL    : POSITION;\n\t\tfloat3 NormalL : NORMAL;\n\t\tfloat2 Tex     : TEXCOORD;\n\t};\n\n\tstruct PS_IN {\n\t\tfloat4 PosH    : SV_POSITION;\n\t\tfloat3 PosW    : POSITION;\n\t\tfloat3 NormalW : NORMAL;\n\t\tfloat2 Tex     : TEXCOORD;\n\t};\n\n\n\tPS_IN vs_main(VS_IN vin) {\n\t\tPS_IN vout;\n\n\t\tvout.PosW    = mul(float4(vin.PosL, 1.0f), gWorld).xyz;\n\t\tvout.NormalW = mul(vin.NormalL, (float3x3)gWorldInvTranspose);\n\n\t\tvout.PosH = mul(float4(vin.PosL, 1.0f), gWorldViewProj);\n\t\tvout.Tex = vin.Tex;\n\n\t\treturn vout;\n\t}\n\n\tfloat4 ps_main(PS_IN pin) : SV_Target{\n\t\t\n\t\tfloat4 texColor = gDiffuseMap.Sample(samAnisotropic, pin.Tex);\n\t\treturn texColor * gMaterial.Ambient + gMaterial.Diffuse * (dot(pin.NormalW, float3(0, -1, 0)) + 0.3) / 1.3;\n\t}\n\n\ttechnique11 PerPixel { \n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_4_0, ps_main() ) );\n\t\t}\n\t}"), "KunosShader")){
                E = new Effect(device, bc);
			}

			TechPerPixel = E.GetTechniqueByName("PerPixel");

			for (var i = 0; i < TechPerPixel.Description.PassCount && InputSignaturePNT == null; i++) {
				InputSignaturePNT = TechPerPixel.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePNT == null) throw new System.Exception("input signature (KunosShader, PNT, PerPixel) == null");
			LayoutPNT = new InputLayout(device, InputSignaturePNT, InputLayouts.VerticePNT.InputElementsValue);

			FxWorld = E.GetVariableByName("gWorld").AsMatrix();
			FxWorldInvTranspose = E.GetVariableByName("gWorldInvTranspose").AsMatrix();
			FxWorldViewProj = E.GetVariableByName("gWorldViewProj").AsMatrix();
			FxDiffuseMap = E.GetVariableByName("gDiffuseMap").AsResource();
			FxEyePosW = E.GetVariableByName("gEyePosW").AsVector();
			FxMaterial = E.GetVariableByName("gMaterial");
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePNT.Dispose();
            LayoutPNT.Dispose();
        }
	}

	public class EffectPpBasic : IEffectWrapper {
		
		
        public Effect E;

        public ShaderSignature InputSignaturePT;
        public InputLayout LayoutPT;

		public EffectTechnique TechCopy, TechOverlay, TechShadow, TechDepth, TechFxaa;

		public EffectResourceVariable FxInputMap, FxOverlayMap, FxDepthMap;
		public EffectScalarVariable FxSizeMultipler;
		public EffectVectorVariable FxScreenSize;

		public EffectPpBasic() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("\n\tTexture2D gInputMap;\n\tTexture2D gOverlayMap;\n\tTexture2D gDepthMap;\n\n\tSamplerState samInputImage {\n\t\tFilter = MIN_MAG_LINEAR_MIP_POINT;\n\t\tAddressU = CLAMP;\n\t\tAddressV = CLAMP;\n\t};\n\t\n\n\tcbuffer cbPerObject : register(b0) {\n\t\tfloat4 gScreenSize;\n\t\tfloat gSizeMultipler;\n\t}\n\n\n\tstruct VS_IN {\n\t\tfloat3 PosL    : POSITION;\n\t\tfloat2 Tex     : TEXCOORD;\n\t};\n\n\tstruct PS_IN {\n\t\tfloat4 PosH    : SV_POSITION;\n\t\tfloat2 Tex     : TEXCOORD;\n\t};\n\n\n\tPS_IN vs_main(VS_IN vin) {\n\t\tPS_IN vout;\n\t\tvout.PosH = float4(vin.PosL, 1.0f);\n\t\tvout.Tex = vin.Tex;\n\t\treturn vout;\n\t}\n\n\tfloat4 ps_Copy(PS_IN pin) : SV_Target{\n\t\treturn gInputMap.SampleLevel(samInputImage, pin.Tex, 0.0f);\n\t}\n\n\ttechnique11 Copy {\n\t\tpass P0 {\n\t\t\tSetVertexShader(CompileShader(vs_5_0, vs_main()));\n\t\t\tSetGeometryShader(NULL);\n\t\t\tSetPixelShader(CompileShader(ps_5_0, ps_Copy()));\n\t\t}\n\t}\n\n\n\tfloat4 ps_Overlay(PS_IN pin) : SV_Target{\n\t\tfloat4 b = gInputMap.Sample(samInputImage, pin.Tex);\n\t\tfloat4 o = gOverlayMap.Sample(samInputImage, pin.Tex);\n\t\treturn float4(b.rgb * (1 - o.a) + o.rgb * o.a, 1.0);\n\t}\n\n\ttechnique11 Overlay {\n\t\tpass P0 {\n\t\t\tSetVertexShader(CompileShader(vs_5_0, vs_main()));\n\t\t\tSetGeometryShader(NULL);\n\t\t\tSetPixelShader(CompileShader(ps_5_0, ps_Overlay()));\n\t\t}\n\t}\n\n\n\tfloat4 ps_Shadow(PS_IN pin) : SV_Target{\n\t\tfloat4 b = gInputMap.Sample(samInputImage, pin.Tex);\n\n\t\tfloat4 tex = gOverlayMap.Sample(samInputImage, pin.Tex);\n\t\ttex.rgb *= tex.a;\n\n\t\tfloat x, y;\n\t\tfor (x = -1; x <= 1; x++)\n\t\t\tfor (y = -1; y <= 1; y++) {\n\t\t\t\tfloat4 v = gOverlayMap.Sample(samInputImage, pin.Tex + float2(x * gScreenSize.z, y * gScreenSize.w));\n\t\t\t\ttex.a = max(tex.a, v.a);\n\t\t\t}\n\n\t\treturn float4(tex.rgb, max(b.a, tex.a));;\n\t}\n\n\ttechnique11 Shadow {\n\t\tpass P0 {\n\t\t\tSetVertexShader(CompileShader(vs_5_0, vs_main()));\n\t\t\tSetGeometryShader(NULL);\n\t\t\tSetPixelShader(CompileShader(ps_5_0, ps_Shadow()));\n\t\t}\n\t}\n\n\n\tfloat4 ps_Depth(PS_IN pin) : SV_Target{\n\t\tfloat4 background = gInputMap.SampleLevel(samInputImage, pin.Tex, 0.0f);\n\n\t\tfloat mx = gScreenSize.z * 20;\n\t\tfloat my = gScreenSize.w * 20;\n\t\tfloat x = max(1 - gSizeMultipler - mx, 0);\n\t\tfloat y = max(1 - gSizeMultipler - my, 0);\n\n\t\tfloat rx = max(1 - mx, gSizeMultipler);\n\t\tfloat ry = max(1 - my, gSizeMultipler);\n\n\t\tif (pin.Tex.x > x && pin.Tex.x < rx) {\n\t\t\tif (pin.Tex.y > y && pin.Tex.y < ry) {\n\t\t\t\tfloat2 depthUv = float2((pin.Tex.x - x) / gSizeMultipler, (pin.Tex.y - y) / gSizeMultipler);\n\t\t\t\treturn gDepthMap.SampleLevel(samInputImage, depthUv, 0.0f).r;\n\t\t\t}\n\t\t}\n\n\t\treturn background;\n\t}\n\n\ttechnique11 Depth { \n\t\tpass P0 {\n\t\t\tSetVertexShader(CompileShader(vs_5_0, vs_main()));\n\t\t\tSetGeometryShader(NULL);\n\t\t\tSetPixelShader(CompileShader(ps_5_0, ps_Depth()));\n\t\t}\n\t}\n\n\n\t#define FXAA_PRESET 5\n\t#include \"FXAA.fx\"\n\n\tfloat4 ps_Fxaa(PS_IN pin) : SV_Target {\n\t\tFxaaTex tex = { samInputImage, gInputMap };\n\t\tfloat3 aaImage = FxaaPixelShader(pin.Tex, tex, gScreenSize.zw);\n\t\treturn float4(aaImage, 1.0f);\n\t}\n\n\ttechnique11 Fxaa { \n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_5_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_5_0, ps_Fxaa() ) );\n\t\t}\n\t}"), "PpBasic")){
                E = new Effect(device, bc);
			}

			TechCopy = E.GetTechniqueByName("Copy");
			TechOverlay = E.GetTechniqueByName("Overlay");
			TechShadow = E.GetTechniqueByName("Shadow");
			TechDepth = E.GetTechniqueByName("Depth");
			TechFxaa = E.GetTechniqueByName("Fxaa");

			for (var i = 0; i < TechCopy.Description.PassCount && InputSignaturePT == null; i++) {
				InputSignaturePT = TechCopy.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePT == null) throw new System.Exception("input signature (PpBasic, PT, Copy) == null");
			LayoutPT = new InputLayout(device, InputSignaturePT, InputLayouts.VerticePT.InputElementsValue);

			FxInputMap = E.GetVariableByName("gInputMap").AsResource();
			FxOverlayMap = E.GetVariableByName("gOverlayMap").AsResource();
			FxDepthMap = E.GetVariableByName("gDepthMap").AsResource();
			FxSizeMultipler = E.GetVariableByName("gSizeMultipler").AsScalar();
			FxScreenSize = E.GetVariableByName("gScreenSize").AsVector();
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePT.Dispose();
            LayoutPT.Dispose();
        }
	}

	public class EffectPpBlur : IEffectWrapper {
		
		public const int SampleCount = 15;
        public Effect E;

        public ShaderSignature InputSignaturePT;
        public InputLayout LayoutPT;

		public EffectTechnique TechGaussianBlur, TechReflectionGaussianBlur;

		public EffectResourceVariable FxInputMap, FxMapsMap;
		public EffectScalarVariable FxSampleWeights, FxPower;
		public EffectVectorVariable FxSampleOffsets;

		public EffectPpBlur() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("#include \"Common.fx\"\n\nTexture2D gMapsMap;\n\nstatic const int SAMPLE_COUNT = 15;\n\ncbuffer cbPerFrame : register(b0) {\n\tfloat4 gSampleOffsets[SAMPLE_COUNT];\n\tfloat gSampleWeights[SAMPLE_COUNT];\n\tfloat gPower;\n}\n\n\n\tfloat4 ps_GaussianBlurDebug(PS_IN pin) : SV_Target {\n\t\treturn tex(pin.Tex);\n\t}\n\n\tfloat4 ps_GaussianBlur(PS_IN pin) : SV_Target {\n\t\tfloat4 c = 0;\n\t\tfor (int i = 0; i < SAMPLE_COUNT; i++){\n\t\t\tc += tex(pin.Tex + gSampleOffsets[i] * gPower) * gSampleWeights[i];\n\t\t}\n\t\treturn c;\n\t}\n\n\ttechnique11 GaussianBlur {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_4_0, ps_GaussianBlur() ) );\n\t\t}\n\t}\n\n\n\tfloat4 ps_ReflectionGaussianBlur(PS_IN pin) : SV_Target {\n\t\tfloat power = saturate(1 - tex(gMapsMap, pin.Tex).y);\n\n\t\tfloat4 c = 0;\n\t\tfor (int i = 0; i < SAMPLE_COUNT; i++){\n\t\t\tc += tex(pin.Tex + gSampleOffsets[i] * power) * gSampleWeights[i];\n\t\t}\n\n\t\treturn c;\n\t}\n\n\ttechnique11 ReflectionGaussianBlur {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_4_0, ps_ReflectionGaussianBlur() ) );\n\t\t}\n\t}"), "PpBlur")){
                E = new Effect(device, bc);
			}

			TechGaussianBlur = E.GetTechniqueByName("GaussianBlur");
			TechReflectionGaussianBlur = E.GetTechniqueByName("ReflectionGaussianBlur");

			for (var i = 0; i < TechGaussianBlur.Description.PassCount && InputSignaturePT == null; i++) {
				InputSignaturePT = TechGaussianBlur.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePT == null) throw new System.Exception("input signature (PpBlur, PT, GaussianBlur) == null");
			LayoutPT = new InputLayout(device, InputSignaturePT, InputLayouts.VerticePT.InputElementsValue);

			FxInputMap = E.GetVariableByName("gInputMap").AsResource();
			FxMapsMap = E.GetVariableByName("gMapsMap").AsResource();
			FxSampleWeights = E.GetVariableByName("gSampleWeights").AsScalar();
			FxPower = E.GetVariableByName("gPower").AsScalar();
			FxSampleOffsets = E.GetVariableByName("gSampleOffsets").AsVector();
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePT.Dispose();
            LayoutPT.Dispose();
        }
	}

	public class EffectPpFxaa311 : IEffectWrapper {
		[StructLayout(LayoutKind.Sequential)]
        public struct FxaaVS_Output {


			public static readonly int Stride = Marshal.SizeOf(typeof(FxaaVS_Output));
        }
		
        public Effect E;

        public ShaderSignature InputSignaturePT;
        public InputLayout LayoutPT;

		public EffectTechnique TechLuma, TechFxaa;

		public EffectResourceVariable FxInputMap, FxDepthMap;
		public EffectScalarVariable FxSizeMultipler;
		public EffectVectorVariable FxScreenSize;

		public EffectPpFxaa311() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("\n\tTexture2D gInputMap;\n\tTexture2D gDepthMap;\n\n\tSamplerState samInputImage {\n\t\tFilter = MIN_MAG_LINEAR_MIP_POINT;\n\t\tAddressU = CLAMP;\n\t\tAddressV = CLAMP;\n\t};\n\t\n\n\tcbuffer cbPerObject : register(b0) {\n\t\tfloat4 gScreenSize;\n\t\tfloat gSizeMultipler;\n\t}\n\n\n\tstruct VS_IN {\n\t\tfloat3 PosL    : POSITION;\n\t\tfloat2 Tex     : TEXCOORD;\n\t};\n\n\tstruct PS_IN {\n\t\tfloat4 PosH    : SV_POSITION;\n\t\tfloat2 Tex     : TEXCOORD;\n\t};\n\n\n\tPS_IN vs_main(VS_IN vin) {\n\t\tPS_IN vout;\n\t\tvout.PosH = float4(vin.PosL, 1.0f);\n\t\tvout.Tex = vin.Tex;\n\t\treturn vout;\n\t}\n\n\tfloat4 ps_Luma(PS_IN pin) : SV_Target{\n\t\tfloat4 color = gInputMap.SampleLevel(samInputImage, pin.Tex, 0.0f);\n\t\tcolor.a = dot(color.rgb, float3(0.299, 0.587, 0.114));\n\t\treturn color;\n\t}\n\n\ttechnique11 Luma {\n\t\tpass P0 {\n\t\t\tSetVertexShader(CompileShader(vs_5_0, vs_main()));\n\t\t\tSetGeometryShader(NULL);\n\t\t\tSetPixelShader(CompileShader(ps_5_0, ps_Luma()));\n\t\t}\n\t}\n\n\n\t#define FXAA_PC 1\n\t#define FXAA_HLSL_5 1\n\t#define FXAA_QUALITY__PRESET 29\n\n\t#include \"FXAA_311.fx\"\n\n\tfloat4 ps_Fxaa_311(PS_IN pin) : SV_Target {\n\t\tFxaaTex tex = { samInputImage, gInputMap };\n\t\treturn FxaaPixelShader(\n\t\t\tpin.Tex,\t\t\t\t\t\t\t\t\n\t\t\tFxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f),\t\t\n\t\t\ttex,\t\t\t\t\t\t\t\n\t\t\ttex,\t\t\t\t\t\t\t\n\t\t\ttex,\t\t\t\t\t\t\t\n\t\t\tgScreenSize.zw,\t\t\t\t\t\t\t\n\t\t\tFxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f),\t\t\n\t\t\tFxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f),\t\t\n\t\t\tFxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f),\t\t\n\t\t\t1.0f,\t\t\t\t\t\t\t\t\t\n\t\t\t0.125f,\t\t\t\t\t\t\t\t\t\n\t\t\t0.0833f,\t\t\t\t\t\t\t\t\n\t\t\t0.0f,\t\t\t\t\t\t\t\t\t\n\t\t\t0.0f,\t\t\t\t\t\t\t\t\t\n\t\t\t0.0f,\t\t\t\t\t\t\t\t\t\n\t\t\tFxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f)\t\t\n\t\t);\n\t}\n\n\ttechnique11 Fxaa {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_5_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_5_0, ps_Fxaa_311() ) );\n\t\t}\n\t}"), "PpFxaa311")){
                E = new Effect(device, bc);
			}

			TechLuma = E.GetTechniqueByName("Luma");
			TechFxaa = E.GetTechniqueByName("Fxaa");

			for (var i = 0; i < TechLuma.Description.PassCount && InputSignaturePT == null; i++) {
				InputSignaturePT = TechLuma.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePT == null) throw new System.Exception("input signature (PpFxaa311, PT, Luma) == null");
			LayoutPT = new InputLayout(device, InputSignaturePT, InputLayouts.VerticePT.InputElementsValue);

			FxInputMap = E.GetVariableByName("gInputMap").AsResource();
			FxDepthMap = E.GetVariableByName("gDepthMap").AsResource();
			FxSizeMultipler = E.GetVariableByName("gSizeMultipler").AsScalar();
			FxScreenSize = E.GetVariableByName("gScreenSize").AsVector();
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePT.Dispose();
            LayoutPT.Dispose();
        }
	}

	public class EffectPpHdr : IEffectWrapper {
		
		public static readonly Vector3 LumConvert = new Vector3(0.299f, 0.587f, 0.114f);
        public Effect E;

        public ShaderSignature InputSignaturePT;
        public InputLayout LayoutPT;

		public EffectTechnique TechDownsampling, TechAdaptation, TechTonemap, TechCopy, TechBloom;

		public EffectResourceVariable FxInputMap, FxBrightnessMap, FxBloomMap;
		public EffectVectorVariable FxPixel, FxCropImage;

		public EffectPpHdr() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("#include \"Common.fx\"\n\n\tcbuffer cbPerFrame : register(b0) {\n\t\tfloat2 gPixel;\n\t\tfloat2 gCropImage;\n\t}\n\n\n\tfloat4 ps_Downsampling (PS_IN pin) : SV_Target {\n\t\tfloat2 uv = pin.Tex * gCropImage + 0.5 - gCropImage / 2;\n\t\tfloat2 delta = gPixel * uv;\n\t\t\n\t\tfloat4 color = tex(uv);\n\t\tcolor += tex(uv + float2(-delta.x, 0));\n\t\tcolor += tex(uv + float2(delta.x, 0));\n\t\tcolor += tex(uv + float2(0, -delta.y));\n\t\tcolor += tex(uv + float2(0, delta.y));\n\t\treturn saturate(color / 5);\n\t}\n\n\ttechnique11 Downsampling {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_4_0, ps_Downsampling() ) );\n\t\t}\n\t}\n\n\n\tTexture2D gBrightnessMap;\n\n\tfloat4 ps_Adaptation (PS_IN pin) : SV_Target {\n\t\treturn (tex(0.5) * 49 + tex(gBrightnessMap, 0.5)) / 50;\n\t}\n\n\ttechnique11 Adaptation {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_4_0, ps_Adaptation() ) );\n\t\t}\n\t}\n\t\n\n\tstatic const float3 LUM_CONVERT = float3(0.299f, 0.587f, 0.114f);\n\n\tTexture2D gBloomMap;\n\n\tfloat3 ToneReinhard(float3 vColor, float average, float exposure, float whitePoint){\n\t\t\n\t\tconst float3x3 RGB2XYZ = {  0.5141364, 0.3238786,  0.16036376,\n\t\t\t\t\t\t\t\t\t0.265068,  0.67023428, 0.06409157,\n\t\t\t\t\t\t\t\t\t0.0241188, 0.1228178,  0.84442666  };\t\t\t\t                    \n\t\tfloat3 XYZ = mul(RGB2XYZ, vColor.rgb);\n  \n\t\t\n\t\tfloat3 Yxy;\n\t\tYxy.r = XYZ.g;                            \n\t\tYxy.g = XYZ.r / (XYZ.r + XYZ.g + XYZ.b ); \n\t\tYxy.b = XYZ.g / (XYZ.r + XYZ.g + XYZ.b ); \n    \n\t\t\n\t\tfloat Lp = Yxy.r * exposure / average;         \n                \n\t\t\n\t\tYxy.r = (Lp * (1.0f + Lp/(whitePoint * whitePoint)))/(1.0f + Lp);\n  \n\t\t\n\t\tXYZ.r = Yxy.r * Yxy.g / Yxy. b;               \n\t\tXYZ.g = Yxy.r;                                \n\t\tXYZ.b = Yxy.r * (1 - Yxy.g - Yxy.b) / Yxy.b;  \n    \n\t\t\n\t\tconst float3x3 XYZ2RGB  = {  2.5651, -1.1665, -0.3986,\n\t\t\t\t\t\t\t\t\t-1.0217,  1.9777,  0.0439, \n\t\t\t\t\t\t\t\t\t 0.0753, -0.2543,  1.1892  };\n\t\treturn saturate(mul(XYZ2RGB, XYZ));\n\t}\n\n\tfloat4 ps_Tonemap (PS_IN pin) : SV_Target {\n\t\tfloat currentBrightness = 0.167 + dot(tex(gBrightnessMap, 0.5).rgb, LUM_CONVERT) * 0.667;\n\t\treturn float4(ToneReinhard(tex(pin.Tex).rgb, currentBrightness, 0.56, 1.2), 1) + tex(gBloomMap, pin.Tex);\n\t}\n\n\ttechnique11 Tonemap {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_4_0, ps_Tonemap() ) );\n\t\t}\n\t}\n\t\n\n\tfloat4 ps_Copy (PS_IN pin) : SV_Target {\n\t\treturn tex(pin.Tex);\n\t}\n\n\ttechnique11 Copy {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_4_0, ps_Copy() ) );\n\t\t}\n\t}\n\n\n\tfloat4 ps_Bloom (PS_IN pin) : SV_Target {\n\t\treturn saturate(tex(pin.Tex) - 2.5) * 0.5;\n\t}\n\n\ttechnique11 Bloom {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_4_0, vs_main() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_4_0, ps_Bloom() ) );\n\t\t}\n\t}"), "PpHdr")){
                E = new Effect(device, bc);
			}

			TechDownsampling = E.GetTechniqueByName("Downsampling");
			TechAdaptation = E.GetTechniqueByName("Adaptation");
			TechTonemap = E.GetTechniqueByName("Tonemap");
			TechCopy = E.GetTechniqueByName("Copy");
			TechBloom = E.GetTechniqueByName("Bloom");

			for (var i = 0; i < TechDownsampling.Description.PassCount && InputSignaturePT == null; i++) {
				InputSignaturePT = TechDownsampling.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePT == null) throw new System.Exception("input signature (PpHdr, PT, Downsampling) == null");
			LayoutPT = new InputLayout(device, InputSignaturePT, InputLayouts.VerticePT.InputElementsValue);

			FxInputMap = E.GetVariableByName("gInputMap").AsResource();
			FxBrightnessMap = E.GetVariableByName("gBrightnessMap").AsResource();
			FxBloomMap = E.GetVariableByName("gBloomMap").AsResource();
			FxPixel = E.GetVariableByName("gPixel").AsVector();
			FxCropImage = E.GetVariableByName("gCropImage").AsVector();
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePT.Dispose();
            LayoutPT.Dispose();
        }
	}

	public class EffectPpSmaa : IEffectWrapper {
		[StructLayout(LayoutKind.Sequential)]
        public struct Smaa_PS_IN {


			public static readonly int Stride = Marshal.SizeOf(typeof(Smaa_PS_IN));
        }
		[StructLayout(LayoutKind.Sequential)]
        public struct Smaa_B_PS_IN {


			public static readonly int Stride = Marshal.SizeOf(typeof(Smaa_B_PS_IN));
        }
		[StructLayout(LayoutKind.Sequential)]
        public struct Smaa_N_PS_IN {


			public static readonly int Stride = Marshal.SizeOf(typeof(Smaa_N_PS_IN));
        }
		
        public Effect E;

        public ShaderSignature InputSignaturePT;
        public InputLayout LayoutPT;

		public EffectTechnique TechSmaa, TechSmaaB, TechSmaaN;

		public EffectResourceVariable FxInputMap, FxDepthMap, FxEdgesMap, FxBlendMap, FxAreaTexMap, FxSearchTexMap;
		public EffectScalarVariable FxSizeMultipler;
		public EffectVectorVariable FxScreenSizeSpec;

		public EffectPpSmaa() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("\n\tTexture2D gInputMap;\n\tTexture2D gDepthMap;\n\n\tTexture2D gEdgesMap;\n\tTexture2D gBlendMap;\n\n\tTexture2D gAreaTexMap;\n\tTexture2D gSearchTexMap;\n\n\tSamplerState samInputImage {\n\t\tFilter = MIN_MAG_LINEAR_MIP_POINT;\n\t\tAddressU = CLAMP;\n\t\tAddressV = CLAMP;\n\t};\n\t\n\n\tcbuffer cbPerObject : register(b0) {\n\t\tfloat4 gScreenSizeSpec;\n\t\tfloat gSizeMultipler;\n\t}\n\n\n\tstruct VS_IN {\n\t\tfloat3 PosL    : POSITION;\n\t\tfloat2 Tex     : TEXCOORD;\n\t};\n\n\tstruct PS_IN {\n\t\tfloat4 PosH    : SV_POSITION;\n\t\tfloat2 Tex     : TEXCOORD;\n\t};\n\n\n\tPS_IN vs_main(VS_IN vin) {\n\t\tPS_IN vout;\n\t\tvout.PosH = float4(vin.PosL, 1.0f);\n\t\tvout.Tex = vin.Tex;\n\t\treturn vout;\n\t}\n\n\n\t#define SMAA_HLSL_4_1\n\t#define SMAA_PRESET_ULTRA\n\t#define SMAA_RT_METRICS gScreenSizeSpec\n\n\t#include \"SMAA.fx\"\n\n\n\tstruct Smaa_PS_IN {\n\t\tfloat4 PosH       : SV_POSITION;\n\t\tfloat4 Offset[3]  : OFFSET;\n\t\tfloat2 Tex        : TEXCOORD;\n\t};\n\n\tSmaa_PS_IN vs_Smaa(VS_IN vin) {\n\t\tSmaa_PS_IN vout;\n\n\t\tvout.PosH = float4(vin.PosL, 1.0f);\n\t\tvout.Tex = vin.Tex;\n\n\t\tvout.Offset[0] = mad(SMAA_RT_METRICS.xyxy, float4(-1.0, 0.0, 0.0, -1.0), vout.Tex.xyxy);\n\t\tvout.Offset[1] = mad(SMAA_RT_METRICS.xyxy, float4(1.0, 0.0, 0.0, 1.0), vout.Tex.xyxy);\n\t\tvout.Offset[2] = mad(SMAA_RT_METRICS.xyxy, float4(-2.0, 0.0, 0.0, -2.0), vout.Tex.xyxy);\n\n\t\treturn vout;\n\t}\n\n\tfloat4 ps_Smaa(Smaa_PS_IN pin) : SV_Target {\n\t\treturn float4(SMAAColorEdgeDetectionPS(pin.Tex, pin.Offset, gInputMap), 0, 0);\n\t\t\n\t\t\n\t}\n\n\ttechnique11 Smaa {\n\t\tpass P0 {\n\t\t\tSetVertexShader( CompileShader( vs_5_0, vs_Smaa() ) );\n\t\t\tSetGeometryShader( NULL );\n\t\t\tSetPixelShader( CompileShader( ps_5_0, ps_Smaa() ) );\n\t\t}\n\t}\n\n\n\tstruct Smaa_B_PS_IN {\n\t\tfloat4 PosH       : SV_POSITION;\n\t\tfloat2 Pix        : PIXCOORD;\n\t\tfloat4 Offset[3]  : OFFSET;\n\t\tfloat2 Tex        : TEXCOORD;\n\t};\n\n\tSmaa_B_PS_IN vs_Smaa_B(VS_IN vin) {\n\t\tSmaa_B_PS_IN vout;\n\n\t\tvout.PosH = float4(vin.PosL, 1.0f);\n\t\tvout.Tex = vin.Tex;\n\n\t\tvout.Pix = vout.Tex * SMAA_RT_METRICS.zw;\n\n\t\tvout.Offset[0] = mad(SMAA_RT_METRICS.xyxy, float4(-0.25, -0.125, 1.25, -0.125), vout.Tex.xyxy);\n\t\tvout.Offset[1] = mad(SMAA_RT_METRICS.xyxy, float4(-0.125, -0.25, -0.125, 1.25), vout.Tex.xyxy);\n\n\t\t\n\t\tvout.Offset[2] = mad(SMAA_RT_METRICS.xxyy,\n\t\t\tfloat4(-2.0, 2.0, -2.0, 2.0) * float(SMAA_MAX_SEARCH_STEPS),\n\t\t\tfloat4(vout.Offset[0].xz, vout.Offset[1].yw));\n\n\t\treturn vout;\n\t}\n\n\tfloat4 ps_Smaa_B(Smaa_B_PS_IN pin) : SV_Target {\n\t\treturn SMAABlendingWeightCalculationPS(pin.Tex, pin.Pix, pin.Offset, gEdgesMap, gAreaTexMap, gSearchTexMap, float4(0, 0, 0, 0));\n\t}\n\n\ttechnique11 SmaaB {\n\t\tpass P0 {\n\t\t\tSetVertexShader(CompileShader(vs_5_0, vs_Smaa_B()));\n\t\t\tSetGeometryShader(NULL);\n\t\t\tSetPixelShader(CompileShader(ps_5_0, ps_Smaa_B()));\n\t\t}\n\t}\n\n\n\tstruct Smaa_N_PS_IN {\n\t\tfloat4 PosH       : SV_POSITION;\n\t\tfloat4 Offset     : OFFSET;\n\t\tfloat2 Tex        : TEXCOORD;\n\t};\n\n\tSmaa_N_PS_IN vs_Smaa_N(VS_IN vin) {\n\t\tSmaa_N_PS_IN vout;\n\n\t\tvout.PosH = float4(vin.PosL, 1.0f);\n\t\tvout.Tex = vin.Tex;\n\t\tvout.Offset = mad(SMAA_RT_METRICS.xyxy, float4(1.0, 0.0, 0.0, 1.0), vout.Tex.xyxy);\n\n\t\treturn vout;\n\t}\n\n\tfloat4 ps_Smaa_N(Smaa_N_PS_IN pin) : SV_Target {\n\t\treturn SMAANeighborhoodBlendingPS(pin.Tex, pin.Offset, gInputMap, gBlendMap);\n\t}\n\n\ttechnique11 SmaaN {\n\t\tpass P0 {\n\t\t\tSetVertexShader(CompileShader(vs_5_0, vs_Smaa_N()));\n\t\t\tSetGeometryShader(NULL);\n\t\t\tSetPixelShader(CompileShader(ps_5_0, ps_Smaa_N()));\n\t\t}\n\t}"), "PpSmaa")){
                E = new Effect(device, bc);
			}

			TechSmaa = E.GetTechniqueByName("Smaa");
			TechSmaaB = E.GetTechniqueByName("SmaaB");
			TechSmaaN = E.GetTechniqueByName("SmaaN");

			for (var i = 0; i < TechSmaa.Description.PassCount && InputSignaturePT == null; i++) {
				InputSignaturePT = TechSmaa.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePT == null) throw new System.Exception("input signature (PpSmaa, PT, Smaa) == null");
			LayoutPT = new InputLayout(device, InputSignaturePT, InputLayouts.VerticePT.InputElementsValue);

			FxInputMap = E.GetVariableByName("gInputMap").AsResource();
			FxDepthMap = E.GetVariableByName("gDepthMap").AsResource();
			FxEdgesMap = E.GetVariableByName("gEdgesMap").AsResource();
			FxBlendMap = E.GetVariableByName("gBlendMap").AsResource();
			FxAreaTexMap = E.GetVariableByName("gAreaTexMap").AsResource();
			FxSearchTexMap = E.GetVariableByName("gSearchTexMap").AsResource();
			FxSizeMultipler = E.GetVariableByName("gSizeMultipler").AsScalar();
			FxScreenSizeSpec = E.GetVariableByName("gScreenSizeSpec").AsVector();
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePT.Dispose();
            LayoutPT.Dispose();
        }
	}

	public class EffectTestingCube : IEffectWrapper {
		
		
        public Effect E;

        public ShaderSignature InputSignaturePC;
        public InputLayout LayoutPC;

		public EffectTechnique TechCube;

		public EffectMatrixVariable FxWorldViewProj { get; private set; }

		public EffectTestingCube() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("struct VS_IN {\n    float3 pos : POSITION;\n    float4 col : COLOR;\n};\n\nstruct PS_IN {\n    float4 pos : SV_POSITION;\n    float4 col : COLOR;\n};\n\ncbuffer cbPerObject : register(b0) {\n\tfloat4x4 gWorldViewProj;\n}\n\nPS_IN vs_main( VS_IN input ){\n    PS_IN output = (PS_IN)0;\n    \n    output.pos = mul(float4(input.pos, 1.0f), gWorldViewProj);\n    output.col = input.col;\n    \n    return output;\n}\n\nfloat4 ps_main( PS_IN input ) : SV_Target {\n    return input.col;\n}\n\ntechnique11 Cube { \n    pass P0 {\n        SetVertexShader( CompileShader( vs_4_0, vs_main() ) );\n        SetGeometryShader( NULL );\n        SetPixelShader( CompileShader( ps_4_0, ps_main() ) );\n    }\n}"), "TestingCube")){
                E = new Effect(device, bc);
			}

			TechCube = E.GetTechniqueByName("Cube");

			for (var i = 0; i < TechCube.Description.PassCount && InputSignaturePC == null; i++) {
				InputSignaturePC = TechCube.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePC == null) throw new System.Exception("input signature (TestingCube, PC, Cube) == null");
			LayoutPC = new InputLayout(device, InputSignaturePC, InputLayouts.VerticePC.InputElementsValue);

			FxWorldViewProj = E.GetVariableByName("gWorldViewProj").AsMatrix();
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePC.Dispose();
            LayoutPC.Dispose();
        }
	}

	public class EffectTestingPnt : IEffectWrapper {
		
		
        public Effect E;

        public ShaderSignature InputSignaturePNT;
        public InputLayout LayoutPNT;

		public EffectTechnique TechCube;

		public EffectMatrixVariable FxWorldViewProj { get; private set; }

		public EffectTestingPnt() {
		}

		public void Initialize(Device device) {
            using (var bc = EffectUtils.Compile(Encoding.UTF8.GetBytes("struct VS_IN {\n    float3 pos    : POSITION;\n    float3 nor    : NORMAL;\n\tfloat2 tex    : TEXCOORD;\n};\n\nstruct PS_IN {\n    float4 pos : SV_POSITION;\n    float4 col : COLOR;\n};\n\ncbuffer cbPerObject : register(b0) {\n\tfloat4x4 gWorldViewProj;\n}\n\nPS_IN vs_main( VS_IN input ){\n    PS_IN output = (PS_IN)0;\n    \n    output.pos = mul(float4(input.pos, 1.0f), gWorldViewProj);\n    output.col = float4(input.tex, input.nor.xy);\n    \n    return output;\n}\n\nfloat4 ps_main( PS_IN input ) : SV_Target {\n    return input.col;\n}\n\ntechnique11 Cube { \n    pass P0 {\n        SetVertexShader( CompileShader( vs_4_0, vs_main() ) );\n        SetGeometryShader( NULL );\n        SetPixelShader( CompileShader( ps_4_0, ps_main() ) );\n    }\n}"), "TestingPnt")){
                E = new Effect(device, bc);
			}

			TechCube = E.GetTechniqueByName("Cube");

			for (var i = 0; i < TechCube.Description.PassCount && InputSignaturePNT == null; i++) {
				InputSignaturePNT = TechCube.GetPassByIndex(i).Description.Signature;
			}
			if (InputSignaturePNT == null) throw new System.Exception("input signature (TestingPnt, PNT, Cube) == null");
			LayoutPNT = new InputLayout(device, InputSignaturePNT, InputLayouts.VerticePNT.InputElementsValue);

			FxWorldViewProj = E.GetVariableByName("gWorldViewProj").AsMatrix();
		}

        public void Dispose() {
            E.Dispose();
			InputSignaturePNT.Dispose();
            LayoutPNT.Dispose();
        }
	}


	public static class EffectUtils {
		private static string GetIncludedData(string filename){
			switch(filename){
				case "Common.fx":
					return "SamplerState samInputImage {\n\tFilter = MIN_MAG_LINEAR_MIP_POINT;\n\tAddressU = CLAMP;\n\tAddressV = CLAMP;\n};\n\nTexture2D gInputMap;\n\nfloat4 tex(float2 uv){\n\treturn gInputMap.SampleLevel(samInputImage, uv, 0.0);\n}\n\nfloat4 tex(Texture2D t, float2 uv){\n\treturn t.SampleLevel(samInputImage, uv, 0.0);\n}\n\nstruct VS_IN {\n\tfloat3 PosL    : POSITION;\n\tfloat2 Tex     : TEXCOORD;\n};\n\nstruct PS_IN {\n\tfloat4 PosH    : SV_POSITION;\n\tfloat2 Tex     : TEXCOORD;\n};\n\nPS_IN vs_main(VS_IN vin) {\n\tPS_IN vout;\n\tvout.PosH = float4(vin.PosL, 1.0f);\n\tvout.Tex = vin.Tex;\n\treturn vout;\n}\n";
				case "Deferred.fx":
					return "struct VS_IN {\n\tfloat3 PosL       : POSITION;\n\tfloat3 NormalL    : NORMAL;\n\tfloat2 Tex        : TEXCOORD;\n\tfloat3 TangentL   : TANGENT;\n};\n\nstruct PS_IN {\n\tfloat4 PosH       : SV_POSITION;\n\tfloat3 PosW       : POSITION;\n\tfloat3 NormalW    : NORMAL;\n\tfloat2 Tex        : TEXCOORD;\n\tfloat3 TangentW   : TANGENT;\n};\n\nstruct PosOnly_PS_IN {\n\tfloat4 PosH       : SV_POSITION;\n};\n\nstruct PS_OUT {\n\tfloat4 Base   : SV_Target0;\n\tfloat4 Normal : SV_Target1;\n\tfloat4 Maps   : SV_Target2;\n};\n\nSamplerState samAnisotropic {\n\tFilter = ANISOTROPIC;\n\tMaxAnisotropy = 4;\n\n\tAddressU = WRAP;\n\tAddressV = WRAP;\n};\n\n";
				case "FXAA.fx":
					return "// Copyright (c) 2011 NVIDIA Corporation. All rights reserved.\n//\n// TO  THE MAXIMUM  EXTENT PERMITTED  BY APPLICABLE  LAW, THIS SOFTWARE  IS PROVIDED\n// *AS IS*  AND NVIDIA AND  ITS SUPPLIERS DISCLAIM  ALL WARRANTIES,  EITHER  EXPRESS\n// OR IMPLIED, INCLUDING, BUT NOT LIMITED  TO, NONINFRINGEMENT,IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL  NVIDIA \n// OR ITS SUPPLIERS BE  LIABLE  FOR  ANY  DIRECT, SPECIAL,  INCIDENTAL,  INDIRECT,  OR  \n// CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION,  DAMAGES FOR LOSS \n// OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY \n// OTHER PECUNIARY LOSS) ARISING OUT OF THE  USE OF OR INABILITY  TO USE THIS SOFTWARE, \n// EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n//\n// Please direct any bugs or questions to SDKFeedback@nvidia.com\n\n#define FXAA_HLSL_4 1\n\n\n/*============================================================================\n \n                                    FXAA                                 \n \n============================================================================*/\n \n/*============================================================================\n                                 API PORTING\n============================================================================*/\n#ifndef     FXAA_GLSL_120\n    #define FXAA_GLSL_120 0\n#endif\n#ifndef     FXAA_GLSL_130\n    #define FXAA_GLSL_130 0\n#endif\n#ifndef     FXAA_HLSL_3\n    #define FXAA_HLSL_3 0\n#endif\n#ifndef     FXAA_HLSL_4\n    #define FXAA_HLSL_4 0\n#endif    \n/*--------------------------------------------------------------------------*/\n#if FXAA_GLSL_120\n    // Requires,\n    //  #version 120\n    //  #extension GL_EXT_gpu_shader4 : enable\n    #define int2 ivec2\n    #define float2 vec2\n    #define float3 vec3\n    #define float4 vec4\n    #define FxaaBool3 bvec3\n    #define FxaaInt2 ivec2\n    #define FxaaFloat2 vec2\n    #define FxaaFloat3 vec3\n    #define FxaaFloat4 vec4\n    #define FxaaBool2Float(a) mix(0.0, 1.0, (a))\n    #define FxaaPow3(x, y) pow(x, y)\n    #define FxaaSel3(f, t, b) mix((f), (t), (b))\n    #define FxaaTex sampler2D\n#endif\n/*--------------------------------------------------------------------------*/\n#if FXAA_GLSL_130\n    // Requires \"#version 130\" or better\n    #define int2 ivec2\n    #define float2 vec2\n    #define float3 vec3\n    #define float4 vec4\n    #define FxaaBool3 bvec3\n    #define FxaaInt2 ivec2\n    #define FxaaFloat2 vec2\n    #define FxaaFloat3 vec3\n    #define FxaaFloat4 vec4\n    #define FxaaBool2Float(a) mix(0.0, 1.0, (a))\n    #define FxaaPow3(x, y) pow(x, y)\n    #define FxaaSel3(f, t, b) mix((f), (t), (b))\n    #define FxaaTex sampler2D\n#endif\n/*--------------------------------------------------------------------------*/\n#if FXAA_HLSL_3\n    #define int2 float2\n    #define FxaaInt2 float2\n    #define FxaaFloat2 float2\n    #define FxaaFloat3 float3\n    #define FxaaFloat4 float4\n    #define FxaaBool2Float(a) (a)\n    #define FxaaPow3(x, y) pow(x, y)\n    #define FxaaSel3(f, t, b) ((f)*(!b) + (t)*(b))\n    #define FxaaTex sampler2D\n#endif\n/*--------------------------------------------------------------------------*/\n#if FXAA_HLSL_4\n    #define FxaaInt2 int2\n    #define FxaaFloat2 float2\n    #define FxaaFloat3 float3\n    #define FxaaFloat4 float4\n    #define FxaaBool2Float(a) (a)\n    #define FxaaPow3(x, y) pow(x, y)\n    #define FxaaSel3(f, t, b) ((f)*(!b) + (t)*(b))\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n#endif\n/*--------------------------------------------------------------------------*/\n#define FxaaToFloat3(a) FxaaFloat3((a), (a), (a))\n/*--------------------------------------------------------------------------*/\nfloat4 FxaaTexLod0(FxaaTex tex, float2 pos) {\n    #if FXAA_GLSL_120\n        return texture2DLod(tex, pos.xy, 0.0);\n    #endif\n    #if FXAA_GLSL_130\n        return textureLod(tex, pos.xy, 0.0);\n    #endif\n    #if FXAA_HLSL_3\n        return tex2Dlod(tex, float4(pos.xy, 0.0, 0.0)); \n    #endif\n    #if FXAA_HLSL_4\n        return tex.tex.SampleLevel(tex.smpl, pos.xy, 0.0);\n    #endif\n}\n/*--------------------------------------------------------------------------*/\nfloat4 FxaaTexGrad(FxaaTex tex, float2 pos, float2 grad) {\n    #if FXAA_GLSL_120\n        return texture2DGrad(tex, pos.xy, grad, grad);\n    #endif\n    #if FXAA_GLSL_130\n        return textureGrad(tex, pos.xy, grad, grad);\n    #endif\n    #if FXAA_HLSL_3\n        return tex2Dgrad(tex, pos.xy, grad, grad); \n    #endif\n    #if FXAA_HLSL_4\n        return tex.tex.SampleGrad(tex.smpl, pos.xy, grad, grad);\n    #endif\n}\n/*--------------------------------------------------------------------------*/\nfloat4 FxaaTexOff(FxaaTex tex, float2 pos, int2 off, float2 rcpFrame) {\n    #if FXAA_GLSL_120\n        return texture2DLodOffset(tex, pos.xy, 0.0, off.xy);\n    #endif\n    #if FXAA_GLSL_130\n        return textureLodOffset(tex, pos.xy, 0.0, off.xy);\n    #endif\n    #if FXAA_HLSL_3\n        return tex2Dlod(tex, float4(pos.xy + (off * rcpFrame), 0, 0)); \n    #endif\n    #if FXAA_HLSL_4\n        return tex.tex.SampleLevel(tex.smpl, pos.xy, 0.0, off.xy);\n    #endif\n}\n\n/*============================================================================\n                                 SRGB KNOBS\n------------------------------------------------------------------------------\nFXAA_SRGB_ROP - Set to 1 when applying FXAA to an sRGB back buffer (DX10/11).\n                This will do the sRGB to linear transform, \n                as ROP will expect linear color from this shader,\n                and this shader works in non-linear color.\n============================================================================*/\n#define FXAA_SRGB_ROP 0\n\n/*============================================================================\n                                DEBUG KNOBS\n------------------------------------------------------------------------------\nAll debug knobs draw FXAA-untouched pixels in FXAA computed luma (monochrome).\n \nFXAA_DEBUG_PASSTHROUGH - Red for pixels which are filtered by FXAA with a\n                         yellow tint on sub-pixel aliasing filtered by FXAA.\nFXAA_DEBUG_HORZVERT    - Blue for horizontal edges, gold for vertical edges. \nFXAA_DEBUG_PAIR        - Blue/green for the 2 pixel pair choice. \nFXAA_DEBUG_NEGPOS      - Red/blue for which side of center of span.\nFXAA_DEBUG_OFFSET      - Red/blue for -/+ x, gold/skyblue for -/+ y.\n============================================================================*/\n#ifndef     FXAA_DEBUG_PASSTHROUGH\n    #define FXAA_DEBUG_PASSTHROUGH 0\n#endif    \n#ifndef     FXAA_DEBUG_HORZVERT\n    #define FXAA_DEBUG_HORZVERT    0\n#endif    \n#ifndef     FXAA_DEBUG_PAIR   \n    #define FXAA_DEBUG_PAIR        0\n#endif    \n#ifndef     FXAA_DEBUG_NEGPOS\n    #define FXAA_DEBUG_NEGPOS      0\n#endif\n#ifndef     FXAA_DEBUG_OFFSET\n    #define FXAA_DEBUG_OFFSET      0\n#endif    \n/*--------------------------------------------------------------------------*/\n#if FXAA_DEBUG_PASSTHROUGH || FXAA_DEBUG_HORZVERT || FXAA_DEBUG_PAIR\n    #define FXAA_DEBUG 1\n#endif    \n#if FXAA_DEBUG_NEGPOS || FXAA_DEBUG_OFFSET\n    #define FXAA_DEBUG 1\n#endif\n#ifndef FXAA_DEBUG\n    #define FXAA_DEBUG 0\n#endif\n  \n/*============================================================================\n                              COMPILE-IN KNOBS\n------------------------------------------------------------------------------\nFXAA_PRESET - Choose compile-in knob preset 0-5.\n------------------------------------------------------------------------------\nFXAA_EDGE_THRESHOLD - The minimum amount of local contrast required \n                      to apply algorithm.\n                      1.0/3.0  - too little\n                      1.0/4.0  - good start\n                      1.0/8.0  - applies to more edges\n                      1.0/16.0 - overkill\n------------------------------------------------------------------------------\nFXAA_EDGE_THRESHOLD_MIN - Trims the algorithm from processing darks.\n                          Perf optimization.\n                          1.0/32.0 - visible limit (smaller isn't visible)\n                          1.0/16.0 - good compromise\n                          1.0/12.0 - upper limit (seeing artifacts)\n------------------------------------------------------------------------------\nFXAA_SEARCH_STEPS - Maximum number of search steps for end of span.\n------------------------------------------------------------------------------\nFXAA_SEARCH_ACCELERATION - How much to accelerate search,\n                           1 - no acceleration\n                           2 - skip by 2 pixels\n                           3 - skip by 3 pixels\n                           4 - skip by 4 pixels\n------------------------------------------------------------------------------\nFXAA_SEARCH_THRESHOLD - Controls when to stop searching.\n                        1.0/4.0 - seems to be the best quality wise\n------------------------------------------------------------------------------\nFXAA_SUBPIX_FASTER - Turn on lower quality but faster subpix path.\n                     Not recomended, but used in preset 0.\n------------------------------------------------------------------------------\nFXAA_SUBPIX - Toggle subpix filtering.\n              0 - turn off\n              1 - turn on\n              2 - turn on full (ignores FXAA_SUBPIX_TRIM and CAP)\n------------------------------------------------------------------------------\nFXAA_SUBPIX_TRIM - Controls sub-pixel aliasing removal.\n                   1.0/2.0 - low removal\n                   1.0/3.0 - medium removal\n                   1.0/4.0 - default removal\n                   1.0/8.0 - high removal\n                   0.0 - complete removal\n------------------------------------------------------------------------------\nFXAA_SUBPIX_CAP - Insures fine detail is not completely removed.\n                  This is important for the transition of sub-pixel detail,\n                  like fences and wires.\n                  3.0/4.0 - default (medium amount of filtering)\n                  7.0/8.0 - high amount of filtering\n                  1.0 - no capping of sub-pixel aliasing removal\n============================================================================*/\n#ifndef FXAA_PRESET\n    #define FXAA_PRESET 3\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_PRESET == 0)\n    #define FXAA_EDGE_THRESHOLD      (1.0/4.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/12.0)\n    #define FXAA_SEARCH_STEPS        2\n    #define FXAA_SEARCH_ACCELERATION 4\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX              1\n    #define FXAA_SUBPIX_FASTER       1\n    #define FXAA_SUBPIX_CAP          (2.0/3.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_PRESET == 1)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/16.0)\n    #define FXAA_SEARCH_STEPS        4\n    #define FXAA_SEARCH_ACCELERATION 3\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX              1\n    #define FXAA_SUBPIX_FASTER       0\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_PRESET == 2)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        8\n    #define FXAA_SEARCH_ACCELERATION 2\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX              1\n    #define FXAA_SUBPIX_FASTER       0\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_PRESET == 3)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        16\n    #define FXAA_SEARCH_ACCELERATION 1\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX              1\n    #define FXAA_SUBPIX_FASTER       0\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_PRESET == 4)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        24\n    #define FXAA_SEARCH_ACCELERATION 1\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX              1\n    #define FXAA_SUBPIX_FASTER       0\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_PRESET == 5)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        32\n    #define FXAA_SEARCH_ACCELERATION 1\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX              1\n    #define FXAA_SUBPIX_FASTER       0\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#define FXAA_SUBPIX_TRIM_SCALE (1.0/(1.0 - FXAA_SUBPIX_TRIM))\n\n/*============================================================================\n                                   HELPERS\n============================================================================*/\n// Return the luma, the estimation of luminance from rgb inputs.\n// This approximates luma using one FMA instruction,\n// skipping normalization and tossing out blue.\n// FxaaLuma() will range 0.0 to 2.963210702.\nfloat FxaaLuma(float3 rgb) {\n    return rgb.y * (0.587/0.299) + rgb.x; } \n/*--------------------------------------------------------------------------*/\nfloat3 FxaaLerp3(float3 a, float3 b, float amountOfA) {\n    return (FxaaToFloat3(-amountOfA) * b) + \n        ((a * FxaaToFloat3(amountOfA)) + b); } \n/*--------------------------------------------------------------------------*/\n// Support any extra filtering before returning color.\nfloat3 FxaaFilterReturn(float3 rgb) {\n    #if FXAA_SRGB_ROP\n        // Do sRGB encoded value to linear conversion.\n        return FxaaSel3(\n            rgb * FxaaToFloat3(1.0/12.92), \n            FxaaPow3(\n                rgb * FxaaToFloat3(1.0/1.055) + FxaaToFloat3(0.055/1.055), \n                FxaaToFloat3(2.4)),\n            rgb > FxaaToFloat3(0.04045)); \n    #else\n        return rgb;\n    #endif\n}\n \n/*============================================================================\n                                VERTEX SHADER\n============================================================================*/\nfloat2 FxaaVertexShader(\n// Both x and y range {-1.0 to 1.0 across screen}.\nfloat2 inPos) {\n    float2 pos;\n    pos.xy = (inPos.xy * FxaaFloat2(0.5, 0.5)) + FxaaFloat2(0.5, 0.5);\n    return pos; }  \n \n/*============================================================================\n \n                                PIXEL SHADER\n                                \n============================================================================*/\nfloat3 FxaaPixelShader(\n// Output of FxaaVertexShader interpolated across screen.\n//  xy -> actual texture position {0.0 to 1.0}\nfloat2 pos,\n// Input texture.\nFxaaTex tex,\n// RCPFRAME SHOULD PIXEL SHADER CONSTANTS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// {1.0/frameWidth, 1.0/frameHeight}\nfloat2 rcpFrame) {\n    \n/*----------------------------------------------------------------------------\n            EARLY EXIT IF LOCAL CONTRAST BELOW EDGE DETECT LIMIT\n------------------------------------------------------------------------------\nMajority of pixels of a typical image do not require filtering, \noften pixels are grouped into blocks which could benefit from early exit \nright at the beginning of the algorithm. \nGiven the following neighborhood, \n \n      N   \n    W M E\n      S   \n    \nIf the difference in local maximum and minimum luma (contrast \"range\") \nis lower than a threshold proportional to the maximum local luma (\"rangeMax\"), \nthen the shader early exits (no visible aliasing). \nThis threshold is clamped at a minimum value (\"FXAA_EDGE_THRESHOLD_MIN\")\nto avoid processing in really dark areas.    \n----------------------------------------------------------------------------*/\n    float3 rgbN = FxaaTexOff(tex, pos.xy, FxaaInt2( 0,-1), rcpFrame).xyz;\n    float3 rgbW = FxaaTexOff(tex, pos.xy, FxaaInt2(-1, 0), rcpFrame).xyz;\n    float3 rgbM = FxaaTexOff(tex, pos.xy, FxaaInt2( 0, 0), rcpFrame).xyz;\n    float3 rgbE = FxaaTexOff(tex, pos.xy, FxaaInt2( 1, 0), rcpFrame).xyz;\n    float3 rgbS = FxaaTexOff(tex, pos.xy, FxaaInt2( 0, 1), rcpFrame).xyz;\n    float lumaN = FxaaLuma(rgbN);\n    float lumaW = FxaaLuma(rgbW);\n    float lumaM = FxaaLuma(rgbM);\n    float lumaE = FxaaLuma(rgbE);\n    float lumaS = FxaaLuma(rgbS);\n    float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));\n    float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));\n    float range = rangeMax - rangeMin;\n    #if FXAA_DEBUG\n        float lumaO = lumaM / (1.0 + (0.587/0.299));\n    #endif        \n    if(range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * FXAA_EDGE_THRESHOLD)) {\n        #if FXAA_DEBUG\n            return FxaaFilterReturn(FxaaToFloat3(lumaO));\n        #endif\n        return FxaaFilterReturn(rgbM); }\n    #if FXAA_SUBPIX > 0\n        #if FXAA_SUBPIX_FASTER\n            float3 rgbL = (rgbN + rgbW + rgbE + rgbS + rgbM) * \n                FxaaToFloat3(1.0/5.0);\n        #else\n            float3 rgbL = rgbN + rgbW + rgbM + rgbE + rgbS;\n        #endif\n    #endif        \n    \n/*----------------------------------------------------------------------------\n                               COMPUTE LOWPASS\n------------------------------------------------------------------------------\nFXAA computes a local neighborhood lowpass value as follows,\n \n  (N + W + E + S)/4\n  \nThen uses the ratio of the contrast range of the lowpass \nand the range found in the early exit check, \nas a sub-pixel aliasing detection filter. \nWhen FXAA detects sub-pixel aliasing (such as single pixel dots), \nit later blends in \"blendL\" amount \nof a lowpass value (computed in the next section) to the final result.\n----------------------------------------------------------------------------*/\n    #if FXAA_SUBPIX != 0\n        float lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25;\n        float rangeL = abs(lumaL - lumaM);\n    #endif        \n    #if FXAA_SUBPIX == 1\n        float blendL = max(0.0, \n            (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE; \n        blendL = min(FXAA_SUBPIX_CAP, blendL);\n    #endif\n    #if FXAA_SUBPIX == 2\n        float blendL = rangeL / range; \n    #endif\n    #if FXAA_DEBUG_PASSTHROUGH\n        #if FXAA_SUBPIX == 0\n            float blendL = 0.0;\n        #endif\n        return FxaaFilterReturn(\n            FxaaFloat3(1.0, blendL/FXAA_SUBPIX_CAP, 0.0));\n    #endif    \n    \n/*----------------------------------------------------------------------------\n                    CHOOSE VERTICAL OR HORIZONTAL SEARCH\n------------------------------------------------------------------------------\nFXAA uses the following local neighborhood,\n \n    NW N NE\n    W  M  E\n    SW S SE\n    \nTo compute an edge amount for both vertical and horizontal directions.\nNote edge detect filters like Sobel fail on single pixel lines through M.\nFXAA takes the weighted average magnitude of the high-pass values \nfor rows and columns as an indication of local edge amount.\n \nA lowpass value for anti-sub-pixel-aliasing is computed as \n    (N+W+E+S+M+NW+NE+SW+SE)/9.\nThis full box pattern has higher quality than other options.\n \nNote following this block, both vertical and horizontal cases\nflow in parallel (reusing the horizontal variables).\n----------------------------------------------------------------------------*/\n    float3 rgbNW = FxaaTexOff(tex, pos.xy, FxaaInt2(-1,-1), rcpFrame).xyz;\n    float3 rgbNE = FxaaTexOff(tex, pos.xy, FxaaInt2( 1,-1), rcpFrame).xyz;\n    float3 rgbSW = FxaaTexOff(tex, pos.xy, FxaaInt2(-1, 1), rcpFrame).xyz;\n    float3 rgbSE = FxaaTexOff(tex, pos.xy, FxaaInt2( 1, 1), rcpFrame).xyz;\n    #if (FXAA_SUBPIX_FASTER == 0) && (FXAA_SUBPIX > 0)\n        rgbL += (rgbNW + rgbNE + rgbSW + rgbSE);\n        rgbL *= FxaaToFloat3(1.0/9.0);\n    #endif\n    float lumaNW = FxaaLuma(rgbNW);\n    float lumaNE = FxaaLuma(rgbNE);\n    float lumaSW = FxaaLuma(rgbSW);\n    float lumaSE = FxaaLuma(rgbSE);\n    float edgeVert = \n        abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +\n        abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +\n        abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));\n    float edgeHorz = \n        abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +\n        abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +\n        abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));\n    bool horzSpan = edgeHorz >= edgeVert;\n    #if FXAA_DEBUG_HORZVERT\n        if(horzSpan) return FxaaFilterReturn(FxaaFloat3(1.0, 0.75, 0.0));\n        else         return FxaaFilterReturn(FxaaFloat3(0.0, 0.50, 1.0));\n    #endif\n    float lengthSign = horzSpan ? -rcpFrame.y : -rcpFrame.x;\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    float gradientN = abs(lumaN - lumaM);\n    float gradientS = abs(lumaS - lumaM);\n    lumaN = (lumaN + lumaM) * 0.5;\n    lumaS = (lumaS + lumaM) * 0.5;\n    \n/*----------------------------------------------------------------------------\n                CHOOSE SIDE OF PIXEL WHERE GRADIENT IS HIGHEST\n------------------------------------------------------------------------------\nThis chooses a pixel pair. \nFor \"horzSpan == true\" this will be a vertical pair,\n \n    [N]     N\n    [M] or [M]\n     S     [S]\n \nNote following this block, both {N,M} and {S,M} cases\nflow in parallel (reusing the {N,M} variables).\n \nThis pair of image rows or columns is searched below\nin the positive and negative direction \nuntil edge status changes \n(or the maximum number of search steps is reached).\n----------------------------------------------------------------------------*/    \n    bool pairN = gradientN >= gradientS;\n    #if FXAA_DEBUG_PAIR\n        if(pairN) return FxaaFilterReturn(FxaaFloat3(0.0, 0.0, 1.0));\n        else      return FxaaFilterReturn(FxaaFloat3(0.0, 1.0, 0.0));\n    #endif\n    if(!pairN) lumaN = lumaS;\n    if(!pairN) gradientN = gradientS;\n    if(!pairN) lengthSign *= -1.0;\n    float2 posN;\n    posN.x = pos.x + (horzSpan ? 0.0 : lengthSign * 0.5);\n    posN.y = pos.y + (horzSpan ? lengthSign * 0.5 : 0.0);\n    \n/*----------------------------------------------------------------------------\n                         CHOOSE SEARCH LIMITING VALUES\n------------------------------------------------------------------------------\nSearch limit (+/- gradientN) is a function of local gradient.\n----------------------------------------------------------------------------*/\n    gradientN *= FXAA_SEARCH_THRESHOLD;\n    \n/*----------------------------------------------------------------------------\n    SEARCH IN BOTH DIRECTIONS UNTIL FIND LUMA PAIR AVERAGE IS OUT OF RANGE\n------------------------------------------------------------------------------\nThis loop searches either in vertical or horizontal directions,\nand in both the negative and positive direction in parallel.\nThis loop fusion is faster than searching separately.\n \nThe search is accelerated using FXAA_SEARCH_ACCELERATION length box filter\nvia anisotropic filtering with specified texture gradients.\n----------------------------------------------------------------------------*/\n    float2 posP = posN;\n    float2 offNP = horzSpan ? \n        FxaaFloat2(rcpFrame.x, 0.0) :\n        FxaaFloat2(0.0f, rcpFrame.y); \n    float lumaEndN = lumaN;\n    float lumaEndP = lumaN;\n    bool doneN = false;\n    bool doneP = false;\n    #if FXAA_SEARCH_ACCELERATION == 1\n        posN += offNP * FxaaFloat2(-1.0, -1.0);\n        posP += offNP * FxaaFloat2( 1.0,  1.0);\n    #endif\n    #if FXAA_SEARCH_ACCELERATION == 2\n        posN += offNP * FxaaFloat2(-1.5, -1.5);\n        posP += offNP * FxaaFloat2( 1.5,  1.5);\n        offNP *= FxaaFloat2(2.0, 2.0);\n    #endif\n    #if FXAA_SEARCH_ACCELERATION == 3\n        posN += offNP * FxaaFloat2(-2.0, -2.0);\n        posP += offNP * FxaaFloat2( 2.0,  2.0);\n        offNP *= FxaaFloat2(3.0, 3.0);\n    #endif\n    #if FXAA_SEARCH_ACCELERATION == 4\n        posN += offNP * FxaaFloat2(-2.5, -2.5);\n        posP += offNP * FxaaFloat2( 2.5,  2.5);\n        offNP *= FxaaFloat2(4.0, 4.0);\n    #endif\n    for(int i = 0; i < FXAA_SEARCH_STEPS; i++) {\n        #if FXAA_SEARCH_ACCELERATION == 1\n            if(!doneN) lumaEndN = \n                FxaaLuma(FxaaTexLod0(tex, posN.xy).xyz);\n            if(!doneP) lumaEndP = \n                FxaaLuma(FxaaTexLod0(tex, posP.xy).xyz);\n        #else\n            if(!doneN) lumaEndN = \n                FxaaLuma(FxaaTexGrad(tex, posN.xy, offNP).xyz);\n            if(!doneP) lumaEndP = \n                FxaaLuma(FxaaTexGrad(tex, posP.xy, offNP).xyz);\n        #endif\n        doneN = doneN || (abs(lumaEndN - lumaN) >= gradientN);\n        doneP = doneP || (abs(lumaEndP - lumaN) >= gradientN);\n        if(doneN && doneP) break;\n        if(!doneN) posN -= offNP;\n        if(!doneP) posP += offNP; }\n    \n/*----------------------------------------------------------------------------\n               HANDLE IF CENTER IS ON POSITIVE OR NEGATIVE SIDE \n------------------------------------------------------------------------------\nFXAA uses the pixel's position in the span \nin combination with the values (lumaEnd*) at the ends of the span,\nto determine filtering.\n \nThis step computes which side of the span the pixel is on. \nOn negative side if dstN < dstP,\n \n     posN        pos                      posP\n      |-----------|------|------------------|\n      |           |      |                  | \n      |<--dstN--->|<---------dstP---------->|\n                         |\n                    span center\n                    \n----------------------------------------------------------------------------*/\n    float dstN = horzSpan ? pos.x - posN.x : pos.y - posN.y;\n    float dstP = horzSpan ? posP.x - pos.x : posP.y - pos.y;\n    bool directionN = dstN < dstP;\n    #if FXAA_DEBUG_NEGPOS\n        if(directionN) return FxaaFilterReturn(FxaaFloat3(1.0, 0.0, 0.0));\n        else           return FxaaFilterReturn(FxaaFloat3(0.0, 0.0, 1.0));\n    #endif\n    lumaEndN = directionN ? lumaEndN : lumaEndP;\n    \n/*----------------------------------------------------------------------------\n         CHECK IF PIXEL IS IN SECTION OF SPAN WHICH GETS NO FILTERING\n------------------------------------------------------------------------------\nIf both the pair luma at the end of the span (lumaEndN) \nand middle pixel luma (lumaM)\nare on the same side of the middle pair average luma (lumaN),\nthen don't filter.\n \nCases,\n \n(1.) \"L\",\n  \n               lumaM\n                 |\n                 V    XXXXXXXX <- other line averaged\n         XXXXXXX[X]XXXXXXXXXXX <- source pixel line\n        |      .      | \n    --------------------------                    \n       [ ]xxxxxx[x]xx[X]XXXXXX <- pair average\n    --------------------------           \n        ^      ^ ^    ^\n        |      | |    |\n        .      |<---->|<---------- no filter region\n        .      | |    |\n        . center |    |\n        .        |  lumaEndN \n        .        |    .\n        .      lumaN  .\n        .             .\n        |<--- span -->|\n        \n                        \n(2.) \"^\" and \"-\",\n  \n                               <- other line averaged\n          XXXXX[X]XXX          <- source pixel line\n         |     |     | \n    --------------------------                    \n        [ ]xxxx[x]xx[ ]        <- pair average\n    --------------------------           \n         |     |     |\n         |<--->|<--->|<---------- filter both sides\n \n \n(3.) \"v\" and inverse of \"-\",\n  \n    XXXXXX           XXXXXXXXX <- other line averaged\n    XXXXXXXXXXX[X]XXXXXXXXXXXX <- source pixel line\n         |     |     |\n    --------------------------                    \n    XXXX[X]xxxx[x]xx[X]XXXXXXX <- pair average\n    --------------------------           \n         |     |     |\n         |<--->|<--->|<---------- don't filter both!\n \n         \nNote the \"v\" case for FXAA requires no filtering.\nThis is because the inverse of the \"-\" case is the \"v\".\nFiltering \"v\" case turns open spans like this,\n \n    XXXXXXXXX\n    \nInto this (which is not desired),\n \n    x+.   .+x\n    XXXXXXXXX\n \n----------------------------------------------------------------------------*/\n    if(((lumaM - lumaN) < 0.0) == ((lumaEndN - lumaN) < 0.0)) \n        lengthSign = 0.0;\n \n/*----------------------------------------------------------------------------\n                COMPUTE SUB-PIXEL OFFSET AND FILTER SPAN\n------------------------------------------------------------------------------\nFXAA filters using a bilinear texture fetch offset \nfrom the middle pixel M towards the center of the pair (NM below).\nMaximum filtering will be half way between pair.\nReminder, at this point in the code, \nthe {N,M} pair is also reused for all cases: {S,M}, {W,M}, and {E,M}.\n \n    +-------+\n    |       |    0.5 offset\n    |   N   |     |\n    |       |     V\n    +-------+....---\n    |       |\n    |   M...|....---\n    |       |     ^\n    +-------+     |\n    .       .    0.0 offset\n    .   S   .\n    .       .\n    .........\n \nPosition on span is used to compute sub-pixel filter offset using simple ramp,\n \n             posN           posP\n              |\\             |<------- 0.5 pixel offset into pair pixel\n              | \\            |\n              |  \\           |\n    ---.......|...\\..........|<------- 0.25 pixel offset into pair pixel\n     ^        |   ^\\         |\n     |        |   | \\        |\n     V        |   |  \\       |\n    ---.......|===|==========|<------- 0.0 pixel offset (ie M pixel)\n     ^        .   |   ^      .\n     |        .  pos  |      .\n     |        .   .   |      .\n     |        .   . center   .\n     |        .   .          .\n     |        |<->|<---------.-------- dstN\n     |        .   .          .    \n     |        .   |<-------->|<------- dstP    \n     |        .             .\n     |        |<------------>|<------- spanLength    \n     |\n    subPixelOffset\n    \n----------------------------------------------------------------------------*/\n    float spanLength = (dstP + dstN);\n    dstN = directionN ? dstN : dstP;\n    float subPixelOffset = (0.5 + (dstN * (-1.0/spanLength))) * lengthSign;\n    #if FXAA_DEBUG_OFFSET\n        float ox = horzSpan ? 0.0 : subPixelOffset*2.0/rcpFrame.x;\n        float oy = horzSpan ? subPixelOffset*2.0/rcpFrame.y : 0.0;\n        if(ox < 0.0) return FxaaFilterReturn(\n            FxaaLerp3(FxaaToFloat3(lumaO), \n                      FxaaFloat3(1.0, 0.0, 0.0), -ox));\n        if(ox > 0.0) return FxaaFilterReturn(\n            FxaaLerp3(FxaaToFloat3(lumaO), \n                      FxaaFloat3(0.0, 0.0, 1.0),  ox));\n        if(oy < 0.0) return FxaaFilterReturn(\n            FxaaLerp3(FxaaToFloat3(lumaO), \n                      FxaaFloat3(1.0, 0.6, 0.2), -oy));\n        if(oy > 0.0) return FxaaFilterReturn(\n            FxaaLerp3(FxaaToFloat3(lumaO), \n                      FxaaFloat3(0.2, 0.6, 1.0),  oy));\n        return FxaaFilterReturn(FxaaFloat3(lumaO, lumaO, lumaO));\n    #endif\n    float3 rgbF = FxaaTexLod0(tex, FxaaFloat2(\n        pos.x + (horzSpan ? 0.0 : subPixelOffset),\n        pos.y + (horzSpan ? subPixelOffset : 0.0))).xyz;\n    #if FXAA_SUBPIX == 0\n        return FxaaFilterReturn(rgbF); \n    #else        \n        return FxaaFilterReturn(FxaaLerp3(rgbL, rgbF, blendL)); \n    #endif\n}\n\n";
				case "FXAA_311.fx":
					return "//----------------------------------------------------------------------------------\n// File:        FXAA\\media/FXAA.hlsl\n// SDK Version: v1.2 \n// Email:       gameworks@nvidia.com\n// Site:        http://developer.nvidia.com/\n//\n// Copyright (c) 2014, NVIDIA CORPORATION. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//  * Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//  * Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//  * Neither the name of NVIDIA CORPORATION nor the names of its\n//    contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//----------------------------------------------------------------------------------\n/*============================================================================\n\n\nNVIDIA FXAA 3.11 by TIMOTHY LOTTES\n\n------------------------------------------------------------------------------\nINTEGRATION CHECKLIST\n------------------------------------------------------------------------------\n(1.)\nIn the shader source, setup defines for the desired configuration.\nWhen providing multiple shaders (for different presets),\nsimply setup the defines differently in multiple files.\nExample,\n\n#define FXAA_PC 1\n#define FXAA_HLSL_5 1\n#define FXAA_QUALITY__PRESET 12\n\nOr,\n\n#define FXAA_360 1\n\nOr,\n\n#define FXAA_PS3 1\n\nEtc.\n\n(2.)\nThen include this file,\n\n#include \"Fxaa3_11.h\"\n\n(3.)\nThen call the FXAA pixel shader from within your desired shader.\nLook at the FXAA Quality FxaaPixelShader() for docs on inputs.\nAs for FXAA 3.11 all inputs for all shaders are the same\nto enable easy porting between platforms.\n\nreturn FxaaPixelShader(...);\n\n(4.)\nInsure pass prior to FXAA outputs RGBL (see next section).\nOr use,\n\n#define FXAA_GREEN_AS_LUMA 1\n\n(5.)\nSetup engine to provide the following constants\nwhich are used in the FxaaPixelShader() inputs,\n\nFxaaFloat2 fxaaQualityRcpFrame,\nFxaaFloat4 fxaaConsoleRcpFrameOpt,\nFxaaFloat4 fxaaConsoleRcpFrameOpt2,\nFxaaFloat4 fxaaConsole360RcpFrameOpt2,\nFxaaFloat fxaaQualitySubpix,\nFxaaFloat fxaaQualityEdgeThreshold,\nFxaaFloat fxaaQualityEdgeThresholdMin,\nFxaaFloat fxaaConsoleEdgeSharpness,\nFxaaFloat fxaaConsoleEdgeThreshold,\nFxaaFloat fxaaConsoleEdgeThresholdMin,\nFxaaFloat4 fxaaConsole360ConstDir\n\nLook at the FXAA Quality FxaaPixelShader() for docs on inputs.\n\n(6.)\nHave FXAA vertex shader run as a full screen triangle,\nand output \"pos\" and \"fxaaConsolePosPos\"\nsuch that inputs in the pixel shader provide,\n\n// {xy} = center of pixel\nFxaaFloat2 pos,\n\n// {xy__} = upper left of pixel\n// {__zw} = lower right of pixel\nFxaaFloat4 fxaaConsolePosPos,\n\n(7.)\nInsure the texture sampler(s) used by FXAA are set to bilinear filtering.\n\n\n------------------------------------------------------------------------------\nINTEGRATION - RGBL AND COLORSPACE\n------------------------------------------------------------------------------\nFXAA3 requires RGBL as input unless the following is set,\n\n#define FXAA_GREEN_AS_LUMA 1\n\nIn which case the engine uses green in place of luma,\nand requires RGB input is in a non-linear colorspace.\n\nRGB should be LDR (low dynamic range).\nSpecifically do FXAA after tonemapping.\n\nRGB data as returned by a texture fetch can be non-linear,\nor linear when FXAA_GREEN_AS_LUMA is not set.\nNote an \"sRGB format\" texture counts as linear,\nbecause the result of a texture fetch is linear data.\nRegular \"RGBA8\" textures in the sRGB colorspace are non-linear.\n\nIf FXAA_GREEN_AS_LUMA is not set,\nluma must be stored in the alpha channel prior to running FXAA.\nThis luma should be in a perceptual space (could be gamma 2.0).\nExample pass before FXAA where output is gamma 2.0 encoded,\n\ncolor.rgb = ToneMap(color.rgb); // linear color output\ncolor.rgb = sqrt(color.rgb);    // gamma 2.0 color output\nreturn color;\n\nTo use FXAA,\n\ncolor.rgb = ToneMap(color.rgb);  // linear color output\ncolor.rgb = sqrt(color.rgb);     // gamma 2.0 color output\ncolor.a = dot(color.rgb, FxaaFloat3(0.299, 0.587, 0.114)); // compute luma\nreturn color;\n\nAnother example where output is linear encoded,\nsay for instance writing to an sRGB formated render target,\nwhere the render target does the conversion back to sRGB after blending,\n\ncolor.rgb = ToneMap(color.rgb); // linear color output\nreturn color;\n\nTo use FXAA,\n\ncolor.rgb = ToneMap(color.rgb); // linear color output\ncolor.a = sqrt(dot(color.rgb, FxaaFloat3(0.299, 0.587, 0.114))); // compute luma\nreturn color;\n\nGetting luma correct is required for the algorithm to work correctly.\n\n\n------------------------------------------------------------------------------\nBEING LINEARLY CORRECT?\n------------------------------------------------------------------------------\nApplying FXAA to a framebuffer with linear RGB color will look worse.\nThis is very counter intuitive, but happends to be true in this case.\nThe reason is because dithering artifacts will be more visiable\nin a linear colorspace.\n\n\n------------------------------------------------------------------------------\nCOMPLEX INTEGRATION\n------------------------------------------------------------------------------\nQ. What if the engine is blending into RGB before wanting to run FXAA?\n\nA. In the last opaque pass prior to FXAA,\nhave the pass write out luma into alpha.\nThen blend into RGB only.\nFXAA should be able to run ok\nassuming the blending pass did not any add aliasing.\nThis should be the common case for particles and common blending passes.\n\nA. Or use FXAA_GREEN_AS_LUMA.\n\n============================================================================*/\n\n/*============================================================================\n\nINTEGRATION KNOBS\n\n============================================================================*/\n//\n// FXAA_PS3 and FXAA_360 choose the console algorithm (FXAA3 CONSOLE).\n// FXAA_360_OPT is a prototype for the new optimized 360 version.\n//\n// 1 = Use API.\n// 0 = Don't use API.\n//\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_PS3\n#define FXAA_PS3 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_360\n#define FXAA_360 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_360_OPT\n#define FXAA_360_OPT 0\n#endif\n/*==========================================================================*/\n#ifndef FXAA_PC\n//\n// FXAA Quality\n// The high quality PC algorithm.\n//\n#define FXAA_PC 1\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_PC_CONSOLE\n//\n// The console algorithm for PC is included\n// for developers targeting really low spec machines.\n// Likely better to just run FXAA_PC, and use a really low preset.\n//\n#define FXAA_PC_CONSOLE 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_120\n#define FXAA_GLSL_120 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_130\n#define FXAA_GLSL_130 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_3\n#define FXAA_HLSL_3 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_4\n#define FXAA_HLSL_4 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_5\n#define FXAA_HLSL_5 1\n#endif\n/*==========================================================================*/\n#ifndef FXAA_GREEN_AS_LUMA\n//\n// For those using non-linear color,\n// and either not able to get luma in alpha, or not wanting to,\n// this enables FXAA to run using green as a proxy for luma.\n// So with this enabled, no need to pack luma in alpha.\n//\n// This will turn off AA on anything which lacks some amount of green.\n// Pure red and blue or combination of only R and B, will get no AA.\n//\n// Might want to lower the settings for both,\n//    fxaaConsoleEdgeThresholdMin\n//    fxaaQualityEdgeThresholdMin\n// In order to insure AA does not get turned off on colors \n// which contain a minor amount of green.\n//\n// 1 = On.\n// 0 = Off.\n//\n#define FXAA_GREEN_AS_LUMA 1\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_EARLY_EXIT\n//\n// Controls algorithm's early exit path.\n// On PS3 turning this ON adds 2 cycles to the shader.\n// On 360 turning this OFF adds 10ths of a millisecond to the shader.\n// Turning this off on console will result in a more blurry image.\n// So this defaults to on.\n//\n// 1 = On.\n// 0 = Off.\n//\n#define FXAA_EARLY_EXIT 1\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_DISCARD\n//\n// Only valid for PC OpenGL currently.\n// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n//\n// 1 = Use discard on pixels which don't need AA.\n//     For APIs which enable concurrent TEX+ROP from same surface.\n// 0 = Return unchanged color on pixels which don't need AA.\n//\n#define FXAA_DISCARD 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_FAST_PIXEL_OFFSET\n//\n// Used for GLSL 120 only.\n//\n// 1 = GL API supports fast pixel offsets\n// 0 = do not use fast pixel offsets\n//\n#ifdef GL_EXT_gpu_shader4\n#define FXAA_FAST_PIXEL_OFFSET 1\n#endif\n#ifdef GL_NV_gpu_shader5\n#define FXAA_FAST_PIXEL_OFFSET 1\n#endif\n#ifdef GL_ARB_gpu_shader5\n#define FXAA_FAST_PIXEL_OFFSET 1\n#endif\n#ifndef FXAA_FAST_PIXEL_OFFSET\n#define FXAA_FAST_PIXEL_OFFSET 0\n#endif\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GATHER4_ALPHA\n//\n// 1 = API supports gather4 on alpha channel.\n// 0 = API does not support gather4 on alpha channel.\n//\n#if (FXAA_HLSL_5 == 1)\n#define FXAA_GATHER4_ALPHA 1\n#endif\n#ifdef GL_ARB_gpu_shader5\n#define FXAA_GATHER4_ALPHA 1\n#endif\n#ifdef GL_NV_gpu_shader5\n#define FXAA_GATHER4_ALPHA 1\n#endif\n#ifndef FXAA_GATHER4_ALPHA\n#define FXAA_GATHER4_ALPHA 0\n#endif\n#endif\n\n/*============================================================================\nFXAA CONSOLE PS3 - TUNING KNOBS\n============================================================================*/\n#ifndef FXAA_CONSOLE__PS3_EDGE_SHARPNESS\n//\n// Consoles the sharpness of edges on PS3 only.\n// Non-PS3 tuning is done with shader input.\n//\n// Due to the PS3 being ALU bound,\n// there are only two safe values here: 4 and 8.\n// These options use the shaders ability to a free *|/ by 2|4|8.\n//\n// 8.0 is sharper\n// 4.0 is softer\n// 2.0 is really soft (good for vector graphics inputs)\n//\n#if 1\n#define FXAA_CONSOLE__PS3_EDGE_SHARPNESS 8.0\n#endif\n#if 0\n#define FXAA_CONSOLE__PS3_EDGE_SHARPNESS 4.0\n#endif\n#if 0\n#define FXAA_CONSOLE__PS3_EDGE_SHARPNESS 2.0\n#endif\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_CONSOLE__PS3_EDGE_THRESHOLD\n//\n// Only effects PS3.\n// Non-PS3 tuning is done with shader input.\n//\n// The minimum amount of local contrast required to apply algorithm.\n// The console setting has a different mapping than the quality setting.\n//\n// This only applies when FXAA_EARLY_EXIT is 1.\n//\n// Due to the PS3 being ALU bound,\n// there are only two safe values here: 0.25 and 0.125.\n// These options use the shaders ability to a free *|/ by 2|4|8.\n//\n// 0.125 leaves less aliasing, but is softer\n// 0.25 leaves more aliasing, and is sharper\n//\n#if 1\n#define FXAA_CONSOLE__PS3_EDGE_THRESHOLD 0.125\n#else\n#define FXAA_CONSOLE__PS3_EDGE_THRESHOLD 0.25\n#endif\n#endif\n\n/*============================================================================\nFXAA QUALITY - TUNING KNOBS\n------------------------------------------------------------------------------\nNOTE the other tuning knobs are now in the shader function inputs!\n============================================================================*/\n#ifndef FXAA_QUALITY__PRESET\n//\n// Choose the quality preset.\n// This needs to be compiled into the shader as it effects code.\n// Best option to include multiple presets is to \n// in each shader define the preset, then include this file.\n// \n// OPTIONS\n// -----------------------------------------------------------------------\n// 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n// 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n// 39       - no dither, very expensive \n//\n// NOTES\n// -----------------------------------------------------------------------\n// 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n// 13 = about same speed as FXAA 3.9 and better than 12\n// 23 = closest to FXAA 3.9 visually and performance wise\n//  _ = the lowest digit is directly related to performance\n// _  = the highest digit is directly related to style\n// \n#define FXAA_QUALITY__PRESET 12\n#endif\n\n\n/*============================================================================\n\nFXAA QUALITY - PRESETS\n\n============================================================================*/\n\n/*============================================================================\nFXAA QUALITY - MEDIUM DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY__PRESET == 10)\n#define FXAA_QUALITY__PS 3\n#define FXAA_QUALITY__P0 1.5\n#define FXAA_QUALITY__P1 3.0\n#define FXAA_QUALITY__P2 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 11)\n#define FXAA_QUALITY__PS 4\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 3.0\n#define FXAA_QUALITY__P3 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 12)\n#define FXAA_QUALITY__PS 5\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 2.0\n#define FXAA_QUALITY__P3 4.0\n#define FXAA_QUALITY__P4 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 13)\n#define FXAA_QUALITY__PS 6\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 2.0\n#define FXAA_QUALITY__P3 2.0\n#define FXAA_QUALITY__P4 4.0\n#define FXAA_QUALITY__P5 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 14)\n#define FXAA_QUALITY__PS 7\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 2.0\n#define FXAA_QUALITY__P3 2.0\n#define FXAA_QUALITY__P4 2.0\n#define FXAA_QUALITY__P5 4.0\n#define FXAA_QUALITY__P6 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 15)\n#define FXAA_QUALITY__PS 8\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 2.0\n#define FXAA_QUALITY__P3 2.0\n#define FXAA_QUALITY__P4 2.0\n#define FXAA_QUALITY__P5 2.0\n#define FXAA_QUALITY__P6 4.0\n#define FXAA_QUALITY__P7 12.0\n#endif\n\n/*============================================================================\nFXAA QUALITY - LOW DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY__PRESET == 20)\n#define FXAA_QUALITY__PS 3\n#define FXAA_QUALITY__P0 1.5\n#define FXAA_QUALITY__P1 2.0\n#define FXAA_QUALITY__P2 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 21)\n#define FXAA_QUALITY__PS 4\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 2.0\n#define FXAA_QUALITY__P3 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 22)\n#define FXAA_QUALITY__PS 5\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 2.0\n#define FXAA_QUALITY__P3 2.0\n#define FXAA_QUALITY__P4 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 23)\n#define FXAA_QUALITY__PS 6\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 2.0\n#define FXAA_QUALITY__P3 2.0\n#define FXAA_QUALITY__P4 2.0\n#define FXAA_QUALITY__P5 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 24)\n#define FXAA_QUALITY__PS 7\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 2.0\n#define FXAA_QUALITY__P3 2.0\n#define FXAA_QUALITY__P4 2.0\n#define FXAA_QUALITY__P5 3.0\n#define FXAA_QUALITY__P6 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 25)\n#define FXAA_QUALITY__PS 8\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 2.0\n#define FXAA_QUALITY__P3 2.0\n#define FXAA_QUALITY__P4 2.0\n#define FXAA_QUALITY__P5 2.0\n#define FXAA_QUALITY__P6 4.0\n#define FXAA_QUALITY__P7 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 26)\n#define FXAA_QUALITY__PS 9\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 2.0\n#define FXAA_QUALITY__P3 2.0\n#define FXAA_QUALITY__P4 2.0\n#define FXAA_QUALITY__P5 2.0\n#define FXAA_QUALITY__P6 2.0\n#define FXAA_QUALITY__P7 4.0\n#define FXAA_QUALITY__P8 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 27)\n#define FXAA_QUALITY__PS 10\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 2.0\n#define FXAA_QUALITY__P3 2.0\n#define FXAA_QUALITY__P4 2.0\n#define FXAA_QUALITY__P5 2.0\n#define FXAA_QUALITY__P6 2.0\n#define FXAA_QUALITY__P7 2.0\n#define FXAA_QUALITY__P8 4.0\n#define FXAA_QUALITY__P9 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 28)\n#define FXAA_QUALITY__PS 11\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 2.0\n#define FXAA_QUALITY__P3 2.0\n#define FXAA_QUALITY__P4 2.0\n#define FXAA_QUALITY__P5 2.0\n#define FXAA_QUALITY__P6 2.0\n#define FXAA_QUALITY__P7 2.0\n#define FXAA_QUALITY__P8 2.0\n#define FXAA_QUALITY__P9 4.0\n#define FXAA_QUALITY__P10 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PRESET == 29)\n#define FXAA_QUALITY__PS 12\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.5\n#define FXAA_QUALITY__P2 2.0\n#define FXAA_QUALITY__P3 2.0\n#define FXAA_QUALITY__P4 2.0\n#define FXAA_QUALITY__P5 2.0\n#define FXAA_QUALITY__P6 2.0\n#define FXAA_QUALITY__P7 2.0\n#define FXAA_QUALITY__P8 2.0\n#define FXAA_QUALITY__P9 2.0\n#define FXAA_QUALITY__P10 4.0\n#define FXAA_QUALITY__P11 8.0\n#endif\n\n/*============================================================================\nFXAA QUALITY - EXTREME QUALITY\n============================================================================*/\n#if (FXAA_QUALITY__PRESET == 39)\n#define FXAA_QUALITY__PS 12\n#define FXAA_QUALITY__P0 1.0\n#define FXAA_QUALITY__P1 1.0\n#define FXAA_QUALITY__P2 1.0\n#define FXAA_QUALITY__P3 1.0\n#define FXAA_QUALITY__P4 1.0\n#define FXAA_QUALITY__P5 1.5\n#define FXAA_QUALITY__P6 2.0\n#define FXAA_QUALITY__P7 2.0\n#define FXAA_QUALITY__P8 2.0\n#define FXAA_QUALITY__P9 2.0\n#define FXAA_QUALITY__P10 4.0\n#define FXAA_QUALITY__P11 8.0\n#endif\n\n\n\n/*============================================================================\n\nAPI PORTING\n\n============================================================================*/\n#if (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n#define FxaaBool bool\n#define FxaaDiscard discard\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 ivec2\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTex sampler2D\n#else\n#define FxaaBool bool\n#define FxaaDiscard clip(-1)\n#define FxaaFloat float\n#define FxaaFloat2 float2\n#define FxaaFloat3 float3\n#define FxaaFloat4 float4\n#define FxaaHalf half\n#define FxaaHalf2 half2\n#define FxaaHalf3 half3\n#define FxaaHalf4 half4\n#define FxaaSat(x) saturate(x)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_120 == 1)\n// Requires,\n//  #version 120\n// And at least,\n//  #extension GL_EXT_gpu_shader4 : enable\n//  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n#if (FXAA_FAST_PIXEL_OFFSET == 1)\n#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n#else\n#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n#endif\n#if (FXAA_GATHER4_ALPHA == 1)\n// use #extension GL_ARB_gpu_shader5 : enable\n#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n#endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_130 == 1)\n// Requires \"#version 130\" or better\n#define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n#if (FXAA_GATHER4_ALPHA == 1)\n// use #extension GL_ARB_gpu_shader5 : enable\n#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n#endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_3 == 1) || (FXAA_360 == 1) || (FXAA_PS3 == 1)\n#define FxaaInt2 float2\n#define FxaaTex sampler2D\n#define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n#define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_4 == 1)\n#define FxaaInt2 int2\nstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_5 == 1)\n#define FxaaInt2 int2\nstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n#define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n#define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n#define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n#endif\n\n\n/*============================================================================\nGREEN AS LUMA OPTION SUPPORT FUNCTION\n============================================================================*/\n#if (FXAA_GREEN_AS_LUMA == 0)\nFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\nFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif    \n\n\n\n\n/*============================================================================\n\nFXAA3 QUALITY - PC\n\n============================================================================*/\n#if (FXAA_PC == 1)\n/*--------------------------------------------------------------------------*/\nFxaaFloat4 FxaaPixelShader(\n\t//\n\t// Use noperspective interpolation here (turn off perspective interpolation).\n\t// {xy} = center of pixel\n\tFxaaFloat2 pos,\n\t//\n\t// Used only for FXAA Console, and not used on the 360 version.\n\t// Use noperspective interpolation here (turn off perspective interpolation).\n\t// {xy__} = upper left of pixel\n\t// {__zw} = lower right of pixel\n\tFxaaFloat4 fxaaConsolePosPos,\n\t//\n\t// Input color texture.\n\t// {rgb_} = color in linear or perceptual color space\n\t// if (FXAA_GREEN_AS_LUMA == 0)\n\t//     {___a} = luma in perceptual color space (not linear)\n\tFxaaTex tex,\n\t//\n\t// Only used on the optimized 360 version of FXAA Console.\n\t// For everything but 360, just use the same input here as for \"tex\".\n\t// For 360, same texture, just alias with a 2nd sampler.\n\t// This sampler needs to have an exponent bias of -1.\n\tFxaaTex fxaaConsole360TexExpBiasNegOne,\n\t//\n\t// Only used on the optimized 360 version of FXAA Console.\n\t// For everything but 360, just use the same input here as for \"tex\".\n\t// For 360, same texture, just alias with a 3nd sampler.\n\t// This sampler needs to have an exponent bias of -2.\n\tFxaaTex fxaaConsole360TexExpBiasNegTwo,\n\t//\n\t// Only used on FXAA Quality.\n\t// This must be from a constant/uniform.\n\t// {x_} = 1.0/screenWidthInPixels\n\t// {_y} = 1.0/screenHeightInPixels\n\tFxaaFloat2 fxaaQualityRcpFrame,\n\t//\n\t// Only used on FXAA Console.\n\t// This must be from a constant/uniform.\n\t// This effects sub-pixel AA quality and inversely sharpness.\n\t//   Where N ranges between,\n\t//     N = 0.50 (default)\n\t//     N = 0.33 (sharper)\n\t// {x___} = -N/screenWidthInPixels  \n\t// {_y__} = -N/screenHeightInPixels\n\t// {__z_} =  N/screenWidthInPixels  \n\t// {___w} =  N/screenHeightInPixels \n\tFxaaFloat4 fxaaConsoleRcpFrameOpt,\n\t//\n\t// Only used on FXAA Console.\n\t// Not used on 360, but used on PS3 and PC.\n\t// This must be from a constant/uniform.\n\t// {x___} = -2.0/screenWidthInPixels  \n\t// {_y__} = -2.0/screenHeightInPixels\n\t// {__z_} =  2.0/screenWidthInPixels  \n\t// {___w} =  2.0/screenHeightInPixels \n\tFxaaFloat4 fxaaConsoleRcpFrameOpt2,\n\t//\n\t// Only used on FXAA Console.\n\t// Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n\t// This must be from a constant/uniform.\n\t// {x___} =  8.0/screenWidthInPixels  \n\t// {_y__} =  8.0/screenHeightInPixels\n\t// {__z_} = -4.0/screenWidthInPixels  \n\t// {___w} = -4.0/screenHeightInPixels \n\tFxaaFloat4 fxaaConsole360RcpFrameOpt2,\n\t//\n\t// Only used on FXAA Quality.\n\t// This used to be the FXAA_QUALITY__SUBPIX define.\n\t// It is here now to allow easier tuning.\n\t// Choose the amount of sub-pixel aliasing removal.\n\t// This can effect sharpness.\n\t//   1.00 - upper limit (softer)\n\t//   0.75 - default amount of filtering\n\t//   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n\t//   0.25 - almost off\n\t//   0.00 - completely off\n\tFxaaFloat fxaaQualitySubpix,\n\t//\n\t// Only used on FXAA Quality.\n\t// This used to be the FXAA_QUALITY__EDGE_THRESHOLD define.\n\t// It is here now to allow easier tuning.\n\t// The minimum amount of local contrast required to apply algorithm.\n\t//   0.333 - too little (faster)\n\t//   0.250 - low quality\n\t//   0.166 - default\n\t//   0.125 - high quality \n\t//   0.063 - overkill (slower)\n\tFxaaFloat fxaaQualityEdgeThreshold,\n\t//\n\t// Only used on FXAA Quality.\n\t// This used to be the FXAA_QUALITY__EDGE_THRESHOLD_MIN define.\n\t// It is here now to allow easier tuning.\n\t// Trims the algorithm from processing darks.\n\t//   0.0833 - upper limit (default, the start of visible unfiltered edges)\n\t//   0.0625 - high quality (faster)\n\t//   0.0312 - visible limit (slower)\n\t// Special notes when using FXAA_GREEN_AS_LUMA,\n\t//   Likely want to set this to zero.\n\t//   As colors that are mostly not-green\n\t//   will appear very dark in the green channel!\n\t//   Tune by looking at mostly non-green content,\n\t//   then start at zero and increase until aliasing is a problem.\n\tFxaaFloat fxaaQualityEdgeThresholdMin,\n\t// \n\t// Only used on FXAA Console.\n\t// This used to be the FXAA_CONSOLE__EDGE_SHARPNESS define.\n\t// It is here now to allow easier tuning.\n\t// This does not effect PS3, as this needs to be compiled in.\n\t//   Use FXAA_CONSOLE__PS3_EDGE_SHARPNESS for PS3.\n\t//   Due to the PS3 being ALU bound,\n\t//   there are only three safe values here: 2 and 4 and 8.\n\t//   These options use the shaders ability to a free *|/ by 2|4|8.\n\t// For all other platforms can be a non-power of two.\n\t//   8.0 is sharper (default!!!)\n\t//   4.0 is softer\n\t//   2.0 is really soft (good only for vector graphics inputs)\n\tFxaaFloat fxaaConsoleEdgeSharpness,\n\t//\n\t// Only used on FXAA Console.\n\t// This used to be the FXAA_CONSOLE__EDGE_THRESHOLD define.\n\t// It is here now to allow easier tuning.\n\t// This does not effect PS3, as this needs to be compiled in.\n\t//   Use FXAA_CONSOLE__PS3_EDGE_THRESHOLD for PS3.\n\t//   Due to the PS3 being ALU bound,\n\t//   there are only two safe values here: 1/4 and 1/8.\n\t//   These options use the shaders ability to a free *|/ by 2|4|8.\n\t// The console setting has a different mapping than the quality setting.\n\t// Other platforms can use other values.\n\t//   0.125 leaves less aliasing, but is softer (default!!!)\n\t//   0.25 leaves more aliasing, and is sharper\n\tFxaaFloat fxaaConsoleEdgeThreshold,\n\t//\n\t// Only used on FXAA Console.\n\t// This used to be the FXAA_CONSOLE__EDGE_THRESHOLD_MIN define.\n\t// It is here now to allow easier tuning.\n\t// Trims the algorithm from processing darks.\n\t// The console setting has a different mapping than the quality setting.\n\t// This only applies when FXAA_EARLY_EXIT is 1.\n\t// This does not apply to PS3, \n\t// PS3 was simplified to avoid more shader instructions.\n\t//   0.06 - faster but more aliasing in darks\n\t//   0.05 - default\n\t//   0.04 - slower and less aliasing in darks\n\t// Special notes when using FXAA_GREEN_AS_LUMA,\n\t//   Likely want to set this to zero.\n\t//   As colors that are mostly not-green\n\t//   will appear very dark in the green channel!\n\t//   Tune by looking at mostly non-green content,\n\t//   then start at zero and increase until aliasing is a problem.\n\tFxaaFloat fxaaConsoleEdgeThresholdMin,\n\t//    \n\t// Extra constants for 360 FXAA Console only.\n\t// Use zeros or anything else for other platforms.\n\t// These must be in physical constant registers and NOT immedates.\n\t// Immedates will result in compiler un-optimizing.\n\t// {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n\tFxaaFloat4 fxaaConsole360ConstDir\n\t) {\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat2 posM;\n\tposM.x = pos.x;\n\tposM.y = pos.y;\n#if (FXAA_GATHER4_ALPHA == 1)\n#if (FXAA_DISCARD == 0)\n\tFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n#if (FXAA_GREEN_AS_LUMA == 0)\n#define lumaM rgbyM.w\n#else\n#define lumaM rgbyM.y\n#endif\n#endif\n#if (FXAA_GREEN_AS_LUMA == 0)\n\tFxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n\tFxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n#else\n\tFxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n\tFxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n#endif\n#if (FXAA_DISCARD == 1)\n#define lumaM luma4A.w\n#endif\n#define lumaE luma4A.z\n#define lumaS luma4A.x\n#define lumaSE luma4A.y\n#define lumaNW luma4B.w\n#define lumaN luma4B.z\n#define lumaW luma4B.x\n#else\n\tFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n#if (FXAA_GREEN_AS_LUMA == 0)\n#define lumaM rgbyM.w\n#else\n#define lumaM rgbyM.y\n#endif\n\tFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, 1), fxaaQualityRcpFrame.xy));\n\tFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 0), fxaaQualityRcpFrame.xy));\n\tFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, -1), fxaaQualityRcpFrame.xy));\n\tFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n#endif\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat maxSM = max(lumaS, lumaM);\n\tFxaaFloat minSM = min(lumaS, lumaM);\n\tFxaaFloat maxESM = max(lumaE, maxSM);\n\tFxaaFloat minESM = min(lumaE, minSM);\n\tFxaaFloat maxWN = max(lumaN, lumaW);\n\tFxaaFloat minWN = min(lumaN, lumaW);\n\tFxaaFloat rangeMax = max(maxWN, maxESM);\n\tFxaaFloat rangeMin = min(minWN, minESM);\n\tFxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n\tFxaaFloat range = rangeMax - rangeMin;\n\tFxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n\tFxaaBool earlyExit = range < rangeMaxClamped;\n\t/*--------------------------------------------------------------------------*/\n\tif (earlyExit)\n#if (FXAA_DISCARD == 1)\n\t\tFxaaDiscard;\n#else\n\t\treturn rgbyM;\n#endif\n\t/*--------------------------------------------------------------------------*/\n#if (FXAA_GATHER4_ALPHA == 0)\n\tFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, -1), fxaaQualityRcpFrame.xy));\n\tFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 1), fxaaQualityRcpFrame.xy));\n\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n#else\n\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n#endif\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat lumaNS = lumaN + lumaS;\n\tFxaaFloat lumaWE = lumaW + lumaE;\n\tFxaaFloat subpixRcpRange = 1.0 / range;\n\tFxaaFloat subpixNSWE = lumaNS + lumaWE;\n\tFxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n\tFxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat lumaNESE = lumaNE + lumaSE;\n\tFxaaFloat lumaNWNE = lumaNW + lumaNE;\n\tFxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n\tFxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat lumaNWSW = lumaNW + lumaSW;\n\tFxaaFloat lumaSWSE = lumaSW + lumaSE;\n\tFxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n\tFxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n\tFxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n\tFxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n\tFxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n\tFxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n\tFxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n\tFxaaBool horzSpan = edgeHorz >= edgeVert;\n\tFxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n\t/*--------------------------------------------------------------------------*/\n\tif (!horzSpan) lumaN = lumaW;\n\tif (!horzSpan) lumaS = lumaE;\n\tif (horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n\tFxaaFloat subpixB = (subpixA * (1.0 / 12.0)) - lumaM;\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat gradientN = lumaN - lumaM;\n\tFxaaFloat gradientS = lumaS - lumaM;\n\tFxaaFloat lumaNN = lumaN + lumaM;\n\tFxaaFloat lumaSS = lumaS + lumaM;\n\tFxaaBool pairN = abs(gradientN) >= abs(gradientS);\n\tFxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n\tif (pairN) lengthSign = -lengthSign;\n\tFxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat2 posB;\n\tposB.x = posM.x;\n\tposB.y = posM.y;\n\tFxaaFloat2 offNP;\n\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\toffNP.y = (horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\tif (!horzSpan) posB.x += lengthSign * 0.5;\n\tif (horzSpan) posB.y += lengthSign * 0.5;\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat2 posN;\n\tposN.x = posB.x - offNP.x * FXAA_QUALITY__P0;\n\tposN.y = posB.y - offNP.y * FXAA_QUALITY__P0;\n\tFxaaFloat2 posP;\n\tposP.x = posB.x + offNP.x * FXAA_QUALITY__P0;\n\tposP.y = posB.y + offNP.y * FXAA_QUALITY__P0;\n\tFxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n\tFxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n\tFxaaFloat subpixE = subpixC * subpixC;\n\tFxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n\t/*--------------------------------------------------------------------------*/\n\tif (!pairN) lumaNN = lumaSS;\n\tFxaaFloat gradientScaled = gradient * 1.0 / 4.0;\n\tFxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n\tFxaaFloat subpixF = subpixD * subpixE;\n\tFxaaBool lumaMLTZero = lumaMM < 0.0;\n\t/*--------------------------------------------------------------------------*/\n\tlumaEndN -= lumaNN * 0.5;\n\tlumaEndP -= lumaNN * 0.5;\n\tFxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n\tFxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n\tif (!doneN) posN.x -= offNP.x * FXAA_QUALITY__P1;\n\tif (!doneN) posN.y -= offNP.y * FXAA_QUALITY__P1;\n\tFxaaBool doneNP = (!doneN) || (!doneP);\n\tif (!doneP) posP.x += offNP.x * FXAA_QUALITY__P1;\n\tif (!doneP) posP.y += offNP.y * FXAA_QUALITY__P1;\n\t/*--------------------------------------------------------------------------*/\n\tif (doneNP) {\n\t\tif (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\tif (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\tif (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\tif (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\tif (!doneN) posN.x -= offNP.x * FXAA_QUALITY__P2;\n\t\tif (!doneN) posN.y -= offNP.y * FXAA_QUALITY__P2;\n\t\tdoneNP = (!doneN) || (!doneP);\n\t\tif (!doneP) posP.x += offNP.x * FXAA_QUALITY__P2;\n\t\tif (!doneP) posP.y += offNP.y * FXAA_QUALITY__P2;\n\t\t/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PS > 3)\n\t\tif (doneNP) {\n\t\t\tif (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\tif (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\tif (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\tif (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\tif (!doneN) posN.x -= offNP.x * FXAA_QUALITY__P3;\n\t\t\tif (!doneN) posN.y -= offNP.y * FXAA_QUALITY__P3;\n\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\tif (!doneP) posP.x += offNP.x * FXAA_QUALITY__P3;\n\t\t\tif (!doneP) posP.y += offNP.y * FXAA_QUALITY__P3;\n\t\t\t/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PS > 4)\n\t\t\tif (doneNP) {\n\t\t\t\tif (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\tif (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\tif (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\tif (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\tif (!doneN) posN.x -= offNP.x * FXAA_QUALITY__P4;\n\t\t\t\tif (!doneN) posN.y -= offNP.y * FXAA_QUALITY__P4;\n\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\tif (!doneP) posP.x += offNP.x * FXAA_QUALITY__P4;\n\t\t\t\tif (!doneP) posP.y += offNP.y * FXAA_QUALITY__P4;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PS > 5)\n\t\t\t\tif (doneNP) {\n\t\t\t\t\tif (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\tif (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\tif (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\tif (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\tif (!doneN) posN.x -= offNP.x * FXAA_QUALITY__P5;\n\t\t\t\t\tif (!doneN) posN.y -= offNP.y * FXAA_QUALITY__P5;\n\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\tif (!doneP) posP.x += offNP.x * FXAA_QUALITY__P5;\n\t\t\t\t\tif (!doneP) posP.y += offNP.y * FXAA_QUALITY__P5;\n\t\t\t\t\t/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PS > 6)\n\t\t\t\t\tif (doneNP) {\n\t\t\t\t\t\tif (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\tif (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\tif (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\tif (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\tif (!doneN) posN.x -= offNP.x * FXAA_QUALITY__P6;\n\t\t\t\t\t\tif (!doneN) posN.y -= offNP.y * FXAA_QUALITY__P6;\n\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\tif (!doneP) posP.x += offNP.x * FXAA_QUALITY__P6;\n\t\t\t\t\t\tif (!doneP) posP.y += offNP.y * FXAA_QUALITY__P6;\n\t\t\t\t\t\t/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PS > 7)\n\t\t\t\t\t\tif (doneNP) {\n\t\t\t\t\t\t\tif (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\tif (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\tif (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\tif (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\tif (!doneN) posN.x -= offNP.x * FXAA_QUALITY__P7;\n\t\t\t\t\t\t\tif (!doneN) posN.y -= offNP.y * FXAA_QUALITY__P7;\n\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\tif (!doneP) posP.x += offNP.x * FXAA_QUALITY__P7;\n\t\t\t\t\t\t\tif (!doneP) posP.y += offNP.y * FXAA_QUALITY__P7;\n\t\t\t\t\t\t\t/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PS > 8)\n\t\t\t\t\t\t\tif (doneNP) {\n\t\t\t\t\t\t\t\tif (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\tif (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\tif (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tif (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\tif (!doneN) posN.x -= offNP.x * FXAA_QUALITY__P8;\n\t\t\t\t\t\t\t\tif (!doneN) posN.y -= offNP.y * FXAA_QUALITY__P8;\n\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\tif (!doneP) posP.x += offNP.x * FXAA_QUALITY__P8;\n\t\t\t\t\t\t\t\tif (!doneP) posP.y += offNP.y * FXAA_QUALITY__P8;\n\t\t\t\t\t\t\t\t/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PS > 9)\n\t\t\t\t\t\t\t\tif (doneNP) {\n\t\t\t\t\t\t\t\t\tif (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\tif (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\tif (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\tif (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\tif (!doneN) posN.x -= offNP.x * FXAA_QUALITY__P9;\n\t\t\t\t\t\t\t\t\tif (!doneN) posN.y -= offNP.y * FXAA_QUALITY__P9;\n\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\tif (!doneP) posP.x += offNP.x * FXAA_QUALITY__P9;\n\t\t\t\t\t\t\t\t\tif (!doneP) posP.y += offNP.y * FXAA_QUALITY__P9;\n\t\t\t\t\t\t\t\t\t/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PS > 10)\n\t\t\t\t\t\t\t\t\tif (doneNP) {\n\t\t\t\t\t\t\t\t\t\tif (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\tif (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\tif (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tif (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tif (!doneN) posN.x -= offNP.x * FXAA_QUALITY__P10;\n\t\t\t\t\t\t\t\t\t\tif (!doneN) posN.y -= offNP.y * FXAA_QUALITY__P10;\n\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\tif (!doneP) posP.x += offNP.x * FXAA_QUALITY__P10;\n\t\t\t\t\t\t\t\t\t\tif (!doneP) posP.y += offNP.y * FXAA_QUALITY__P10;\n\t\t\t\t\t\t\t\t\t\t/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PS > 11)\n\t\t\t\t\t\t\t\t\t\tif (doneNP) {\n\t\t\t\t\t\t\t\t\t\t\tif (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\tif (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\tif (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\tif (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\tif (!doneN) posN.x -= offNP.x * FXAA_QUALITY__P11;\n\t\t\t\t\t\t\t\t\t\t\tif (!doneN) posN.y -= offNP.y * FXAA_QUALITY__P11;\n\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\tif (!doneP) posP.x += offNP.x * FXAA_QUALITY__P11;\n\t\t\t\t\t\t\t\t\t\t\tif (!doneP) posP.y += offNP.y * FXAA_QUALITY__P11;\n\t\t\t\t\t\t\t\t\t\t\t/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY__PS > 12)\n\t\t\t\t\t\t\t\t\t\t\tif (doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tif (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tif (!doneN) posN.x -= offNP.x * FXAA_QUALITY__P12;\n\t\t\t\t\t\t\t\t\t\t\t\tif (!doneN) posN.y -= offNP.y * FXAA_QUALITY__P12;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\tif (!doneP) posP.x += offNP.x * FXAA_QUALITY__P12;\n\t\t\t\t\t\t\t\t\t\t\t\tif (!doneP) posP.y += offNP.y * FXAA_QUALITY__P12;\n\t\t\t\t\t\t\t\t\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t\t\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t}\n#endif\n\t\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t}\n#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t}\n#endif\n\t\t\t/*--------------------------------------------------------------------------*/\n\t\t}\n#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t}\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat dstN = posM.x - posN.x;\n\tFxaaFloat dstP = posP.x - posM.x;\n\tif (!horzSpan) dstN = posM.y - posN.y;\n\tif (!horzSpan) dstP = posP.y - posM.y;\n\t/*--------------------------------------------------------------------------*/\n\tFxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n\tFxaaFloat spanLength = (dstP + dstN);\n\tFxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n\tFxaaFloat spanLengthRcp = 1.0 / spanLength;\n\t/*--------------------------------------------------------------------------*/\n\tFxaaBool directionN = dstN < dstP;\n\tFxaaFloat dst = min(dstN, dstP);\n\tFxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n\tFxaaFloat subpixG = subpixF * subpixF;\n\tFxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n\tFxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n\tFxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n\tif (!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n\tif (horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n#if (FXAA_DISCARD == 1)\n\treturn FxaaTexTop(tex, posM);\n#else\n\treturn FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n#endif\n}\n/*==========================================================================*/\n#endif\n\n\n\n\n/*============================================================================\n\nFXAA3 CONSOLE - PC VERSION\n\n------------------------------------------------------------------------------\nInstead of using this on PC, I'd suggest just using FXAA Quality with\n#define FXAA_QUALITY__PRESET 10\nOr\n#define FXAA_QUALITY__PRESET 20\nEither are higher qualilty and almost as fast as this on modern PC GPUs.\n============================================================================*/\n#if (FXAA_PC_CONSOLE == 1)\n/*--------------------------------------------------------------------------*/\nFxaaFloat4 FxaaPixelShader(\n\t// See FXAA Quality FxaaPixelShader() source for docs on Inputs!\n\tFxaaFloat2 pos,\n\tFxaaFloat4 fxaaConsolePosPos,\n\tFxaaTex tex,\n\tFxaaTex fxaaConsole360TexExpBiasNegOne,\n\tFxaaTex fxaaConsole360TexExpBiasNegTwo,\n\tFxaaFloat2 fxaaQualityRcpFrame,\n\tFxaaFloat4 fxaaConsoleRcpFrameOpt,\n\tFxaaFloat4 fxaaConsoleRcpFrameOpt2,\n\tFxaaFloat4 fxaaConsole360RcpFrameOpt2,\n\tFxaaFloat fxaaQualitySubpix,\n\tFxaaFloat fxaaQualityEdgeThreshold,\n\tFxaaFloat fxaaQualityEdgeThresholdMin,\n\tFxaaFloat fxaaConsoleEdgeSharpness,\n\tFxaaFloat fxaaConsoleEdgeThreshold,\n\tFxaaFloat fxaaConsoleEdgeThresholdMin,\n\tFxaaFloat4 fxaaConsole360ConstDir\n\t) {\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat lumaNw = FxaaLuma(FxaaTexTop(tex, fxaaConsolePosPos.xy));\n\tFxaaFloat lumaSw = FxaaLuma(FxaaTexTop(tex, fxaaConsolePosPos.xw));\n\tFxaaFloat lumaNe = FxaaLuma(FxaaTexTop(tex, fxaaConsolePosPos.zy));\n\tFxaaFloat lumaSe = FxaaLuma(FxaaTexTop(tex, fxaaConsolePosPos.zw));\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat4 rgbyM = FxaaTexTop(tex, pos.xy);\n#if (FXAA_GREEN_AS_LUMA == 0)\n\tFxaaFloat lumaM = rgbyM.w;\n#else\n\tFxaaFloat lumaM = rgbyM.y;\n#endif\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat lumaMaxNwSw = max(lumaNw, lumaSw);\n\tlumaNe += 1.0 / 384.0;\n\tFxaaFloat lumaMinNwSw = min(lumaNw, lumaSw);\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat lumaMaxNeSe = max(lumaNe, lumaSe);\n\tFxaaFloat lumaMinNeSe = min(lumaNe, lumaSe);\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat lumaMax = max(lumaMaxNeSe, lumaMaxNwSw);\n\tFxaaFloat lumaMin = min(lumaMinNeSe, lumaMinNwSw);\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat lumaMaxScaled = lumaMax * fxaaConsoleEdgeThreshold;\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat lumaMinM = min(lumaMin, lumaM);\n\tFxaaFloat lumaMaxScaledClamped = max(fxaaConsoleEdgeThresholdMin, lumaMaxScaled);\n\tFxaaFloat lumaMaxM = max(lumaMax, lumaM);\n\tFxaaFloat dirSwMinusNe = lumaSw - lumaNe;\n\tFxaaFloat lumaMaxSubMinM = lumaMaxM - lumaMinM;\n\tFxaaFloat dirSeMinusNw = lumaSe - lumaNw;\n\tif (lumaMaxSubMinM < lumaMaxScaledClamped) return rgbyM;\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat2 dir;\n\tdir.x = dirSwMinusNe + dirSeMinusNw;\n\tdir.y = dirSwMinusNe - dirSeMinusNw;\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat2 dir1 = normalize(dir.xy);\n\tFxaaFloat4 rgbyN1 = FxaaTexTop(tex, pos.xy - dir1 * fxaaConsoleRcpFrameOpt.zw);\n\tFxaaFloat4 rgbyP1 = FxaaTexTop(tex, pos.xy + dir1 * fxaaConsoleRcpFrameOpt.zw);\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat dirAbsMinTimesC = min(abs(dir1.x), abs(dir1.y)) * fxaaConsoleEdgeSharpness;\n\tFxaaFloat2 dir2 = clamp(dir1.xy / dirAbsMinTimesC, -2.0, 2.0);\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat4 rgbyN2 = FxaaTexTop(tex, pos.xy - dir2 * fxaaConsoleRcpFrameOpt2.zw);\n\tFxaaFloat4 rgbyP2 = FxaaTexTop(tex, pos.xy + dir2 * fxaaConsoleRcpFrameOpt2.zw);\n\t/*--------------------------------------------------------------------------*/\n\tFxaaFloat4 rgbyA = rgbyN1 + rgbyP1;\n\tFxaaFloat4 rgbyB = ((rgbyN2 + rgbyP2) * 0.25) + (rgbyA * 0.25);\n\t/*--------------------------------------------------------------------------*/\n#if (FXAA_GREEN_AS_LUMA == 0)\n\tFxaaBool twoTap = (rgbyB.w < lumaMin) || (rgbyB.w > lumaMax);\n#else\n\tFxaaBool twoTap = (rgbyB.y < lumaMin) || (rgbyB.y > lumaMax);\n#endif\n\tif (twoTap) rgbyB.xyz = rgbyA.xyz * 0.5;\n\treturn rgbyB;\n}\n/*==========================================================================*/\n#endif\n\n\n\n/*============================================================================\n\nFXAA3 CONSOLE - 360 PIXEL SHADER\n\n------------------------------------------------------------------------------\nThis optimized version thanks to suggestions from Andy Luedke.\nShould be fully tex bound in all cases.\nAs of the FXAA 3.11 release, I have still not tested this code,\nhowever I fixed a bug which was in both FXAA 3.9 and FXAA 3.10.\nAnd note this is replacing the old unoptimized version.\nIf it does not work, please let me know so I can fix it.\n============================================================================*/\n#if (FXAA_360 == 1)\n/*--------------------------------------------------------------------------*/\n[reduceTempRegUsage(4)]\nfloat4 FxaaPixelShader(\n\t// See FXAA Quality FxaaPixelShader() source for docs on Inputs!\n\tFxaaFloat2 pos,\n\tFxaaFloat4 fxaaConsolePosPos,\n\tFxaaTex tex,\n\tFxaaTex fxaaConsole360TexExpBiasNegOne,\n\tFxaaTex fxaaConsole360TexExpBiasNegTwo,\n\tFxaaFloat2 fxaaQualityRcpFrame,\n\tFxaaFloat4 fxaaConsoleRcpFrameOpt,\n\tFxaaFloat4 fxaaConsoleRcpFrameOpt2,\n\tFxaaFloat4 fxaaConsole360RcpFrameOpt2,\n\tFxaaFloat fxaaQualitySubpix,\n\tFxaaFloat fxaaQualityEdgeThreshold,\n\tFxaaFloat fxaaQualityEdgeThresholdMin,\n\tFxaaFloat fxaaConsoleEdgeSharpness,\n\tFxaaFloat fxaaConsoleEdgeThreshold,\n\tFxaaFloat fxaaConsoleEdgeThresholdMin,\n\tFxaaFloat4 fxaaConsole360ConstDir\n\t) {\n\t/*--------------------------------------------------------------------------*/\n\tfloat4 lumaNwNeSwSe;\n#if (FXAA_GREEN_AS_LUMA == 0)\n\tasm {\n\t\ttfetch2D lumaNwNeSwSe.w___, tex, pos.xy, OffsetX = -0.5, OffsetY = -0.5, UseComputedLOD = false\n\t\t\ttfetch2D lumaNwNeSwSe._w__, tex, pos.xy, OffsetX = 0.5, OffsetY = -0.5, UseComputedLOD = false\n\t\t\ttfetch2D lumaNwNeSwSe.__w_, tex, pos.xy, OffsetX = -0.5, OffsetY = 0.5, UseComputedLOD = false\n\t\t\ttfetch2D lumaNwNeSwSe.___w, tex, pos.xy, OffsetX = 0.5, OffsetY = 0.5, UseComputedLOD = false\n\t};\n#else\n\tasm {\n\t\ttfetch2D lumaNwNeSwSe.y___, tex, pos.xy, OffsetX = -0.5, OffsetY = -0.5, UseComputedLOD = false\n\t\t\ttfetch2D lumaNwNeSwSe._y__, tex, pos.xy, OffsetX = 0.5, OffsetY = -0.5, UseComputedLOD = false\n\t\t\ttfetch2D lumaNwNeSwSe.__y_, tex, pos.xy, OffsetX = -0.5, OffsetY = 0.5, UseComputedLOD = false\n\t\t\ttfetch2D lumaNwNeSwSe.___y, tex, pos.xy, OffsetX = 0.5, OffsetY = 0.5, UseComputedLOD = false\n\t};\n#endif\n\t/*--------------------------------------------------------------------------*/\n\tlumaNwNeSwSe.y += 1.0 / 384.0;\n\tfloat2 lumaMinTemp = min(lumaNwNeSwSe.xy, lumaNwNeSwSe.zw);\n\tfloat2 lumaMaxTemp = max(lumaNwNeSwSe.xy, lumaNwNeSwSe.zw);\n\tfloat lumaMin = min(lumaMinTemp.x, lumaMinTemp.y);\n\tfloat lumaMax = max(lumaMaxTemp.x, lumaMaxTemp.y);\n\t/*--------------------------------------------------------------------------*/\n\tfloat4 rgbyM = tex2Dlod(tex, float4(pos.xy, 0.0, 0.0));\n#if (FXAA_GREEN_AS_LUMA == 0)\n\tfloat lumaMinM = min(lumaMin, rgbyM.w);\n\tfloat lumaMaxM = max(lumaMax, rgbyM.w);\n#else\n\tfloat lumaMinM = min(lumaMin, rgbyM.y);\n\tfloat lumaMaxM = max(lumaMax, rgbyM.y);\n#endif        \n\tif ((lumaMaxM - lumaMinM) < max(fxaaConsoleEdgeThresholdMin, lumaMax * fxaaConsoleEdgeThreshold)) return rgbyM;\n\t/*--------------------------------------------------------------------------*/\n\tfloat2 dir;\n\tdir.x = dot(lumaNwNeSwSe, fxaaConsole360ConstDir.yyxx);\n\tdir.y = dot(lumaNwNeSwSe, fxaaConsole360ConstDir.xyxy);\n\tdir = normalize(dir);\n\t/*--------------------------------------------------------------------------*/\n\tfloat4 dir1 = dir.xyxy * fxaaConsoleRcpFrameOpt.xyzw;\n\t/*--------------------------------------------------------------------------*/\n\tfloat4 dir2;\n\tfloat dirAbsMinTimesC = min(abs(dir.x), abs(dir.y)) * fxaaConsoleEdgeSharpness;\n\tdir2 = saturate(fxaaConsole360ConstDir.zzww * dir.xyxy / dirAbsMinTimesC + 0.5);\n\tdir2 = dir2 * fxaaConsole360RcpFrameOpt2.xyxy + fxaaConsole360RcpFrameOpt2.zwzw;\n\t/*--------------------------------------------------------------------------*/\n\tfloat4 rgbyN1 = tex2Dlod(fxaaConsole360TexExpBiasNegOne, float4(pos.xy + dir1.xy, 0.0, 0.0));\n\tfloat4 rgbyP1 = tex2Dlod(fxaaConsole360TexExpBiasNegOne, float4(pos.xy + dir1.zw, 0.0, 0.0));\n\tfloat4 rgbyN2 = tex2Dlod(fxaaConsole360TexExpBiasNegTwo, float4(pos.xy + dir2.xy, 0.0, 0.0));\n\tfloat4 rgbyP2 = tex2Dlod(fxaaConsole360TexExpBiasNegTwo, float4(pos.xy + dir2.zw, 0.0, 0.0));\n\t/*--------------------------------------------------------------------------*/\n\tfloat4 rgbyA = rgbyN1 + rgbyP1;\n\tfloat4 rgbyB = rgbyN2 + rgbyP2 + rgbyA * 0.5;\n\t/*--------------------------------------------------------------------------*/\n\tfloat4 rgbyR = ((FxaaLuma(rgbyB) - lumaMax) > 0.0) ? rgbyA : rgbyB;\n\trgbyR = ((FxaaLuma(rgbyB) - lumaMin) > 0.0) ? rgbyR : rgbyA;\n\treturn rgbyR;\n}\n/*==========================================================================*/\n#endif\n\n\n\n/*============================================================================\n\nFXAA3 CONSOLE - OPTIMIZED PS3 PIXEL SHADER (NO EARLY EXIT)\n\n==============================================================================\nThe code below does not exactly match the assembly.\nI have a feeling that 12 cycles is possible, but was not able to get there.\nMight have to increase register count to get full performance.\nNote this shader does not use perspective interpolation.\n\nUse the following cgc options,\n\n--fenable-bx2 --fastmath --fastprecision --nofloatbindings\n\n------------------------------------------------------------------------------\nNVSHADERPERF OUTPUT\n------------------------------------------------------------------------------\nFor reference and to aid in debug, output of NVShaderPerf should match this,\n\nShader to schedule:\n0: texpkb h0.w(TRUE), v5.zyxx, #0\n2: addh h2.z(TRUE), h0.w, constant(0.001953, 0.000000, 0.000000, 0.000000).x\n4: texpkb h0.w(TRUE), v5.xwxx, #0\n6: addh h0.z(TRUE), -h2, h0.w\n7: texpkb h1.w(TRUE), v5, #0\n9: addh h0.x(TRUE), h0.z, -h1.w\n10: addh h3.w(TRUE), h0.z, h1\n11: texpkb h2.w(TRUE), v5.zwzz, #0\n13: addh h0.z(TRUE), h3.w, -h2.w\n14: addh h0.x(TRUE), h2.w, h0\n15: nrmh h1.xz(TRUE), h0_n\n16: minh_m8 h0.x(TRUE), |h1|, |h1.z|\n17: maxh h4.w(TRUE), h0, h1\n18: divx h2.xy(TRUE), h1_n.xzzw, h0_n\n19: movr r1.zw(TRUE), v4.xxxy\n20: madr r2.xz(TRUE), -h1, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).zzww, r1.zzww\n22: minh h5.w(TRUE), h0, h1\n23: texpkb h0(TRUE), r2.xzxx, #0\n25: madr r0.zw(TRUE), h1.xzxz, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w), r1\n27: maxh h4.x(TRUE), h2.z, h2.w\n28: texpkb h1(TRUE), r0.zwzz, #0\n30: addh_d2 h1(TRUE), h0, h1\n31: madr r0.xy(TRUE), -h2, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).xyxx, r1.zwzz\n33: texpkb h0(TRUE), r0, #0\n35: minh h4.z(TRUE), h2, h2.w\n36: fenct TRUE\n37: madr r1.xy(TRUE), h2, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).xyxx, r1.zwzz\n39: texpkb h2(TRUE), r1, #0\n41: addh_d2 h0(TRUE), h0, h2\n42: maxh h2.w(TRUE), h4, h4.x\n43: minh h2.x(TRUE), h5.w, h4.z\n44: addh_d2 h0(TRUE), h0, h1\n45: slth h2.x(TRUE), h0.w, h2\n46: sgth h2.w(TRUE), h0, h2\n47: movh h0(TRUE), h0\n48: addx.c0 rc(TRUE), h2, h2.w\n49: movh h0(c0.NE.x), h1\n\nIPU0 ------ Simplified schedule: --------\nPass |  Unit  |  uOp |  PC:  Op\n-----+--------+------+-------------------------\n1 | SCT0/1 |  mov |   0:  TXLr h0.w, g[TEX1].zyxx, const.xxxx, TEX0;\n|    TEX |  txl |   0:  TXLr h0.w, g[TEX1].zyxx, const.xxxx, TEX0;\n|   SCB1 |  add |   2:  ADDh h2.z, h0.--w-, const.--x-;\n|        |      |\n2 | SCT0/1 |  mov |   4:  TXLr h0.w, g[TEX1].xwxx, const.xxxx, TEX0;\n|    TEX |  txl |   4:  TXLr h0.w, g[TEX1].xwxx, const.xxxx, TEX0;\n|   SCB1 |  add |   6:  ADDh h0.z,-h2, h0.--w-;\n|        |      |\n3 | SCT0/1 |  mov |   7:  TXLr h1.w, g[TEX1], const.xxxx, TEX0;\n|    TEX |  txl |   7:  TXLr h1.w, g[TEX1], const.xxxx, TEX0;\n|   SCB0 |  add |   9:  ADDh h0.x, h0.z---,-h1.w---;\n|   SCB1 |  add |  10:  ADDh h3.w, h0.---z, h1;\n|        |      |\n4 | SCT0/1 |  mov |  11:  TXLr h2.w, g[TEX1].zwzz, const.xxxx, TEX0;\n|    TEX |  txl |  11:  TXLr h2.w, g[TEX1].zwzz, const.xxxx, TEX0;\n|   SCB0 |  add |  14:  ADDh h0.x, h2.w---, h0;\n|   SCB1 |  add |  13:  ADDh h0.z, h3.--w-,-h2.--w-;\n|        |      |\n5 |   SCT1 |  mov |  15:  NRMh h1.xz, h0;\n|    SRB |  nrm |  15:  NRMh h1.xz, h0;\n|   SCB0 |  min |  16:  MINh*8 h0.x, |h1|, |h1.z---|;\n|   SCB1 |  max |  17:  MAXh h4.w, h0, h1;\n|        |      |\n6 |   SCT0 |  div |  18:  DIVx h2.xy, h1.xz--, h0;\n|   SCT1 |  mov |  19:  MOVr r1.zw, g[TEX0].--xy;\n|   SCB0 |  mad |  20:  MADr r2.xz,-h1, const.z-w-, r1.z-w-;\n|   SCB1 |  min |  22:  MINh h5.w, h0, h1;\n|        |      |\n7 | SCT0/1 |  mov |  23:  TXLr h0, r2.xzxx, const.xxxx, TEX0;\n|    TEX |  txl |  23:  TXLr h0, r2.xzxx, const.xxxx, TEX0;\n|   SCB0 |  max |  27:  MAXh h4.x, h2.z---, h2.w---;\n|   SCB1 |  mad |  25:  MADr r0.zw, h1.--xz, const, r1;\n|        |      |\n8 | SCT0/1 |  mov |  28:  TXLr h1, r0.zwzz, const.xxxx, TEX0;\n|    TEX |  txl |  28:  TXLr h1, r0.zwzz, const.xxxx, TEX0;\n| SCB0/1 |  add |  30:  ADDh/2 h1, h0, h1;\n|        |      |\n9 |   SCT0 |  mad |  31:  MADr r0.xy,-h2, const.xy--, r1.zw--;\n|   SCT1 |  mov |  33:  TXLr h0, r0, const.zzzz, TEX0;\n|    TEX |  txl |  33:  TXLr h0, r0, const.zzzz, TEX0;\n|   SCB1 |  min |  35:  MINh h4.z, h2, h2.--w-;\n|        |      |\n10 |   SCT0 |  mad |  37:  MADr r1.xy, h2, const.xy--, r1.zw--;\n|   SCT1 |  mov |  39:  TXLr h2, r1, const.zzzz, TEX0;\n|    TEX |  txl |  39:  TXLr h2, r1, const.zzzz, TEX0;\n| SCB0/1 |  add |  41:  ADDh/2 h0, h0, h2;\n|        |      |\n11 |   SCT0 |  min |  43:  MINh h2.x, h5.w---, h4.z---;\n|   SCT1 |  max |  42:  MAXh h2.w, h4, h4.---x;\n| SCB0/1 |  add |  44:  ADDh/2 h0, h0, h1;\n|        |      |\n12 |   SCT0 |  set |  45:  SLTh h2.x, h0.w---, h2;\n|   SCT1 |  set |  46:  SGTh h2.w, h0, h2;\n| SCB0/1 |  mul |  47:  MOVh h0, h0;\n|        |      |\n13 |   SCT0 |  mad |  48:  ADDxc0_s rc, h2, h2.w---;\n| SCB0/1 |  mul |  49:  MOVh h0(NE0.xxxx), h1;\n\nPass   SCT  TEX  SCB\n1:   0% 100%  25%\n2:   0% 100%  25%\n3:   0% 100%  50%\n4:   0% 100%  50%\n5:   0%   0%  50%\n6: 100%   0%  75%\n7:   0% 100%  75%\n8:   0% 100% 100%\n9:   0% 100%  25%\n10:   0% 100% 100%\n11:  50%   0% 100%\n12:  50%   0% 100%\n13:  25%   0% 100%\n\nMEAN:  17%  61%  67%\n\nPass   SCT0  SCT1   TEX  SCB0  SCB1\n1:    0%    0%  100%    0%  100%\n2:    0%    0%  100%    0%  100%\n3:    0%    0%  100%  100%  100%\n4:    0%    0%  100%  100%  100%\n5:    0%    0%    0%  100%  100%\n6:  100%  100%    0%  100%  100%\n7:    0%    0%  100%  100%  100%\n8:    0%    0%  100%  100%  100%\n9:    0%    0%  100%    0%  100%\n10:    0%    0%  100%  100%  100%\n11:  100%  100%    0%  100%  100%\n12:  100%  100%    0%  100%  100%\n13:  100%    0%    0%  100%  100%\n\nMEAN:   30%   23%   61%   76%  100%\nFragment Performance Setup: Driver RSX Compiler, GPU RSX, Flags 0x5\nResults 13 cycles, 3 r regs, 923,076,923 pixels/s\n============================================================================*/\n#if (FXAA_PS3 == 1) && (FXAA_EARLY_EXIT == 0)\n/*--------------------------------------------------------------------------*/\n#pragma regcount 7\n#pragma disablepc all\n#pragma option O3\n#pragma option OutColorPrec=fp16\n#pragma texformat default RGBA8\n/*==========================================================================*/\nhalf4 FxaaPixelShader(\n\t// See FXAA Quality FxaaPixelShader() source for docs on Inputs!\n\tFxaaFloat2 pos,\n\tFxaaFloat4 fxaaConsolePosPos,\n\tFxaaTex tex,\n\tFxaaTex fxaaConsole360TexExpBiasNegOne,\n\tFxaaTex fxaaConsole360TexExpBiasNegTwo,\n\tFxaaFloat2 fxaaQualityRcpFrame,\n\tFxaaFloat4 fxaaConsoleRcpFrameOpt,\n\tFxaaFloat4 fxaaConsoleRcpFrameOpt2,\n\tFxaaFloat4 fxaaConsole360RcpFrameOpt2,\n\tFxaaFloat fxaaQualitySubpix,\n\tFxaaFloat fxaaQualityEdgeThreshold,\n\tFxaaFloat fxaaQualityEdgeThresholdMin,\n\tFxaaFloat fxaaConsoleEdgeSharpness,\n\tFxaaFloat fxaaConsoleEdgeThreshold,\n\tFxaaFloat fxaaConsoleEdgeThresholdMin,\n\tFxaaFloat4 fxaaConsole360ConstDir\n\t) {\n\t/*--------------------------------------------------------------------------*/\n\t// (1)\n\thalf4 dir;\n\thalf4 lumaNe = h4tex2Dlod(tex, half4(fxaaConsolePosPos.zy, 0, 0));\n#if (FXAA_GREEN_AS_LUMA == 0)\n\tlumaNe.w += half(1.0 / 512.0);\n\tdir.x = -lumaNe.w;\n\tdir.z = -lumaNe.w;\n#else\n\tlumaNe.y += half(1.0 / 512.0);\n\tdir.x = -lumaNe.y;\n\tdir.z = -lumaNe.y;\n#endif\n\t/*--------------------------------------------------------------------------*/\n\t// (2)\n\thalf4 lumaSw = h4tex2Dlod(tex, half4(fxaaConsolePosPos.xw, 0, 0));\n#if (FXAA_GREEN_AS_LUMA == 0)\n\tdir.x += lumaSw.w;\n\tdir.z += lumaSw.w;\n#else\n\tdir.x += lumaSw.y;\n\tdir.z += lumaSw.y;\n#endif        \n\t/*--------------------------------------------------------------------------*/\n\t// (3)\n\thalf4 lumaNw = h4tex2Dlod(tex, half4(fxaaConsolePosPos.xy, 0, 0));\n#if (FXAA_GREEN_AS_LUMA == 0)\n\tdir.x -= lumaNw.w;\n\tdir.z += lumaNw.w;\n#else\n\tdir.x -= lumaNw.y;\n\tdir.z += lumaNw.y;\n#endif\n\t/*--------------------------------------------------------------------------*/\n\t// (4)\n\thalf4 lumaSe = h4tex2Dlod(tex, half4(fxaaConsolePosPos.zw, 0, 0));\n#if (FXAA_GREEN_AS_LUMA == 0)\n\tdir.x += lumaSe.w;\n\tdir.z -= lumaSe.w;\n#else\n\tdir.x += lumaSe.y;\n\tdir.z -= lumaSe.y;\n#endif\n\t/*--------------------------------------------------------------------------*/\n\t// (5)\n\thalf4 dir1_pos;\n\tdir1_pos.xy = normalize(dir.xyz).xz;\n\thalf dirAbsMinTimesC = min(abs(dir1_pos.x), abs(dir1_pos.y)) * half(FXAA_CONSOLE__PS3_EDGE_SHARPNESS);\n\t/*--------------------------------------------------------------------------*/\n\t// (6)\n\thalf4 dir2_pos;\n\tdir2_pos.xy = clamp(dir1_pos.xy / dirAbsMinTimesC, half(-2.0), half(2.0));\n\tdir1_pos.zw = pos.xy;\n\tdir2_pos.zw = pos.xy;\n\thalf4 temp1N;\n\ttemp1N.xy = dir1_pos.zw - dir1_pos.xy * fxaaConsoleRcpFrameOpt.zw;\n\t/*--------------------------------------------------------------------------*/\n\t// (7)\n\ttemp1N = h4tex2Dlod(tex, half4(temp1N.xy, 0.0, 0.0));\n\thalf4 rgby1;\n\trgby1.xy = dir1_pos.zw + dir1_pos.xy * fxaaConsoleRcpFrameOpt.zw;\n\t/*--------------------------------------------------------------------------*/\n\t// (8)\n\trgby1 = h4tex2Dlod(tex, half4(rgby1.xy, 0.0, 0.0));\n\trgby1 = (temp1N + rgby1) * 0.5;\n\t/*--------------------------------------------------------------------------*/\n\t// (9)\n\thalf4 temp2N;\n\ttemp2N.xy = dir2_pos.zw - dir2_pos.xy * fxaaConsoleRcpFrameOpt2.zw;\n\ttemp2N = h4tex2Dlod(tex, half4(temp2N.xy, 0.0, 0.0));\n\t/*--------------------------------------------------------------------------*/\n\t// (10)\n\thalf4 rgby2;\n\trgby2.xy = dir2_pos.zw + dir2_pos.xy * fxaaConsoleRcpFrameOpt2.zw;\n\trgby2 = h4tex2Dlod(tex, half4(rgby2.xy, 0.0, 0.0));\n\trgby2 = (temp2N + rgby2) * 0.5;\n\t/*--------------------------------------------------------------------------*/\n\t// (11)\n\t// compilier moves these scalar ops up to other cycles\n#if (FXAA_GREEN_AS_LUMA == 0)\n\thalf lumaMin = min(min(lumaNw.w, lumaSw.w), min(lumaNe.w, lumaSe.w));\n\thalf lumaMax = max(max(lumaNw.w, lumaSw.w), max(lumaNe.w, lumaSe.w));\n#else\n\thalf lumaMin = min(min(lumaNw.y, lumaSw.y), min(lumaNe.y, lumaSe.y));\n\thalf lumaMax = max(max(lumaNw.y, lumaSw.y), max(lumaNe.y, lumaSe.y));\n#endif        \n\trgby2 = (rgby2 + rgby1) * 0.5;\n\t/*--------------------------------------------------------------------------*/\n\t// (12)\n#if (FXAA_GREEN_AS_LUMA == 0)\n\tbool twoTapLt = rgby2.w < lumaMin;\n\tbool twoTapGt = rgby2.w > lumaMax;\n#else\n\tbool twoTapLt = rgby2.y < lumaMin;\n\tbool twoTapGt = rgby2.y > lumaMax;\n#endif\n\t/*--------------------------------------------------------------------------*/\n\t// (13)\n\tif (twoTapLt || twoTapGt) rgby2 = rgby1;\n\t/*--------------------------------------------------------------------------*/\n\treturn rgby2;\n}\n/*==========================================================================*/\n#endif\n\n\n\n/*============================================================================\n\nFXAA3 CONSOLE - OPTIMIZED PS3 PIXEL SHADER (WITH EARLY EXIT)\n\n==============================================================================\nThe code mostly matches the assembly.\nI have a feeling that 14 cycles is possible, but was not able to get there.\nMight have to increase register count to get full performance.\nNote this shader does not use perspective interpolation.\n\nUse the following cgc options,\n\n--fenable-bx2 --fastmath --fastprecision --nofloatbindings\n\nUse of FXAA_GREEN_AS_LUMA currently adds a cycle (16 clks).\nWill look at fixing this for FXAA 3.12.\n------------------------------------------------------------------------------\nNVSHADERPERF OUTPUT\n------------------------------------------------------------------------------\nFor reference and to aid in debug, output of NVShaderPerf should match this,\n\nShader to schedule:\n0: texpkb h0.w(TRUE), v5.zyxx, #0\n2: addh h2.y(TRUE), h0.w, constant(0.001953, 0.000000, 0.000000, 0.000000).x\n4: texpkb h1.w(TRUE), v5.xwxx, #0\n6: addh h0.x(TRUE), h1.w, -h2.y\n7: texpkb h2.w(TRUE), v5.zwzz, #0\n9: minh h4.w(TRUE), h2.y, h2\n10: maxh h5.x(TRUE), h2.y, h2.w\n11: texpkb h0.w(TRUE), v5, #0\n13: addh h3.w(TRUE), -h0, h0.x\n14: addh h0.x(TRUE), h0.w, h0\n15: addh h0.z(TRUE), -h2.w, h0.x\n16: addh h0.x(TRUE), h2.w, h3.w\n17: minh h5.y(TRUE), h0.w, h1.w\n18: nrmh h2.xz(TRUE), h0_n\n19: minh_m8 h2.w(TRUE), |h2.x|, |h2.z|\n20: divx h4.xy(TRUE), h2_n.xzzw, h2_n.w\n21: movr r1.zw(TRUE), v4.xxxy\n22: maxh h2.w(TRUE), h0, h1\n23: fenct TRUE\n24: madr r0.xy(TRUE), -h2.xzzw, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).zwzz, r1.zwzz\n26: texpkb h0(TRUE), r0, #0\n28: maxh h5.x(TRUE), h2.w, h5\n29: minh h5.w(TRUE), h5.y, h4\n30: madr r1.xy(TRUE), h2.xzzw, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).zwzz, r1.zwzz\n32: texpkb h2(TRUE), r1, #0\n34: addh_d2 h2(TRUE), h0, h2\n35: texpkb h1(TRUE), v4, #0\n37: maxh h5.y(TRUE), h5.x, h1.w\n38: minh h4.w(TRUE), h1, h5\n39: madr r0.xy(TRUE), -h4, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).xyxx, r1.zwzz\n41: texpkb h0(TRUE), r0, #0\n43: addh_m8 h5.z(TRUE), h5.y, -h4.w\n44: madr r2.xy(TRUE), h4, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).xyxx, r1.zwzz\n46: texpkb h3(TRUE), r2, #0\n48: addh_d2 h0(TRUE), h0, h3\n49: addh_d2 h3(TRUE), h0, h2\n50: movh h0(TRUE), h3\n51: slth h3.x(TRUE), h3.w, h5.w\n52: sgth h3.w(TRUE), h3, h5.x\n53: addx.c0 rc(TRUE), h3.x, h3\n54: slth.c0 rc(TRUE), h5.z, h5\n55: movh h0(c0.NE.w), h2\n56: movh h0(c0.NE.x), h1\n\nIPU0 ------ Simplified schedule: --------\nPass |  Unit  |  uOp |  PC:  Op\n-----+--------+------+-------------------------\n1 | SCT0/1 |  mov |   0:  TXLr h0.w, g[TEX1].zyxx, const.xxxx, TEX0;\n|    TEX |  txl |   0:  TXLr h0.w, g[TEX1].zyxx, const.xxxx, TEX0;\n|   SCB0 |  add |   2:  ADDh h2.y, h0.-w--, const.-x--;\n|        |      |\n2 | SCT0/1 |  mov |   4:  TXLr h1.w, g[TEX1].xwxx, const.xxxx, TEX0;\n|    TEX |  txl |   4:  TXLr h1.w, g[TEX1].xwxx, const.xxxx, TEX0;\n|   SCB0 |  add |   6:  ADDh h0.x, h1.w---,-h2.y---;\n|        |      |\n3 | SCT0/1 |  mov |   7:  TXLr h2.w, g[TEX1].zwzz, const.xxxx, TEX0;\n|    TEX |  txl |   7:  TXLr h2.w, g[TEX1].zwzz, const.xxxx, TEX0;\n|   SCB0 |  max |  10:  MAXh h5.x, h2.y---, h2.w---;\n|   SCB1 |  min |   9:  MINh h4.w, h2.---y, h2;\n|        |      |\n4 | SCT0/1 |  mov |  11:  TXLr h0.w, g[TEX1], const.xxxx, TEX0;\n|    TEX |  txl |  11:  TXLr h0.w, g[TEX1], const.xxxx, TEX0;\n|   SCB0 |  add |  14:  ADDh h0.x, h0.w---, h0;\n|   SCB1 |  add |  13:  ADDh h3.w,-h0, h0.---x;\n|        |      |\n5 |   SCT0 |  mad |  16:  ADDh h0.x, h2.w---, h3.w---;\n|   SCT1 |  mad |  15:  ADDh h0.z,-h2.--w-, h0.--x-;\n|   SCB0 |  min |  17:  MINh h5.y, h0.-w--, h1.-w--;\n|        |      |\n6 |   SCT1 |  mov |  18:  NRMh h2.xz, h0;\n|    SRB |  nrm |  18:  NRMh h2.xz, h0;\n|   SCB1 |  min |  19:  MINh*8 h2.w, |h2.---x|, |h2.---z|;\n|        |      |\n7 |   SCT0 |  div |  20:  DIVx h4.xy, h2.xz--, h2.ww--;\n|   SCT1 |  mov |  21:  MOVr r1.zw, g[TEX0].--xy;\n|   SCB1 |  max |  22:  MAXh h2.w, h0, h1;\n|        |      |\n8 |   SCT0 |  mad |  24:  MADr r0.xy,-h2.xz--, const.zw--, r1.zw--;\n|   SCT1 |  mov |  26:  TXLr h0, r0, const.xxxx, TEX0;\n|    TEX |  txl |  26:  TXLr h0, r0, const.xxxx, TEX0;\n|   SCB0 |  max |  28:  MAXh h5.x, h2.w---, h5;\n|   SCB1 |  min |  29:  MINh h5.w, h5.---y, h4;\n|        |      |\n9 |   SCT0 |  mad |  30:  MADr r1.xy, h2.xz--, const.zw--, r1.zw--;\n|   SCT1 |  mov |  32:  TXLr h2, r1, const.xxxx, TEX0;\n|    TEX |  txl |  32:  TXLr h2, r1, const.xxxx, TEX0;\n| SCB0/1 |  add |  34:  ADDh/2 h2, h0, h2;\n|        |      |\n10 | SCT0/1 |  mov |  35:  TXLr h1, g[TEX0], const.xxxx, TEX0;\n|    TEX |  txl |  35:  TXLr h1, g[TEX0], const.xxxx, TEX0;\n|   SCB0 |  max |  37:  MAXh h5.y, h5.-x--, h1.-w--;\n|   SCB1 |  min |  38:  MINh h4.w, h1, h5;\n|        |      |\n11 |   SCT0 |  mad |  39:  MADr r0.xy,-h4, const.xy--, r1.zw--;\n|   SCT1 |  mov |  41:  TXLr h0, r0, const.zzzz, TEX0;\n|    TEX |  txl |  41:  TXLr h0, r0, const.zzzz, TEX0;\n|   SCB0 |  mad |  44:  MADr r2.xy, h4, const.xy--, r1.zw--;\n|   SCB1 |  add |  43:  ADDh*8 h5.z, h5.--y-,-h4.--w-;\n|        |      |\n12 | SCT0/1 |  mov |  46:  TXLr h3, r2, const.xxxx, TEX0;\n|    TEX |  txl |  46:  TXLr h3, r2, const.xxxx, TEX0;\n| SCB0/1 |  add |  48:  ADDh/2 h0, h0, h3;\n|        |      |\n13 | SCT0/1 |  mad |  49:  ADDh/2 h3, h0, h2;\n| SCB0/1 |  mul |  50:  MOVh h0, h3;\n|        |      |\n14 |   SCT0 |  set |  51:  SLTh h3.x, h3.w---, h5.w---;\n|   SCT1 |  set |  52:  SGTh h3.w, h3, h5.---x;\n|   SCB0 |  set |  54:  SLThc0 rc, h5.z---, h5;\n|   SCB1 |  add |  53:  ADDxc0_s rc, h3.---x, h3;\n|        |      |\n15 | SCT0/1 |  mul |  55:  MOVh h0(NE0.wwww), h2;\n| SCB0/1 |  mul |  56:  MOVh h0(NE0.xxxx), h1;\n\nPass   SCT  TEX  SCB\n1:   0% 100%  25%\n2:   0% 100%  25%\n3:   0% 100%  50%\n4:   0% 100%  50%\n5:  50%   0%  25%\n6:   0%   0%  25%\n7: 100%   0%  25%\n8:   0% 100%  50%\n9:   0% 100% 100%\n10:   0% 100%  50%\n11:   0% 100%  75%\n12:   0% 100% 100%\n13: 100%   0% 100%\n14:  50%   0%  50%\n15: 100%   0% 100%\n\nMEAN:  26%  60%  56%\n\nPass   SCT0  SCT1   TEX  SCB0  SCB1\n1:    0%    0%  100%  100%    0%\n2:    0%    0%  100%  100%    0%\n3:    0%    0%  100%  100%  100%\n4:    0%    0%  100%  100%  100%\n5:  100%  100%    0%  100%    0%\n6:    0%    0%    0%    0%  100%\n7:  100%  100%    0%    0%  100%\n8:    0%    0%  100%  100%  100%\n9:    0%    0%  100%  100%  100%\n10:    0%    0%  100%  100%  100%\n11:    0%    0%  100%  100%  100%\n12:    0%    0%  100%  100%  100%\n13:  100%  100%    0%  100%  100%\n14:  100%  100%    0%  100%  100%\n15:  100%  100%    0%  100%  100%\n\nMEAN:   33%   33%   60%   86%   80%\nFragment Performance Setup: Driver RSX Compiler, GPU RSX, Flags 0x5\nResults 15 cycles, 3 r regs, 800,000,000 pixels/s\n============================================================================*/\n#if (FXAA_PS3 == 1) && (FXAA_EARLY_EXIT == 1)\n/*--------------------------------------------------------------------------*/\n#pragma regcount 7\n#pragma disablepc all\n#pragma option O2\n#pragma option OutColorPrec=fp16\n#pragma texformat default RGBA8\n/*==========================================================================*/\nhalf4 FxaaPixelShader(\n\t// See FXAA Quality FxaaPixelShader() source for docs on Inputs!\n\tFxaaFloat2 pos,\n\tFxaaFloat4 fxaaConsolePosPos,\n\tFxaaTex tex,\n\tFxaaTex fxaaConsole360TexExpBiasNegOne,\n\tFxaaTex fxaaConsole360TexExpBiasNegTwo,\n\tFxaaFloat2 fxaaQualityRcpFrame,\n\tFxaaFloat4 fxaaConsoleRcpFrameOpt,\n\tFxaaFloat4 fxaaConsoleRcpFrameOpt2,\n\tFxaaFloat4 fxaaConsole360RcpFrameOpt2,\n\tFxaaFloat fxaaQualitySubpix,\n\tFxaaFloat fxaaQualityEdgeThreshold,\n\tFxaaFloat fxaaQualityEdgeThresholdMin,\n\tFxaaFloat fxaaConsoleEdgeSharpness,\n\tFxaaFloat fxaaConsoleEdgeThreshold,\n\tFxaaFloat fxaaConsoleEdgeThresholdMin,\n\tFxaaFloat4 fxaaConsole360ConstDir\n\t) {\n\t/*--------------------------------------------------------------------------*/\n\t// (1)\n\thalf4 rgbyNe = h4tex2Dlod(tex, half4(fxaaConsolePosPos.zy, 0, 0));\n#if (FXAA_GREEN_AS_LUMA == 0)\n\thalf lumaNe = rgbyNe.w + half(1.0 / 512.0);\n#else\n\thalf lumaNe = rgbyNe.y + half(1.0 / 512.0);\n#endif\n\t/*--------------------------------------------------------------------------*/\n\t// (2)\n\thalf4 lumaSw = h4tex2Dlod(tex, half4(fxaaConsolePosPos.xw, 0, 0));\n#if (FXAA_GREEN_AS_LUMA == 0)\n\thalf lumaSwNegNe = lumaSw.w - lumaNe;\n#else\n\thalf lumaSwNegNe = lumaSw.y - lumaNe;\n#endif\n\t/*--------------------------------------------------------------------------*/\n\t// (3)\n\thalf4 lumaNw = h4tex2Dlod(tex, half4(fxaaConsolePosPos.xy, 0, 0));\n#if (FXAA_GREEN_AS_LUMA == 0)\n\thalf lumaMaxNwSw = max(lumaNw.w, lumaSw.w);\n\thalf lumaMinNwSw = min(lumaNw.w, lumaSw.w);\n#else\n\thalf lumaMaxNwSw = max(lumaNw.y, lumaSw.y);\n\thalf lumaMinNwSw = min(lumaNw.y, lumaSw.y);\n#endif\n\t/*--------------------------------------------------------------------------*/\n\t// (4)\n\thalf4 lumaSe = h4tex2Dlod(tex, half4(fxaaConsolePosPos.zw, 0, 0));\n#if (FXAA_GREEN_AS_LUMA == 0)\n\thalf dirZ = lumaNw.w + lumaSwNegNe;\n\thalf dirX = -lumaNw.w + lumaSwNegNe;\n#else\n\thalf dirZ = lumaNw.y + lumaSwNegNe;\n\thalf dirX = -lumaNw.y + lumaSwNegNe;\n#endif\n\t/*--------------------------------------------------------------------------*/\n\t// (5)\n\thalf3 dir;\n\tdir.y = 0.0;\n#if (FXAA_GREEN_AS_LUMA == 0)\n\tdir.x = lumaSe.w + dirX;\n\tdir.z = -lumaSe.w + dirZ;\n\thalf lumaMinNeSe = min(lumaNe, lumaSe.w);\n#else\n\tdir.x = lumaSe.y + dirX;\n\tdir.z = -lumaSe.y + dirZ;\n\thalf lumaMinNeSe = min(lumaNe, lumaSe.y);\n#endif\n\t/*--------------------------------------------------------------------------*/\n\t// (6)\n\thalf4 dir1_pos;\n\tdir1_pos.xy = normalize(dir).xz;\n\thalf dirAbsMinTimes8 = min(abs(dir1_pos.x), abs(dir1_pos.y)) * half(FXAA_CONSOLE__PS3_EDGE_SHARPNESS);\n\t/*--------------------------------------------------------------------------*/\n\t// (7)\n\thalf4 dir2_pos;\n\tdir2_pos.xy = clamp(dir1_pos.xy / dirAbsMinTimes8, half(-2.0), half(2.0));\n\tdir1_pos.zw = pos.xy;\n\tdir2_pos.zw = pos.xy;\n#if (FXAA_GREEN_AS_LUMA == 0)\n\thalf lumaMaxNeSe = max(lumaNe, lumaSe.w);\n#else\n\thalf lumaMaxNeSe = max(lumaNe, lumaSe.y);\n#endif\n\t/*--------------------------------------------------------------------------*/\n\t// (8)\n\thalf4 temp1N;\n\ttemp1N.xy = dir1_pos.zw - dir1_pos.xy * fxaaConsoleRcpFrameOpt.zw;\n\ttemp1N = h4tex2Dlod(tex, half4(temp1N.xy, 0.0, 0.0));\n\thalf lumaMax = max(lumaMaxNwSw, lumaMaxNeSe);\n\thalf lumaMin = min(lumaMinNwSw, lumaMinNeSe);\n\t/*--------------------------------------------------------------------------*/\n\t// (9)\n\thalf4 rgby1;\n\trgby1.xy = dir1_pos.zw + dir1_pos.xy * fxaaConsoleRcpFrameOpt.zw;\n\trgby1 = h4tex2Dlod(tex, half4(rgby1.xy, 0.0, 0.0));\n\trgby1 = (temp1N + rgby1) * 0.5;\n\t/*--------------------------------------------------------------------------*/\n\t// (10)\n\thalf4 rgbyM = h4tex2Dlod(tex, half4(pos.xy, 0.0, 0.0));\n#if (FXAA_GREEN_AS_LUMA == 0)\n\thalf lumaMaxM = max(lumaMax, rgbyM.w);\n\thalf lumaMinM = min(lumaMin, rgbyM.w);\n#else\n\thalf lumaMaxM = max(lumaMax, rgbyM.y);\n\thalf lumaMinM = min(lumaMin, rgbyM.y);\n#endif\n\t/*--------------------------------------------------------------------------*/\n\t// (11)\n\thalf4 temp2N;\n\ttemp2N.xy = dir2_pos.zw - dir2_pos.xy * fxaaConsoleRcpFrameOpt2.zw;\n\ttemp2N = h4tex2Dlod(tex, half4(temp2N.xy, 0.0, 0.0));\n\thalf4 rgby2;\n\trgby2.xy = dir2_pos.zw + dir2_pos.xy * fxaaConsoleRcpFrameOpt2.zw;\n\thalf lumaRangeM = (lumaMaxM - lumaMinM) / FXAA_CONSOLE__PS3_EDGE_THRESHOLD;\n\t/*--------------------------------------------------------------------------*/\n\t// (12)\n\trgby2 = h4tex2Dlod(tex, half4(rgby2.xy, 0.0, 0.0));\n\trgby2 = (temp2N + rgby2) * 0.5;\n\t/*--------------------------------------------------------------------------*/\n\t// (13)\n\trgby2 = (rgby2 + rgby1) * 0.5;\n\t/*--------------------------------------------------------------------------*/\n\t// (14)\n#if (FXAA_GREEN_AS_LUMA == 0)\n\tbool twoTapLt = rgby2.w < lumaMin;\n\tbool twoTapGt = rgby2.w > lumaMax;\n#else\n\tbool twoTapLt = rgby2.y < lumaMin;\n\tbool twoTapGt = rgby2.y > lumaMax;\n#endif\n\tbool earlyExit = lumaRangeM < lumaMax;\n\tbool twoTap = twoTapLt || twoTapGt;\n\t/*--------------------------------------------------------------------------*/\n\t// (15)\n\tif (twoTap) rgby2 = rgby1;\n\tif (earlyExit) rgby2 = rgbyM;\n\t/*--------------------------------------------------------------------------*/\n\treturn rgby2;\n}\n/*==========================================================================*/\n#endif\n\n\ncbuffer cbFxaa : register(b1) {\n\tfloat4 RCPFrame : packoffset(c0);\n};\n\nstruct FxaaVS_Output {\n\tfloat4 Pos : SV_POSITION;\n\tfloat2 Tex : TEXCOORD0;\n};\n\nFxaaVS_Output FxaaVS(uint id : SV_VertexID) {\n\tFxaaVS_Output Output;\n\tOutput.Tex = float2((id << 1) & 2, id & 2);\n\tOutput.Pos = float4(Output.Tex * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f), 0.0f, 1.0f);\n\treturn Output;\n}\n\nSamplerState InputSampler : register(s3);\nTexture2D    InputTexture : register(t0);\n\nfloat4 FxaaPS(FxaaVS_Output Input) : SV_TARGET{\n\tFxaaTex InputFXAATex = { InputSampler, InputTexture };\nreturn FxaaPixelShader(\n\tInput.Tex.xy,\t\t\t\t\t\t\t// FxaaFloat2 pos,\n\tFxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f),\t\t// FxaaFloat4 fxaaConsolePosPos,\n\tInputFXAATex,\t\t\t\t\t\t\t// FxaaTex tex,\n\tInputFXAATex,\t\t\t\t\t\t\t// FxaaTex fxaaConsole360TexExpBiasNegOne,\n\tInputFXAATex,\t\t\t\t\t\t\t// FxaaTex fxaaConsole360TexExpBiasNegTwo,\n\tRCPFrame.xy,\t\t\t\t\t\t\t// FxaaFloat2 fxaaQualityRcpFrame,\n\tFxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f),\t\t// FxaaFloat4 fxaaConsoleRcpFrameOpt,\n\tFxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f),\t\t// FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n\tFxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f),\t\t// FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n\t0.75f,\t\t\t\t\t\t\t\t\t// FxaaFloat fxaaQualitySubpix,\n\t0.166f,\t\t\t\t\t\t\t\t\t// FxaaFloat fxaaQualityEdgeThreshold,\n\t0.0833f,\t\t\t\t\t\t\t\t// FxaaFloat fxaaQualityEdgeThresholdMin,\n\t0.0f,\t\t\t\t\t\t\t\t\t// FxaaFloat fxaaConsoleEdgeSharpness,\n\t0.0f,\t\t\t\t\t\t\t\t\t// FxaaFloat fxaaConsoleEdgeThreshold,\n\t0.0f,\t\t\t\t\t\t\t\t\t// FxaaFloat fxaaConsoleEdgeThresholdMin,\n\tFxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f)\t\t// FxaaFloat fxaaConsole360ConstDir,\n\t);\n}\n\n";
				case "SMAA.fx":
					return "/**\n * Copyright (C) 2013 Jorge Jimenez (jorge@iryoku.com)\n * Copyright (C) 2013 Jose I. Echevarria (joseignacioechevarria@gmail.com)\n * Copyright (C) 2013 Belen Masia (bmasia@unizar.es)\n * Copyright (C) 2013 Fernando Navarro (fernandn@microsoft.com)\n * Copyright (C) 2013 Diego Gutierrez (diegog@unizar.es)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to\n * do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software. As clarification, there\n * is no requirement that the copyright notice and permission be included in\n * binary distributions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/**\n *                  _______  ___  ___       ___           ___\n *                 /       ||   \\/   |     /   \\         /   \\\n *                |   (---- |  \\  /  |    /  ^  \\       /  ^  \\\n *                 \\   \\    |  |\\/|  |   /  /_\\  \\     /  /_\\  \\\n *              ----)   |   |  |  |  |  /  _____  \\   /  _____  \\\n *             |_______/    |__|  |__| /__/     \\__\\ /__/     \\__\\\n * \n *                               E N H A N C E D\n *       S U B P I X E L   M O R P H O L O G I C A L   A N T I A L I A S I N G\n *\n *                         http://www.iryoku.com/smaa/\n *\n * Hi, welcome aboard!\n * \n * Here you'll find instructions to get the shader up and running as fast as\n * possible.\n *\n * IMPORTANTE NOTICE: when updating, remember to update both this file and the\n * precomputed textures! They may change from version to version.\n *\n * The shader has three passes, chained together as follows:\n *\n *                           |input|------------------�\n *                              v                     |\n *                    [ SMAA*EdgeDetection ]          |\n *                              v                     |\n *                          |edgesTex|                |\n *                              v                     |\n *              [ SMAABlendingWeightCalculation ]     |\n *                              v                     |\n *                          |blendTex|                |\n *                              v                     |\n *                [ SMAANeighborhoodBlending ] <------�\n *                              v\n *                           |output|\n *\n * Note that each [pass] has its own vertex and pixel shader. Remember to use\n * oversized triangles instead of quads to avoid overshading along the\n * diagonal.\n *\n * You've three edge detection methods to choose from: luma, color or depth.\n * They represent different quality/performance and anti-aliasing/sharpness\n * tradeoffs, so our recommendation is for you to choose the one that best\n * suits your particular scenario:\n *\n * - Depth edge detection is usually the fastest but it may miss some edges.\n *\n * - Luma edge detection is usually more expensive than depth edge detection,\n *   but catches visible edges that depth edge detection can miss.\n *\n * - Color edge detection is usually the most expensive one but catches\n *   chroma-only edges.\n *\n * For quickstarters: just use luma edge detection.\n *\n * The general advice is to not rush the integration process and ensure each\n * step is done correctly (don't try to integrate SMAA T2x with predicated edge\n * detection from the start!). Ok then, let's go!\n *\n *  1. The first step is to create two RGBA temporal render targets for holding\n *     |edgesTex| and |blendTex|.\n *\n *     In DX10 or DX11, you can use a RG render target for the edges texture.\n *     In the case of NVIDIA GPUs, using RG render targets seems to actually be\n *     slower.\n *\n *     On the Xbox 360, you can use the same render target for resolving both\n *     |edgesTex| and |blendTex|, as they aren't needed simultaneously.\n *\n *  2. Both temporal render targets |edgesTex| and |blendTex| must be cleared\n *     each frame. Do not forget to clear the alpha channel!\n *\n *  3. The next step is loading the two supporting precalculated textures,\n *     'areaTex' and 'searchTex'. You'll find them in the 'Textures' folder as\n *     C++ headers, and also as regular DDS files. They'll be needed for the\n *     'SMAABlendingWeightCalculation' pass.\n *\n *     If you use the C++ headers, be sure to load them in the format specified\n *     inside of them.\n *\n *     You can also compress 'areaTex' and 'searchTex' using BC5 and BC4\n *     respectively, if you have that option in your content processor pipeline.\n *     When compressing then, you get a non-perceptible quality decrease, and a\n *     marginal performance increase.\n *\n *  4. All samplers must be set to linear filtering and clamp.\n *\n *     After you get the technique working, remember that 64-bit inputs have\n *     half-rate linear filtering on GCN.\n *\n *     If SMAA is applied to 64-bit color buffers, switching to point filtering\n *     when accesing them will increase the performance. Search for\n *     'SMAASamplePoint' to see which textures may benefit from point\n *     filtering, and where (which is basically the color input in the edge\n *     detection and resolve passes).\n *\n *  5. All texture reads and buffer writes must be non-sRGB, with the exception\n *     of the input read and the output write in\n *     'SMAANeighborhoodBlending' (and only in this pass!). If sRGB reads in\n *     this last pass are not possible, the technique will work anyway, but\n *     will perform antialiasing in gamma space.\n *\n *     IMPORTANT: for best results the input read for the color/luma edge \n *     detection should *NOT* be sRGB.\n *\n *  6. Before including SMAA.h you'll have to setup the render target metrics,\n *     the target and any optional configuration defines. Optionally you can\n *     use a preset.\n *\n *     You have the following targets available: \n *         SMAA_HLSL_3\n *         SMAA_HLSL_4\n *         SMAA_HLSL_4_1\n *         SMAA_GLSL_3 *\n *         SMAA_GLSL_4 *\n *\n *         * (See SMAA_INCLUDE_VS and SMAA_INCLUDE_PS below).\n *\n *     And four presets:\n *         SMAA_PRESET_LOW          (%60 of the quality)\n *         SMAA_PRESET_MEDIUM       (%80 of the quality)\n *         SMAA_PRESET_HIGH         (%95 of the quality)\n *         SMAA_PRESET_ULTRA        (%99 of the quality)\n *\n *     For example:\n *         #define SMAA_RT_METRICS float4(1.0 / 1280.0, 1.0 / 720.0, 1280.0, 720.0)\n *         #define SMAA_HLSL_4\n *         #define SMAA_PRESET_HIGH\n *         #include \"SMAA.h\"\n *\n *     Note that SMAA_RT_METRICS doesn't need to be a macro, it can be a\n *     uniform variable. The code is designed to minimize the impact of not\n *     using a constant value, but it is still better to hardcode it.\n *\n *     Depending on how you encoded 'areaTex' and 'searchTex', you may have to\n *     add (and customize) the following defines before including SMAA.h:\n *          #define SMAA_AREATEX_SELECT(sample) sample.rg\n *          #define SMAA_SEARCHTEX_SELECT(sample) sample.r\n *\n *     If your engine is already using porting macros, you can define\n *     SMAA_CUSTOM_SL, and define the porting functions by yourself.\n *\n *  7. Then, you'll have to setup the passes as indicated in the scheme above.\n *     You can take a look into SMAA.fx, to see how we did it for our demo.\n *     Checkout the function wrappers, you may want to copy-paste them!\n *\n *  8. It's recommended to validate the produced |edgesTex| and |blendTex|.\n *     You can use a screenshot from your engine to compare the |edgesTex|\n *     and |blendTex| produced inside of the engine with the results obtained\n *     with the reference demo.\n *\n *  9. After you get the last pass to work, it's time to optimize. You'll have\n *     to initialize a stencil buffer in the first pass (discard is already in\n *     the code), then mask execution by using it the second pass. The last\n *     pass should be executed in all pixels.\n *\n *\n * After this point you can choose to enable predicated thresholding,\n * temporal supersampling and motion blur integration:\n *\n * a) If you want to use predicated thresholding, take a look into\n *    SMAA_PREDICATION; you'll need to pass an extra texture in the edge\n *    detection pass.\n *\n * b) If you want to enable temporal supersampling (SMAA T2x):\n *\n * 1. The first step is to render using subpixel jitters. I won't go into\n *    detail, but it's as simple as moving each vertex position in the\n *    vertex shader, you can check how we do it in our DX10 demo.\n *\n * 2. Then, you must setup the temporal resolve. You may want to take a look\n *    into SMAAResolve for resolving 2x modes. After you get it working, you'll\n *    probably see ghosting everywhere. But fear not, you can enable the\n *    CryENGINE temporal reprojection by setting the SMAA_REPROJECTION macro.\n *    Check out SMAA_DECODE_VELOCITY if your velocity buffer is encoded.\n *\n * 3. The next step is to apply SMAA to each subpixel jittered frame, just as\n *    done for 1x.\n *\n * 4. At this point you should already have something usable, but for best\n *    results the proper area textures must be set depending on current jitter.\n *    For this, the parameter 'subsampleIndices' of\n *    'SMAABlendingWeightCalculationPS' must be set as follows, for our T2x\n *    mode:\n *\n *    @SUBSAMPLE_INDICES\n *\n *    | S# |  Camera Jitter   |  subsampleIndices    |\n *    +----+------------------+---------------------+\n *    |  0 |  ( 0.25, -0.25)  |  float4(1, 1, 1, 0)  |\n *    |  1 |  (-0.25,  0.25)  |  float4(2, 2, 2, 0)  |\n *\n *    These jitter positions assume a bottom-to-top y axis. S# stands for the\n *    sample number.\n *\n * More information about temporal supersampling here:\n *    http://iryoku.com/aacourse/downloads/13-Anti-Aliasing-Methods-in-CryENGINE-3.pdf\n *\n * c) If you want to enable spatial multisampling (SMAA S2x):\n *\n * 1. The scene must be rendered using MSAA 2x. The MSAA 2x buffer must be\n *    created with:\n *      - DX10:     see below (*)\n *      - DX10.1:   D3D10_STANDARD_MULTISAMPLE_PATTERN or\n *      - DX11:     D3D11_STANDARD_MULTISAMPLE_PATTERN\n *\n *    This allows to ensure that the subsample order matches the table in\n *    @SUBSAMPLE_INDICES.\n *\n *    (*) In the case of DX10, we refer the reader to:\n *      - SMAA::detectMSAAOrder and\n *      - SMAA::msaaReorder\n *\n *    These functions allow to match the standard multisample patterns by\n *    detecting the subsample order for a specific GPU, and reordering\n *    them appropriately.\n *\n * 2. A shader must be run to output each subsample into a separate buffer\n *    (DX10 is required). You can use SMAASeparate for this purpose, or just do\n *    it in an existing pass (for example, in the tone mapping pass, which has\n *    the advantage of feeding tone mapped subsamples to SMAA, which will yield\n *    better results).\n *\n * 3. The full SMAA 1x pipeline must be run for each separated buffer, storing\n *    the results in the final buffer. The second run should alpha blend with\n *    the existing final buffer using a blending factor of 0.5.\n *    'subsampleIndices' must be adjusted as in the SMAA T2x case (see point\n *    b).\n *\n * d) If you want to enable temporal supersampling on top of SMAA S2x\n *    (which actually is SMAA 4x):\n *\n * 1. SMAA 4x consists on temporally jittering SMAA S2x, so the first step is\n *    to calculate SMAA S2x for current frame. In this case, 'subsampleIndices'\n *    must be set as follows:\n *\n *    | F# | S# |   Camera Jitter    |    Net Jitter     |   subsampleIndices   |\n *    +----+----+--------------------+-------------------+----------------------+\n *    |  0 |  0 |  ( 0.125,  0.125)  |  ( 0.375, -0.125) |  float4(5, 3, 1, 3)  |\n *    |  0 |  1 |  ( 0.125,  0.125)  |  (-0.125,  0.375) |  float4(4, 6, 2, 3)  |\n *    +----+----+--------------------+-------------------+----------------------+\n *    |  1 |  2 |  (-0.125, -0.125)  |  ( 0.125, -0.375) |  float4(3, 5, 1, 4)  |\n *    |  1 |  3 |  (-0.125, -0.125)  |  (-0.375,  0.125) |  float4(6, 4, 2, 4)  |\n *\n *    These jitter positions assume a bottom-to-top y axis. F# stands for the\n *    frame number. S# stands for the sample number.\n *\n * 2. After calculating SMAA S2x for current frame (with the new subsample\n *    indices), previous frame must be reprojected as in SMAA T2x mode (see\n *    point b).\n *\n * e) If motion blur is used, you may want to do the edge detection pass\n *    together with motion blur. This has two advantages:\n *\n * 1. Pixels under heavy motion can be omitted from the edge detection process.\n *    For these pixels we can just store \"no edge\", as motion blur will take\n *    care of them.\n * 2. The center pixel tap is reused.\n *\n * Note that in this case depth testing should be used instead of stenciling,\n * as we have to write all the pixels in the motion blur pass.\n *\n * That's it!\n */\n\n//-----------------------------------------------------------------------------\n// SMAA Presets\n\n/**\n * Note that if you use one of these presets, the following configuration\n * macros will be ignored if set in the \"Configurable Defines\" section.\n */\n\n#if defined(SMAA_PRESET_LOW)\n#define SMAA_THRESHOLD 0.15\n#define SMAA_MAX_SEARCH_STEPS 4\n#define SMAA_DISABLE_DIAG_DETECTION\n#define SMAA_DISABLE_CORNER_DETECTION\n#elif defined(SMAA_PRESET_MEDIUM)\n#define SMAA_THRESHOLD 0.1\n#define SMAA_MAX_SEARCH_STEPS 8\n#define SMAA_DISABLE_DIAG_DETECTION\n#define SMAA_DISABLE_CORNER_DETECTION\n#elif defined(SMAA_PRESET_HIGH)\n#define SMAA_THRESHOLD 0.1\n#define SMAA_MAX_SEARCH_STEPS 16\n#define SMAA_MAX_SEARCH_STEPS_DIAG 8\n#define SMAA_CORNER_ROUNDING 25\n#elif defined(SMAA_PRESET_ULTRA)\n#define SMAA_THRESHOLD 0.05\n#define SMAA_MAX_SEARCH_STEPS 32\n#define SMAA_MAX_SEARCH_STEPS_DIAG 16\n#define SMAA_CORNER_ROUNDING 25\n#endif\n\n//-----------------------------------------------------------------------------\n// Configurable Defines\n\n/**\n * SMAA_THRESHOLD specifies the threshold or sensitivity to edges.\n * Lowering this value you will be able to detect more edges at the expense of\n * performance. \n *\n * Range: [0, 0.5]\n *   0.1 is a reasonable value, and allows to catch most visible edges.\n *   0.05 is a rather overkill value, that allows to catch 'em all.\n *\n *   If temporal supersampling is used, 0.2 could be a reasonable value, as low\n *   contrast edges are properly filtered by just 2x.\n */\n#ifndef SMAA_THRESHOLD\n#define SMAA_THRESHOLD 0.1\n#endif\n\n/**\n * SMAA_DEPTH_THRESHOLD specifies the threshold for depth edge detection.\n * \n * Range: depends on the depth range of the scene.\n */\n#ifndef SMAA_DEPTH_THRESHOLD\n#define SMAA_DEPTH_THRESHOLD (0.1 * SMAA_THRESHOLD)\n#endif\n\n/**\n * SMAA_MAX_SEARCH_STEPS specifies the maximum steps performed in the\n * horizontal/vertical pattern searches, at each side of the pixel.\n *\n * In number of pixels, it's actually the double. So the maximum line length\n * perfectly handled by, for example 16, is 64 (by perfectly, we meant that\n * longer lines won't look as good, but still antialiased).\n *\n * Range: [0, 112]\n */\n#ifndef SMAA_MAX_SEARCH_STEPS\n#define SMAA_MAX_SEARCH_STEPS 16\n#endif\n\n/**\n * SMAA_MAX_SEARCH_STEPS_DIAG specifies the maximum steps performed in the\n * diagonal pattern searches, at each side of the pixel. In this case we jump\n * one pixel at time, instead of two.\n *\n * Range: [0, 20]\n *\n * On high-end machines it is cheap (between a 0.8x and 0.9x slower for 16 \n * steps), but it can have a significant impact on older machines.\n *\n * Define SMAA_DISABLE_DIAG_DETECTION to disable diagonal processing.\n */\n#ifndef SMAA_MAX_SEARCH_STEPS_DIAG\n#define SMAA_MAX_SEARCH_STEPS_DIAG 8\n#endif\n\n/**\n * SMAA_CORNER_ROUNDING specifies how much sharp corners will be rounded.\n *\n * Range: [0, 100]\n *\n * Define SMAA_DISABLE_CORNER_DETECTION to disable corner processing.\n */\n#ifndef SMAA_CORNER_ROUNDING\n#define SMAA_CORNER_ROUNDING 25\n#endif\n\n/**\n * If there is an neighbor edge that has SMAA_LOCAL_CONTRAST_FACTOR times\n * bigger contrast than current edge, current edge will be discarded.\n *\n * This allows to eliminate spurious crossing edges, and is based on the fact\n * that, if there is too much contrast in a direction, that will hide\n * perceptually contrast in the other neighbors.\n */\n#ifndef SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR\n#define SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR 2.0\n#endif\n\n/**\n * Predicated thresholding allows to better preserve texture details and to\n * improve performance, by decreasing the number of detected edges using an\n * additional buffer like the light accumulation buffer, object ids or even the\n * depth buffer (the depth buffer usage may be limited to indoor or short range\n * scenes).\n *\n * It locally decreases the luma or color threshold if an edge is found in an\n * additional buffer (so the global threshold can be higher).\n *\n * This method was developed by Playstation EDGE MLAA team, and used in \n * Killzone 3, by using the light accumulation buffer. More information here:\n *     http://iryoku.com/aacourse/downloads/06-MLAA-on-PS3.pptx \n */\n#ifndef SMAA_PREDICATION\n#define SMAA_PREDICATION 0\n#endif\n\n/**\n * Threshold to be used in the additional predication buffer. \n *\n * Range: depends on the input, so you'll have to find the magic number that\n * works for you.\n */\n#ifndef SMAA_PREDICATION_THRESHOLD\n#define SMAA_PREDICATION_THRESHOLD 0.01\n#endif\n\n/**\n * How much to scale the global threshold used for luma or color edge\n * detection when using predication.\n *\n * Range: [1, 5]\n */\n#ifndef SMAA_PREDICATION_SCALE\n#define SMAA_PREDICATION_SCALE 2.0\n#endif\n\n/**\n * How much to locally decrease the threshold.\n *\n * Range: [0, 1]\n */\n#ifndef SMAA_PREDICATION_STRENGTH\n#define SMAA_PREDICATION_STRENGTH 0.4\n#endif\n\n/**\n * Temporal reprojection allows to remove ghosting artifacts when using\n * temporal supersampling. We use the CryEngine 3 method which also introduces\n * velocity weighting. This feature is of extreme importance for totally\n * removing ghosting. More information here:\n *    http://iryoku.com/aacourse/downloads/13-Anti-Aliasing-Methods-in-CryENGINE-3.pdf\n *\n * Note that you'll need to setup a velocity buffer for enabling reprojection.\n * For static geometry, saving the previous depth buffer is a viable\n * alternative.\n */\n#ifndef SMAA_REPROJECTION\n#define SMAA_REPROJECTION 0\n#endif\n\n/**\n * SMAA_REPROJECTION_WEIGHT_SCALE controls the velocity weighting. It allows to\n * remove ghosting trails behind the moving object, which are not removed by\n * just using reprojection. Using low values will exhibit ghosting, while using\n * high values will disable temporal supersampling under motion.\n *\n * Behind the scenes, velocity weighting removes temporal supersampling when\n * the velocity of the subsamples differs (meaning they are different objects).\n *\n * Range: [0, 80]\n */\n#ifndef SMAA_REPROJECTION_WEIGHT_SCALE\n#define SMAA_REPROJECTION_WEIGHT_SCALE 30.0\n#endif\n\n/**\n * On some compilers, discard cannot be used in vertex shaders. Thus, they need\n * to be compiled separately.\n */\n#ifndef SMAA_INCLUDE_VS\n#define SMAA_INCLUDE_VS 1\n#endif\n#ifndef SMAA_INCLUDE_PS\n#define SMAA_INCLUDE_PS 1\n#endif\n\n//-----------------------------------------------------------------------------\n// Texture Access Defines\n\n#ifndef SMAA_AREATEX_SELECT\n#if defined(SMAA_HLSL_3)\n#define SMAA_AREATEX_SELECT(sample) sample.ra\n#else\n#define SMAA_AREATEX_SELECT(sample) sample.rg\n#endif\n#endif\n\n#ifndef SMAA_SEARCHTEX_SELECT\n#define SMAA_SEARCHTEX_SELECT(sample) sample.r\n#endif\n\n#ifndef SMAA_DECODE_VELOCITY\n#define SMAA_DECODE_VELOCITY(sample) sample.rg\n#endif\n\n//-----------------------------------------------------------------------------\n// Non-Configurable Defines\n\n#define SMAA_AREATEX_MAX_DISTANCE 16\n#define SMAA_AREATEX_MAX_DISTANCE_DIAG 20\n#define SMAA_AREATEX_PIXEL_SIZE (1.0 / float2(160.0, 560.0))\n#define SMAA_AREATEX_SUBTEX_SIZE (1.0 / 7.0)\n#define SMAA_SEARCHTEX_SIZE float2(66.0, 33.0)\n#define SMAA_SEARCHTEX_PACKED_SIZE float2(64.0, 16.0)\n#define SMAA_CORNER_ROUNDING_NORM (float(SMAA_CORNER_ROUNDING) / 100.0)\n\n//-----------------------------------------------------------------------------\n// Porting Functions\n\n#if defined(SMAA_HLSL_3)\n#define SMAATexture2D(tex) sampler2D tex\n#define SMAATexturePass2D(tex) tex\n#define SMAASampleLevelZero(tex, coord) tex2Dlod(tex, float4(coord, 0.0, 0.0))\n#define SMAASampleLevelZeroPoint(tex, coord) tex2Dlod(tex, float4(coord, 0.0, 0.0))\n#define SMAASampleLevelZeroOffset(tex, coord, offset) tex2Dlod(tex, float4(coord + offset * SMAA_RT_METRICS.xy, 0.0, 0.0))\n#define SMAASample(tex, coord) tex2D(tex, coord)\n#define SMAASamplePoint(tex, coord) tex2D(tex, coord)\n#define SMAASampleOffset(tex, coord, offset) tex2D(tex, coord + offset * SMAA_RT_METRICS.xy)\n#define SMAA_FLATTEN [flatten]\n#define SMAA_BRANCH [branch]\n#endif\n#if defined(SMAA_HLSL_4) || defined(SMAA_HLSL_4_1)\nSamplerState LinearSampler { Filter = MIN_MAG_LINEAR_MIP_POINT; AddressU = Clamp; AddressV = Clamp; };\nSamplerState PointSampler { Filter = MIN_MAG_MIP_POINT; AddressU = Clamp; AddressV = Clamp; };\n#define SMAATexture2D(tex) Texture2D tex\n#define SMAATexturePass2D(tex) tex\n#define SMAASampleLevelZero(tex, coord) tex.SampleLevel(LinearSampler, coord, 0)\n#define SMAASampleLevelZeroPoint(tex, coord) tex.SampleLevel(PointSampler, coord, 0)\n#define SMAASampleLevelZeroOffset(tex, coord, offset) tex.SampleLevel(LinearSampler, coord, 0, offset)\n#define SMAASample(tex, coord) tex.Sample(LinearSampler, coord)\n#define SMAASamplePoint(tex, coord) tex.Sample(PointSampler, coord)\n#define SMAASampleOffset(tex, coord, offset) tex.Sample(LinearSampler, coord, offset)\n#define SMAA_FLATTEN [flatten]\n#define SMAA_BRANCH [branch]\n#define SMAATexture2DMS2(tex) Texture2DMS<float4, 2> tex\n#define SMAALoad(tex, pos, sample) tex.Load(pos, sample)\n#if defined(SMAA_HLSL_4_1)\n#define SMAAGather(tex, coord) tex.Gather(LinearSampler, coord, 0)\n#endif\n#endif\n#if defined(SMAA_GLSL_3) || defined(SMAA_GLSL_4)\n#define SMAATexture2D(tex) sampler2D tex\n#define SMAATexturePass2D(tex) tex\n#define SMAASampleLevelZero(tex, coord) textureLod(tex, coord, 0.0)\n#define SMAASampleLevelZeroPoint(tex, coord) textureLod(tex, coord, 0.0)\n#define SMAASampleLevelZeroOffset(tex, coord, offset) textureLodOffset(tex, coord, 0.0, offset)\n#define SMAASample(tex, coord) texture(tex, coord)\n#define SMAASamplePoint(tex, coord) texture(tex, coord)\n#define SMAASampleOffset(tex, coord, offset) texture(tex, coord, offset)\n#define SMAA_FLATTEN\n#define SMAA_BRANCH\n#define lerp(a, b, t) mix(a, b, t)\n#define saturate(a) clamp(a, 0.0, 1.0)\n#if defined(SMAA_GLSL_4)\n#define mad(a, b, c) fma(a, b, c)\n#define SMAAGather(tex, coord) textureGather(tex, coord)\n#else\n#define mad(a, b, c) (a * b + c)\n#endif\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define int2 ivec2\n#define int3 ivec3\n#define int4 ivec4\n#define bool2 bvec2\n#define bool3 bvec3\n#define bool4 bvec4\n#endif\n\n#if !defined(SMAA_HLSL_3) && !defined(SMAA_HLSL_4) && !defined(SMAA_HLSL_4_1) && !defined(SMAA_GLSL_3) && !defined(SMAA_GLSL_4) && !defined(SMAA_CUSTOM_SL)\n#error you must define the shading language: SMAA_HLSL_*, SMAA_GLSL_* or SMAA_CUSTOM_SL\n#endif\n\n//-----------------------------------------------------------------------------\n// Misc functions\n\n/**\n * Gathers current pixel, and the top-left neighbors.\n */\nfloat3 SMAAGatherNeighbours(float2 texcoord,\n                            float4 offset[3],\n                            SMAATexture2D(tex)) {\n    #ifdef SMAAGather\n    return SMAAGather(tex, texcoord + SMAA_RT_METRICS.xy * float2(-0.5, -0.5)).grb;\n    #else\n    float P = SMAASamplePoint(tex, texcoord).r;\n    float Pleft = SMAASamplePoint(tex, offset[0].xy).r;\n    float Ptop  = SMAASamplePoint(tex, offset[0].zw).r;\n    return float3(P, Pleft, Ptop);\n    #endif\n}\n\n/**\n * Adjusts the threshold by means of predication.\n */\nfloat2 SMAACalculatePredicatedThreshold(float2 texcoord,\n                                        float4 offset[3],\n                                        SMAATexture2D(predicationTex)) {\n    float3 neighbours = SMAAGatherNeighbours(texcoord, offset, SMAATexturePass2D(predicationTex));\n    float2 delta = abs(neighbours.xx - neighbours.yz);\n    float2 edges = step(SMAA_PREDICATION_THRESHOLD, delta);\n    return SMAA_PREDICATION_SCALE * SMAA_THRESHOLD * (1.0 - SMAA_PREDICATION_STRENGTH * edges);\n}\n\n/**\n * Conditional move:\n */\nvoid SMAAMovc(bool2 cond, inout float2 variable, float2 value) {\n    SMAA_FLATTEN if (cond.x) variable.x = value.x;\n    SMAA_FLATTEN if (cond.y) variable.y = value.y;\n}\n\nvoid SMAAMovc(bool4 cond, inout float4 variable, float4 value) {\n    SMAAMovc(cond.xy, variable.xy, value.xy);\n    SMAAMovc(cond.zw, variable.zw, value.zw);\n}\n\n\n#if SMAA_INCLUDE_VS\n//-----------------------------------------------------------------------------\n// Vertex Shaders\n\n/**\n * Edge Detection Vertex Shader\n */\nvoid SMAAEdgeDetectionVS(float2 texcoord,\n                         out float4 offset[3]) {\n    offset[0] = mad(SMAA_RT_METRICS.xyxy, float4(-1.0, 0.0, 0.0, -1.0), texcoord.xyxy);\n    offset[1] = mad(SMAA_RT_METRICS.xyxy, float4( 1.0, 0.0, 0.0,  1.0), texcoord.xyxy);\n    offset[2] = mad(SMAA_RT_METRICS.xyxy, float4(-2.0, 0.0, 0.0, -2.0), texcoord.xyxy);\n}\n\n/**\n * Blend Weight Calculation Vertex Shader\n */\nvoid SMAABlendingWeightCalculationVS(float2 texcoord,\n                                     out float2 pixcoord,\n                                     out float4 offset[3]) {\n    pixcoord = texcoord * SMAA_RT_METRICS.zw;\n\n    // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n    offset[0] = mad(SMAA_RT_METRICS.xyxy, float4(-0.25, -0.125,  1.25, -0.125), texcoord.xyxy);\n    offset[1] = mad(SMAA_RT_METRICS.xyxy, float4(-0.125, -0.25, -0.125,  1.25), texcoord.xyxy);\n\n    // And these for the searches, they indicate the ends of the loops:\n    offset[2] = mad(SMAA_RT_METRICS.xxyy,\n                    float4(-2.0, 2.0, -2.0, 2.0) * float(SMAA_MAX_SEARCH_STEPS),\n                    float4(offset[0].xz, offset[1].yw));\n}\n\n/**\n * Neighborhood Blending Vertex Shader\n */\nvoid SMAANeighborhoodBlendingVS(float2 texcoord,\n                                out float4 offset) {\n    offset = mad(SMAA_RT_METRICS.xyxy, float4( 1.0, 0.0, 0.0,  1.0), texcoord.xyxy);\n}\n#endif // SMAA_INCLUDE_VS\n\n#if SMAA_INCLUDE_PS\n//-----------------------------------------------------------------------------\n// Edge Detection Pixel Shaders (First Pass)\n\n/**\n * Luma Edge Detection\n *\n * IMPORTANT NOTICE: luma edge detection requires gamma-corrected colors, and\n * thus 'colorTex' should be a non-sRGB texture.\n */\nfloat2 SMAALumaEdgeDetectionPS(float2 texcoord,\n                               float4 offset[3],\n                               SMAATexture2D(colorTex)\n                               #if SMAA_PREDICATION\n                               , SMAATexture2D(predicationTex)\n                               #endif\n                               ) {\n    // Calculate the threshold:\n    #if SMAA_PREDICATION\n    float2 threshold = SMAACalculatePredicatedThreshold(texcoord, offset, SMAATexturePass2D(predicationTex));\n    #else\n    float2 threshold = float2(SMAA_THRESHOLD, SMAA_THRESHOLD);\n    #endif\n\n    // Calculate lumas:\n    float3 weights = float3(0.2126, 0.7152, 0.0722);\n    float L = dot(SMAASamplePoint(colorTex, texcoord).rgb, weights);\n\n    float Lleft = dot(SMAASamplePoint(colorTex, offset[0].xy).rgb, weights);\n    float Ltop  = dot(SMAASamplePoint(colorTex, offset[0].zw).rgb, weights);\n\n    // We do the usual threshold:\n    float4 delta;\n    delta.xy = abs(L - float2(Lleft, Ltop));\n    float2 edges = step(threshold, delta.xy);\n\n    // Then discard if there is no edge:\n    if (dot(edges, float2(1.0, 1.0)) == 0.0)\n        discard;\n\n    // Calculate right and bottom deltas:\n    float Lright = dot(SMAASamplePoint(colorTex, offset[1].xy).rgb, weights);\n    float Lbottom  = dot(SMAASamplePoint(colorTex, offset[1].zw).rgb, weights);\n    delta.zw = abs(L - float2(Lright, Lbottom));\n\n    // Calculate the maximum delta in the direct neighborhood:\n    float2 maxDelta = max(delta.xy, delta.zw);\n\n    // Calculate left-left and top-top deltas:\n    float Lleftleft = dot(SMAASamplePoint(colorTex, offset[2].xy).rgb, weights);\n    float Ltoptop = dot(SMAASamplePoint(colorTex, offset[2].zw).rgb, weights);\n    delta.zw = abs(float2(Lleft, Ltop) - float2(Lleftleft, Ltoptop));\n\n    // Calculate the final maximum delta:\n    maxDelta = max(maxDelta.xy, delta.zw);\n    float finalDelta = max(maxDelta.x, maxDelta.y);\n\n    // Local contrast adaptation:\n    edges.xy *= step(finalDelta, SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);\n\n    return edges;\n}\n\n/**\n * Color Edge Detection\n *\n * IMPORTANT NOTICE: color edge detection requires gamma-corrected colors, and\n * thus 'colorTex' should be a non-sRGB texture.\n */\nfloat2 SMAAColorEdgeDetectionPS(float2 texcoord,\n                                float4 offset[3],\n                                SMAATexture2D(colorTex)\n                                #if SMAA_PREDICATION\n                                , SMAATexture2D(predicationTex)\n                                #endif\n                                ) {\n    // Calculate the threshold:\n    #if SMAA_PREDICATION\n    float2 threshold = SMAACalculatePredicatedThreshold(texcoord, offset, predicationTex);\n    #else\n    float2 threshold = float2(SMAA_THRESHOLD, SMAA_THRESHOLD);\n    #endif\n\n    // Calculate color deltas:\n    float4 delta;\n    float3 C = SMAASamplePoint(colorTex, texcoord).rgb;\n\n    float3 Cleft = SMAASamplePoint(colorTex, offset[0].xy).rgb;\n    float3 t = abs(C - Cleft);\n    delta.x = max(max(t.r, t.g), t.b);\n\n    float3 Ctop  = SMAASamplePoint(colorTex, offset[0].zw).rgb;\n    t = abs(C - Ctop);\n    delta.y = max(max(t.r, t.g), t.b);\n\n    // We do the usual threshold:\n    float2 edges = step(threshold, delta.xy);\n\n    // Then discard if there is no edge:\n    if (dot(edges, float2(1.0, 1.0)) == 0.0)\n        discard;\n\n    // Calculate right and bottom deltas:\n    float3 Cright = SMAASamplePoint(colorTex, offset[1].xy).rgb;\n    t = abs(C - Cright);\n    delta.z = max(max(t.r, t.g), t.b);\n\n    float3 Cbottom  = SMAASamplePoint(colorTex, offset[1].zw).rgb;\n    t = abs(C - Cbottom);\n    delta.w = max(max(t.r, t.g), t.b);\n\n    // Calculate the maximum delta in the direct neighborhood:\n    float2 maxDelta = max(delta.xy, delta.zw);\n\n    // Calculate left-left and top-top deltas:\n    float3 Cleftleft  = SMAASamplePoint(colorTex, offset[2].xy).rgb;\n    t = abs(C - Cleftleft);\n    delta.z = max(max(t.r, t.g), t.b);\n\n    float3 Ctoptop = SMAASamplePoint(colorTex, offset[2].zw).rgb;\n    t = abs(C - Ctoptop);\n    delta.w = max(max(t.r, t.g), t.b);\n\n    // Calculate the final maximum delta:\n    maxDelta = max(maxDelta.xy, delta.zw);\n    float finalDelta = max(maxDelta.x, maxDelta.y);\n\n    // Local contrast adaptation:\n    edges.xy *= step(finalDelta, SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);\n\n    return edges;\n}\n\n/**\n * Depth Edge Detection\n */\nfloat2 SMAADepthEdgeDetectionPS(float2 texcoord,\n                                float4 offset[3],\n                                SMAATexture2D(depthTex)) {\n    float3 neighbours = SMAAGatherNeighbours(texcoord, offset, SMAATexturePass2D(depthTex));\n    float2 delta = abs(neighbours.xx - float2(neighbours.y, neighbours.z));\n    float2 edges = step(SMAA_DEPTH_THRESHOLD, delta);\n\n    if (dot(edges, float2(1.0, 1.0)) == 0.0)\n        discard;\n\n    return edges;\n}\n\n//-----------------------------------------------------------------------------\n// Diagonal Search Functions\n\n#if !defined(SMAA_DISABLE_DIAG_DETECTION)\n\n/**\n * Allows to decode two binary values from a bilinear-filtered access.\n */\nfloat2 SMAADecodeDiagBilinearAccess(float2 e) {\n    // Bilinear access for fetching 'e' have a 0.25 offset, and we are\n    // interested in the R and G edges:\n    //\n    // +---G---+-------+\n    // |   x o R   x   |\n    // +-------+-------+\n    //\n    // Then, if one of these edge is enabled:\n    //   Red:   (0.75 * X + 0.25 * 1) => 0.25 or 1.0\n    //   Green: (0.75 * 1 + 0.25 * X) => 0.75 or 1.0\n    //\n    // This function will unpack the values (mad + mul + round):\n    // wolframalpha.com: round(x * abs(5 * x - 5 * 0.75)) plot 0 to 1\n    e.r = e.r * abs(5.0 * e.r - 5.0 * 0.75);\n    return round(e);\n}\n\nfloat4 SMAADecodeDiagBilinearAccess(float4 e) {\n    e.rb = e.rb * abs(5.0 * e.rb - 5.0 * 0.75);\n    return round(e);\n}\n\n/**\n * These functions allows to perform diagonal pattern searches.\n */\nfloat2 SMAASearchDiag1(SMAATexture2D(edgesTex), float2 texcoord, float2 dir, out float2 e) {\n    float4 coord = float4(texcoord, -1.0, 1.0);\n    float3 t = float3(SMAA_RT_METRICS.xy, 1.0);\n    while (coord.z < float(SMAA_MAX_SEARCH_STEPS_DIAG - 1) &&\n           coord.w > 0.9) {\n        coord.xyz = mad(t, float3(dir, 1.0), coord.xyz);\n        e = SMAASampleLevelZero(edgesTex, coord.xy).rg;\n        coord.w = dot(e, float2(0.5, 0.5));\n    }\n    return coord.zw;\n}\n\nfloat2 SMAASearchDiag2(SMAATexture2D(edgesTex), float2 texcoord, float2 dir, out float2 e) {\n    float4 coord = float4(texcoord, -1.0, 1.0);\n    coord.x += 0.25 * SMAA_RT_METRICS.x; // See @SearchDiag2Optimization\n    float3 t = float3(SMAA_RT_METRICS.xy, 1.0);\n    while (coord.z < float(SMAA_MAX_SEARCH_STEPS_DIAG - 1) &&\n           coord.w > 0.9) {\n        coord.xyz = mad(t, float3(dir, 1.0), coord.xyz);\n\n        // @SearchDiag2Optimization\n        // Fetch both edges at once using bilinear filtering:\n        e = SMAASampleLevelZero(edgesTex, coord.xy).rg;\n        e = SMAADecodeDiagBilinearAccess(e);\n\n        // Non-optimized version:\n        // e.g = SMAASampleLevelZero(edgesTex, coord.xy).g;\n        // e.r = SMAASampleLevelZeroOffset(edgesTex, coord.xy, int2(1, 0)).r;\n\n        coord.w = dot(e, float2(0.5, 0.5));\n    }\n    return coord.zw;\n}\n\n/** \n * Similar to SMAAArea, this calculates the area corresponding to a certain\n * diagonal distance and crossing edges 'e'.\n */\nfloat2 SMAAAreaDiag(SMAATexture2D(areaTex), float2 dist, float2 e, float offset) {\n    float2 texcoord = mad(float2(SMAA_AREATEX_MAX_DISTANCE_DIAG, SMAA_AREATEX_MAX_DISTANCE_DIAG), e, dist);\n\n    // We do a scale and bias for mapping to texel space:\n    texcoord = mad(SMAA_AREATEX_PIXEL_SIZE, texcoord, 0.5 * SMAA_AREATEX_PIXEL_SIZE);\n\n    // Diagonal areas are on the second half of the texture:\n    texcoord.x += 0.5;\n\n    // Move to proper place, according to the subpixel offset:\n    texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n\n    // Do it!\n    return SMAA_AREATEX_SELECT(SMAASampleLevelZero(areaTex, texcoord));\n}\n\n/**\n * This searches for diagonal patterns and returns the corresponding weights.\n */\nfloat2 SMAACalculateDiagWeights(SMAATexture2D(edgesTex), SMAATexture2D(areaTex), float2 texcoord, float2 e, float4 subsampleIndices) {\n    float2 weights = float2(0.0, 0.0);\n\n    // Search for the line ends:\n    float4 d;\n    float2 end;\n    if (e.r > 0.0) {\n        d.xz = SMAASearchDiag1(SMAATexturePass2D(edgesTex), texcoord, float2(-1.0,  1.0), end);\n        d.x += float(end.y > 0.9);\n    } else\n        d.xz = float2(0.0, 0.0);\n    d.yw = SMAASearchDiag1(SMAATexturePass2D(edgesTex), texcoord, float2(1.0, -1.0), end);\n\n    SMAA_BRANCH\n    if (d.x + d.y > 2.0) { // d.x + d.y + 1 > 3\n        // Fetch the crossing edges:\n        float4 coords = mad(float4(-d.x + 0.25, d.x, d.y, -d.y - 0.25), SMAA_RT_METRICS.xyxy, texcoord.xyxy);\n        float4 c;\n        c.xy = SMAASampleLevelZeroOffset(edgesTex, coords.xy, int2(-1,  0)).rg;\n        c.zw = SMAASampleLevelZeroOffset(edgesTex, coords.zw, int2( 1,  0)).rg;\n        c.yxwz = SMAADecodeDiagBilinearAccess(c.xyzw);\n\n        // Non-optimized version:\n        // float4 coords = mad(float4(-d.x, d.x, d.y, -d.y), SMAA_RT_METRICS.xyxy, texcoord.xyxy);\n        // float4 c;\n        // c.x = SMAASampleLevelZeroOffset(edgesTex, coords.xy, int2(-1,  0)).g;\n        // c.y = SMAASampleLevelZeroOffset(edgesTex, coords.xy, int2( 0,  0)).r;\n        // c.z = SMAASampleLevelZeroOffset(edgesTex, coords.zw, int2( 1,  0)).g;\n        // c.w = SMAASampleLevelZeroOffset(edgesTex, coords.zw, int2( 1, -1)).r;\n\n        // Merge crossing edges at each side into a single value:\n        float2 cc = mad(float2(2.0, 2.0), c.xz, c.yw);\n\n        // Remove the crossing edge if we didn't found the end of the line:\n        SMAAMovc(bool2(step(0.9, d.zw)), cc, float2(0.0, 0.0));\n\n        // Fetch the areas for this line:\n        weights += SMAAAreaDiag(SMAATexturePass2D(areaTex), d.xy, cc, subsampleIndices.z);\n    }\n\n    // Search for the line ends:\n    d.xz = SMAASearchDiag2(SMAATexturePass2D(edgesTex), texcoord, float2(-1.0, -1.0), end);\n    if (SMAASampleLevelZeroOffset(edgesTex, texcoord, int2(1, 0)).r > 0.0) {\n        d.yw = SMAASearchDiag2(SMAATexturePass2D(edgesTex), texcoord, float2(1.0, 1.0), end);\n        d.y += float(end.y > 0.9);\n    } else\n        d.yw = float2(0.0, 0.0);\n\n    SMAA_BRANCH\n    if (d.x + d.y > 2.0) { // d.x + d.y + 1 > 3\n        // Fetch the crossing edges:\n        float4 coords = mad(float4(-d.x, -d.x, d.y, d.y), SMAA_RT_METRICS.xyxy, texcoord.xyxy);\n        float4 c;\n        c.x  = SMAASampleLevelZeroOffset(edgesTex, coords.xy, int2(-1,  0)).g;\n        c.y  = SMAASampleLevelZeroOffset(edgesTex, coords.xy, int2( 0, -1)).r;\n        c.zw = SMAASampleLevelZeroOffset(edgesTex, coords.zw, int2( 1,  0)).gr;\n        float2 cc = mad(float2(2.0, 2.0), c.xz, c.yw);\n\n        // Remove the crossing edge if we didn't found the end of the line:\n        SMAAMovc(bool2(step(0.9, d.zw)), cc, float2(0.0, 0.0));\n\n        // Fetch the areas for this line:\n        weights += SMAAAreaDiag(SMAATexturePass2D(areaTex), d.xy, cc, subsampleIndices.w).gr;\n    }\n\n    return weights;\n}\n#endif\n\n//-----------------------------------------------------------------------------\n// Horizontal/Vertical Search Functions\n\n/**\n * This allows to determine how much length should we add in the last step\n * of the searches. It takes the bilinearly interpolated edge (see \n * @PSEUDO_GATHER4), and adds 0, 1 or 2, depending on which edges and\n * crossing edges are active.\n */\nfloat SMAASearchLength(SMAATexture2D(searchTex), float2 e, float offset) {\n    // The texture is flipped vertically, with left and right cases taking half\n    // of the space horizontally:\n    float2 scale = SMAA_SEARCHTEX_SIZE * float2(0.5, -1.0);\n    float2 bias = SMAA_SEARCHTEX_SIZE * float2(offset, 1.0);\n\n    // Scale and bias to access texel centers:\n    scale += float2(-1.0,  1.0);\n    bias  += float2( 0.5, -0.5);\n\n    // Convert from pixel coordinates to texcoords:\n    // (We use SMAA_SEARCHTEX_PACKED_SIZE because the texture is cropped)\n    scale *= 1.0 / SMAA_SEARCHTEX_PACKED_SIZE;\n    bias *= 1.0 / SMAA_SEARCHTEX_PACKED_SIZE;\n\n    // Lookup the search texture:\n    return SMAA_SEARCHTEX_SELECT(SMAASampleLevelZero(searchTex, mad(scale, e, bias)));\n}\n\n/**\n * Horizontal/vertical search functions for the 2nd pass.\n */\nfloat SMAASearchXLeft(SMAATexture2D(edgesTex), SMAATexture2D(searchTex), float2 texcoord, float end) {\n    /**\n     * @PSEUDO_GATHER4\n     * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n     * sample between edge, thus fetching four edges in a row.\n     * Sampling with different offsets in each direction allows to disambiguate\n     * which edges are active from the four fetched ones.\n     */\n    float2 e = float2(0.0, 1.0);\n    while (texcoord.x > end && \n           e.g > 0.8281 && // Is there some edge not activated?\n           e.r == 0.0) { // Or is there a crossing edge that breaks the line?\n        e = SMAASampleLevelZero(edgesTex, texcoord).rg;\n        texcoord = mad(-float2(2.0, 0.0), SMAA_RT_METRICS.xy, texcoord);\n    }\n\n    float offset = mad(-(255.0 / 127.0), SMAASearchLength(SMAATexturePass2D(searchTex), e, 0.0), 3.25);\n    return mad(SMAA_RT_METRICS.x, offset, texcoord.x);\n\n    // Non-optimized version:\n    // We correct the previous (-0.25, -0.125) offset we applied:\n    // texcoord.x += 0.25 * SMAA_RT_METRICS.x;\n\n    // The searches are bias by 1, so adjust the coords accordingly:\n    // texcoord.x += SMAA_RT_METRICS.x;\n\n    // Disambiguate the length added by the last step:\n    // texcoord.x += 2.0 * SMAA_RT_METRICS.x; // Undo last step\n    // texcoord.x -= SMAA_RT_METRICS.x * (255.0 / 127.0) * SMAASearchLength(SMAATexturePass2D(searchTex), e, 0.0);\n    // return mad(SMAA_RT_METRICS.x, offset, texcoord.x);\n}\n\nfloat SMAASearchXRight(SMAATexture2D(edgesTex), SMAATexture2D(searchTex), float2 texcoord, float end) {\n    float2 e = float2(0.0, 1.0);\n    while (texcoord.x < end && \n           e.g > 0.8281 && // Is there some edge not activated?\n           e.r == 0.0) { // Or is there a crossing edge that breaks the line?\n        e = SMAASampleLevelZero(edgesTex, texcoord).rg;\n        texcoord = mad(float2(2.0, 0.0), SMAA_RT_METRICS.xy, texcoord);\n    }\n    float offset = mad(-(255.0 / 127.0), SMAASearchLength(SMAATexturePass2D(searchTex), e, 0.5), 3.25);\n    return mad(-SMAA_RT_METRICS.x, offset, texcoord.x);\n}\n\nfloat SMAASearchYUp(SMAATexture2D(edgesTex), SMAATexture2D(searchTex), float2 texcoord, float end) {\n    float2 e = float2(1.0, 0.0);\n    while (texcoord.y > end && \n           e.r > 0.8281 && // Is there some edge not activated?\n           e.g == 0.0) { // Or is there a crossing edge that breaks the line?\n        e = SMAASampleLevelZero(edgesTex, texcoord).rg;\n        texcoord = mad(-float2(0.0, 2.0), SMAA_RT_METRICS.xy, texcoord);\n    }\n    float offset = mad(-(255.0 / 127.0), SMAASearchLength(SMAATexturePass2D(searchTex), e.gr, 0.0), 3.25);\n    return mad(SMAA_RT_METRICS.y, offset, texcoord.y);\n}\n\nfloat SMAASearchYDown(SMAATexture2D(edgesTex), SMAATexture2D(searchTex), float2 texcoord, float end) {\n    float2 e = float2(1.0, 0.0);\n    while (texcoord.y < end && \n           e.r > 0.8281 && // Is there some edge not activated?\n           e.g == 0.0) { // Or is there a crossing edge that breaks the line?\n        e = SMAASampleLevelZero(edgesTex, texcoord).rg;\n        texcoord = mad(float2(0.0, 2.0), SMAA_RT_METRICS.xy, texcoord);\n    }\n    float offset = mad(-(255.0 / 127.0), SMAASearchLength(SMAATexturePass2D(searchTex), e.gr, 0.5), 3.25);\n    return mad(-SMAA_RT_METRICS.y, offset, texcoord.y);\n}\n\n/** \n * Ok, we have the distance and both crossing edges. So, what are the areas\n * at each side of current edge?\n */\nfloat2 SMAAArea(SMAATexture2D(areaTex), float2 dist, float e1, float e2, float offset) {\n    // Rounding prevents precision errors of bilinear filtering:\n    float2 texcoord = mad(float2(SMAA_AREATEX_MAX_DISTANCE, SMAA_AREATEX_MAX_DISTANCE), round(4.0 * float2(e1, e2)), dist);\n    \n    // We do a scale and bias for mapping to texel space:\n    texcoord = mad(SMAA_AREATEX_PIXEL_SIZE, texcoord, 0.5 * SMAA_AREATEX_PIXEL_SIZE);\n\n    // Move to proper place, according to the subpixel offset:\n    texcoord.y = mad(SMAA_AREATEX_SUBTEX_SIZE, offset, texcoord.y);\n\n    // Do it!\n    return SMAA_AREATEX_SELECT(SMAASampleLevelZero(areaTex, texcoord));\n}\n\n//-----------------------------------------------------------------------------\n// Corner Detection Functions\n\nvoid SMAADetectHorizontalCornerPattern(SMAATexture2D(edgesTex), inout float2 weights, float4 texcoord, float2 d) {\n    #if !defined(SMAA_DISABLE_CORNER_DETECTION)\n    float2 leftRight = step(d.xy, d.yx);\n    float2 rounding = (1.0 - SMAA_CORNER_ROUNDING_NORM) * leftRight;\n\n    rounding /= leftRight.x + leftRight.y; // Reduce blending for pixels in the center of a line.\n\n    float2 factor = float2(1.0, 1.0);\n    factor.x -= rounding.x * SMAASampleLevelZeroOffset(edgesTex, texcoord.xy, int2(0,  1)).r;\n    factor.x -= rounding.y * SMAASampleLevelZeroOffset(edgesTex, texcoord.zw, int2(1,  1)).r;\n    factor.y -= rounding.x * SMAASampleLevelZeroOffset(edgesTex, texcoord.xy, int2(0, -2)).r;\n    factor.y -= rounding.y * SMAASampleLevelZeroOffset(edgesTex, texcoord.zw, int2(1, -2)).r;\n\n    weights *= saturate(factor);\n    #endif\n}\n\nvoid SMAADetectVerticalCornerPattern(SMAATexture2D(edgesTex), inout float2 weights, float4 texcoord, float2 d) {\n    #if !defined(SMAA_DISABLE_CORNER_DETECTION)\n    float2 leftRight = step(d.xy, d.yx);\n    float2 rounding = (1.0 - SMAA_CORNER_ROUNDING_NORM) * leftRight;\n\n    rounding /= leftRight.x + leftRight.y;\n\n    float2 factor = float2(1.0, 1.0);\n    factor.x -= rounding.x * SMAASampleLevelZeroOffset(edgesTex, texcoord.xy, int2( 1, 0)).g;\n    factor.x -= rounding.y * SMAASampleLevelZeroOffset(edgesTex, texcoord.zw, int2( 1, 1)).g;\n    factor.y -= rounding.x * SMAASampleLevelZeroOffset(edgesTex, texcoord.xy, int2(-2, 0)).g;\n    factor.y -= rounding.y * SMAASampleLevelZeroOffset(edgesTex, texcoord.zw, int2(-2, 1)).g;\n\n    weights *= saturate(factor);\n    #endif\n}\n\n//-----------------------------------------------------------------------------\n// Blending Weight Calculation Pixel Shader (Second Pass)\n\nfloat4 SMAABlendingWeightCalculationPS(float2 texcoord,\n                                       float2 pixcoord,\n                                       float4 offset[3],\n                                       SMAATexture2D(edgesTex),\n                                       SMAATexture2D(areaTex),\n                                       SMAATexture2D(searchTex),\n                                       float4 subsampleIndices) { // Just pass zero for SMAA 1x, see @SUBSAMPLE_INDICES.\n    float4 weights = float4(0.0, 0.0, 0.0, 0.0);\n\n    float2 e = SMAASample(edgesTex, texcoord).rg;\n\n    SMAA_BRANCH\n    if (e.g > 0.0) { // Edge at north\n        #if !defined(SMAA_DISABLE_DIAG_DETECTION)\n        // Diagonals have both north and west edges, so searching for them in\n        // one of the boundaries is enough.\n        weights.rg = SMAACalculateDiagWeights(SMAATexturePass2D(edgesTex), SMAATexturePass2D(areaTex), texcoord, e, subsampleIndices);\n\n        // We give priority to diagonals, so if we find a diagonal we skip \n        // horizontal/vertical processing.\n        SMAA_BRANCH\n        if (weights.r == -weights.g) { // weights.r + weights.g == 0.0\n        #endif\n\n        float2 d;\n\n        // Find the distance to the left:\n        float3 coords;\n        coords.x = SMAASearchXLeft(SMAATexturePass2D(edgesTex), SMAATexturePass2D(searchTex), offset[0].xy, offset[2].x);\n        coords.y = offset[1].y; // offset[1].y = texcoord.y - 0.25 * SMAA_RT_METRICS.y (@CROSSING_OFFSET)\n        d.x = coords.x;\n\n        // Now fetch the left crossing edges, two at a time using bilinear\n        // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n        // discern what value each edge has:\n        float e1 = SMAASampleLevelZero(edgesTex, coords.xy).r;\n\n        // Find the distance to the right:\n        coords.z = SMAASearchXRight(SMAATexturePass2D(edgesTex), SMAATexturePass2D(searchTex), offset[0].zw, offset[2].y);\n        d.y = coords.z;\n\n        // We want the distances to be in pixel units (doing this here allow to\n        // better interleave arithmetic and memory accesses):\n        d = abs(round(mad(SMAA_RT_METRICS.zz, d, -pixcoord.xx)));\n\n        // SMAAArea below needs a sqrt, as the areas texture is compressed\n        // quadratically:\n        float2 sqrt_d = sqrt(d);\n\n        // Fetch the right crossing edges:\n        float e2 = SMAASampleLevelZeroOffset(edgesTex, coords.zy, int2(1, 0)).r;\n\n        // Ok, we know how this pattern looks like, now it is time for getting\n        // the actual area:\n        weights.rg = SMAAArea(SMAATexturePass2D(areaTex), sqrt_d, e1, e2, subsampleIndices.y);\n\n        // Fix corners:\n        coords.y = texcoord.y;\n        SMAADetectHorizontalCornerPattern(SMAATexturePass2D(edgesTex), weights.rg, coords.xyzy, d);\n\n        #if !defined(SMAA_DISABLE_DIAG_DETECTION)\n        } else\n            e.r = 0.0; // Skip vertical processing.\n        #endif\n    }\n\n    SMAA_BRANCH\n    if (e.r > 0.0) { // Edge at west\n        float2 d;\n\n        // Find the distance to the top:\n        float3 coords;\n        coords.y = SMAASearchYUp(SMAATexturePass2D(edgesTex), SMAATexturePass2D(searchTex), offset[1].xy, offset[2].z);\n        coords.x = offset[0].x; // offset[1].x = texcoord.x - 0.25 * SMAA_RT_METRICS.x;\n        d.x = coords.y;\n\n        // Fetch the top crossing edges:\n        float e1 = SMAASampleLevelZero(edgesTex, coords.xy).g;\n\n        // Find the distance to the bottom:\n        coords.z = SMAASearchYDown(SMAATexturePass2D(edgesTex), SMAATexturePass2D(searchTex), offset[1].zw, offset[2].w);\n        d.y = coords.z;\n\n        // We want the distances to be in pixel units:\n        d = abs(round(mad(SMAA_RT_METRICS.ww, d, -pixcoord.yy)));\n\n        // SMAAArea below needs a sqrt, as the areas texture is compressed \n        // quadratically:\n        float2 sqrt_d = sqrt(d);\n\n        // Fetch the bottom crossing edges:\n        float e2 = SMAASampleLevelZeroOffset(edgesTex, coords.xz, int2(0, 1)).g;\n\n        // Get the area for this direction:\n        weights.ba = SMAAArea(SMAATexturePass2D(areaTex), sqrt_d, e1, e2, subsampleIndices.x);\n\n        // Fix corners:\n        coords.x = texcoord.x;\n        SMAADetectVerticalCornerPattern(SMAATexturePass2D(edgesTex), weights.ba, coords.xyxz, d);\n    }\n\n    return weights;\n}\n\n//-----------------------------------------------------------------------------\n// Neighborhood Blending Pixel Shader (Third Pass)\n\nfloat4 SMAANeighborhoodBlendingPS(float2 texcoord,\n                                  float4 offset,\n                                  SMAATexture2D(colorTex),\n                                  SMAATexture2D(blendTex)\n                                  #if SMAA_REPROJECTION\n                                  , SMAATexture2D(velocityTex)\n                                  #endif\n                                  ) {\n    // Fetch the blending weights for current pixel:\n    float4 a;\n    a.x = SMAASample(blendTex, offset.xy).a; // Right\n    a.y = SMAASample(blendTex, offset.zw).g; // Top\n    a.wz = SMAASample(blendTex, texcoord).xz; // Bottom / Left\n\n    // Is there any blending weight with a value greater than 0.0?\n    SMAA_BRANCH\n    if (dot(a, float4(1.0, 1.0, 1.0, 1.0)) < 1e-5) {\n        float4 color = SMAASampleLevelZero(colorTex, texcoord);\n\n        #if SMAA_REPROJECTION\n        float2 velocity = SMAA_DECODE_VELOCITY(SMAASampleLevelZero(velocityTex, texcoord));\n\n        // Pack velocity into the alpha channel:\n        color.a = sqrt(5.0 * length(velocity));\n        #endif\n\n        return color;\n    } else {\n        bool h = max(a.x, a.z) > max(a.y, a.w); // max(horizontal) > max(vertical)\n\n        // Calculate the blending offsets:\n        float4 blendingOffset = float4(0.0, a.y, 0.0, a.w);\n        float2 blendingWeight = a.yw;\n        SMAAMovc(bool4(h, h, h, h), blendingOffset, float4(a.x, 0.0, a.z, 0.0));\n        SMAAMovc(bool2(h, h), blendingWeight, a.xz);\n        blendingWeight /= dot(blendingWeight, float2(1.0, 1.0));\n\n        // Calculate the texture coordinates:\n        float4 blendingCoord = mad(blendingOffset, float4(SMAA_RT_METRICS.xy, -SMAA_RT_METRICS.xy), texcoord.xyxy);\n\n        // We exploit bilinear filtering to mix current pixel with the chosen\n        // neighbor:\n        float4 color = blendingWeight.x * SMAASampleLevelZero(colorTex, blendingCoord.xy);\n        color += blendingWeight.y * SMAASampleLevelZero(colorTex, blendingCoord.zw);\n\n        #if SMAA_REPROJECTION\n        // Antialias velocity for proper reprojection in a later stage:\n        float2 velocity = blendingWeight.x * SMAA_DECODE_VELOCITY(SMAASampleLevelZero(velocityTex, blendingCoord.xy));\n        velocity += blendingWeight.y * SMAA_DECODE_VELOCITY(SMAASampleLevelZero(velocityTex, blendingCoord.zw));\n\n        // Pack velocity into the alpha channel:\n        color.a = sqrt(5.0 * length(velocity));\n        #endif\n\n        return color;\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Temporal Resolve Pixel Shader (Optional Pass)\n\nfloat4 SMAAResolvePS(float2 texcoord,\n                     SMAATexture2D(currentColorTex),\n                     SMAATexture2D(previousColorTex)\n                     #if SMAA_REPROJECTION\n                     , SMAATexture2D(velocityTex)\n                     #endif\n                     ) {\n    #if SMAA_REPROJECTION\n    // Velocity is assumed to be calculated for motion blur, so we need to\n    // inverse it for reprojection:\n    float2 velocity = -SMAA_DECODE_VELOCITY(SMAASamplePoint(velocityTex, texcoord).rg);\n\n    // Fetch current pixel:\n    float4 current = SMAASamplePoint(currentColorTex, texcoord);\n\n    // Reproject current coordinates and fetch previous pixel:\n    float4 previous = SMAASamplePoint(previousColorTex, texcoord + velocity);\n\n    // Attenuate the previous pixel if the velocity is different:\n    float delta = abs(current.a * current.a - previous.a * previous.a) / 5.0;\n    float weight = 0.5 * saturate(1.0 - sqrt(delta) * SMAA_REPROJECTION_WEIGHT_SCALE);\n\n    // Blend the pixels according to the calculated weight:\n    return lerp(current, previous, weight);\n    #else\n    // Just blend the pixels:\n    float4 current = SMAASamplePoint(currentColorTex, texcoord);\n    float4 previous = SMAASamplePoint(previousColorTex, texcoord);\n    return lerp(current, previous, 0.5);\n    #endif\n}\n\n//-----------------------------------------------------------------------------\n// Separate Multisamples Pixel Shader (Optional Pass)\n\n#ifdef SMAALoad\nvoid SMAASeparatePS(float4 position,\n                    float2 texcoord,\n                    out float4 target0,\n                    out float4 target1,\n                    SMAATexture2DMS2(colorTexMS)) {\n    int2 pos = int2(position.xy);\n    target0 = SMAALoad(colorTexMS, pos, 0);\n    target1 = SMAALoad(colorTexMS, pos, 1);\n}\n#endif\n\n//-----------------------------------------------------------------------------\n#endif // SMAA_INCLUDE_PS\n";
				default:
					return null;
			}
		}

	    private static readonly Include IncludeFx = new IncludeImplementation();

	    private class IncludeImplementation : Include {
	        public void Open(IncludeType type, string fileName, Stream parentStream, out Stream stream) {
	            stream = new MemoryStream(Encoding.UTF8.GetBytes(GetIncludedData(fileName)));
	        }

	        public void Close(Stream stream) {
                stream.Close();
                stream.Dispose();
	        }
	    }

		internal static ShaderBytecode Compile(byte[] data, string name = "") {
            try {
                return ShaderBytecode.Compile(data, "Render", "fx_5_0", ShaderFlags.None, EffectFlags.None, null, IncludeFx);
            } catch (System.Exception e) {
				System.Diagnostics.Debug.WriteLine("Shader " + (name ?? "?") + " compilation failed:\n\n" + e.Message);
                System.Windows.Forms.MessageBox.Show("Shader " + (name ?? "?") + " compilation failed:\n\n" + e.Message);
				System.Environment.Exit(1);
				return null;
            }
        }
		
        public static void Set(this EffectVariable variable, EffectDeferredGObject.PosOnly_PS_IN o) {
            SlimDxExtension.Set(variable, o, EffectDeferredGObject.PosOnly_PS_IN.Stride);
        }
        public static void Set(this EffectVariable variable, EffectDeferredGObject.Material o) {
            SlimDxExtension.Set(variable, o, EffectDeferredGObject.Material.Stride);
        }
        public static void Set(this EffectVariable variable, EffectDeferredGObject.AmbientShadow_VS_IN o) {
            SlimDxExtension.Set(variable, o, EffectDeferredGObject.AmbientShadow_VS_IN.Stride);
        }
        public static void Set(this EffectVariable variable, EffectDeferredGObject.AmbientShadow_PS_IN o) {
            SlimDxExtension.Set(variable, o, EffectDeferredGObject.AmbientShadow_PS_IN.Stride);
        }
        public static void Set(this EffectVariable variable, EffectDeferredGObjectSpecial.PosOnly_PS_IN o) {
            SlimDxExtension.Set(variable, o, EffectDeferredGObjectSpecial.PosOnly_PS_IN.Stride);
        }
        public static void Set(this EffectVariable variable, EffectDeferredGObjectSpecial.SpecialGl_PS_IN o) {
            SlimDxExtension.Set(variable, o, EffectDeferredGObjectSpecial.SpecialGl_PS_IN.Stride);
        }
        public static void Set(this EffectVariable variable, EffectDeferredGSky.PosOnly_PS_IN o) {
            SlimDxExtension.Set(variable, o, EffectDeferredGSky.PosOnly_PS_IN.Stride);
        }
        public static void Set(this EffectVariable variable, EffectDeferredGSky.Sky_VS_IN o) {
            SlimDxExtension.Set(variable, o, EffectDeferredGSky.Sky_VS_IN.Stride);
        }
        public static void Set(this EffectVariable variable, EffectDeferredGSky.Sky_PS_IN o) {
            SlimDxExtension.Set(variable, o, EffectDeferredGSky.Sky_PS_IN.Stride);
        }
        public static void Set(this EffectVariable variable, EffectKunosShader.Material o) {
            SlimDxExtension.Set(variable, o, EffectKunosShader.Material.Stride);
        }
        public static void Set(this EffectVariable variable, EffectPpFxaa311.FxaaVS_Output o) {
            SlimDxExtension.Set(variable, o, EffectPpFxaa311.FxaaVS_Output.Stride);
        }
        public static void Set(this EffectVariable variable, EffectPpSmaa.Smaa_PS_IN o) {
            SlimDxExtension.Set(variable, o, EffectPpSmaa.Smaa_PS_IN.Stride);
        }
        public static void Set(this EffectVariable variable, EffectPpSmaa.Smaa_B_PS_IN o) {
            SlimDxExtension.Set(variable, o, EffectPpSmaa.Smaa_B_PS_IN.Stride);
        }
        public static void Set(this EffectVariable variable, EffectPpSmaa.Smaa_N_PS_IN o) {
            SlimDxExtension.Set(variable, o, EffectPpSmaa.Smaa_N_PS_IN.Stride);
        }
	}
}
